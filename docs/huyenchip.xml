<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<title>Chip Huyen</title>
<link>https://huyenchip.com</link>


<item>
<title>Building A Generative AI Platform</title>
<link>https://huyenchip.com//2024/07/25/genai-platform.html</link>
<guid>https://huyenchip.com//2024/07/25/genai-platform.html</guid>
<content:encoded><![CDATA[
<div> 构建平台、增强上下文、保护组件、优化性能、监控系统
<br /><br />总结:本文介绍了部署生成式AI应用的常见组件和架构。从简单的架构开始，逐步添加组件，包括增强上下文、保护措施、模型路由器、缓存和复杂逻辑。同时讨论了监控系统的重要性，包括日志、追踪和指标。最后，探讨了AI管道编排的重要性，指出选择合适的编排工具需要考虑集成性、支持复杂管道和易用性、性能和可扩展性。 <div>
<p>After studying how companies deploy generative AI applications, I noticed many similarities in their platforms. This post outlines the common components of a generative AI platform, what they do, and how they are implemented. I try my best to keep the architecture general, but certain applications might deviate. This is what the overall architecture looks like.</p>

<center>
    <figure>
    <img alt="Overview of a genai platform" src="/assets/pics/genai-platform/1-genai-platform.png" style="float: center; margin: 0 0 0em 0em;" />
    </figure>
</center>
<p><br />
This is a pretty complex system. This post will start from the simplest architecture and progressively add more components. In its simplest form, your application receives a query and sends it to the model. The model generates a response, which is returned to the user. There are no guardrails, no augmented context, and no optimization. The <strong>Model API</strong> box refers to both third-party APIs (e.g., OpenAI, Google, Anthropic) and self-hosted APIs.</p>

<center>
    <figure>
    <img alt="Overview of a genai platform" src="/assets/pics/genai-platform/2.png" style="float: center; margin: 0 0 0em 0em;" />
    </figure>
</center>
<p><br />
From this, you can add more components as needs arise. The order discussed in this post is common, though you don’t need to follow the exact same order. A component can be skipped if your system works well without it. Evaluation is necessary at every step of the development process.</p>

<ol>
  <li>Enhance context input into a model by giving the model access to external data sources and tools for information gathering.</li>
  <li>Put in guardrails to protect your system and your users.</li>
  <li>Add model router and gateway to support complex pipelines and add more security.</li>
  <li>Optimize for latency and costs with cache.</li>
  <li>Add complex logic and write actions to maximize your system’s capabilities.</li>
</ol>

<p>Observability, which allows you to gain visibility into your system for monitoring and debugging, and orchestration, which involves chaining all the components together, are two essential components of the platform. We will discuss them at the end of this post.</p>

<p><strong>» What this post is not «</strong></p>

<p><em>This post focuses on the overall architecture for deploying AI applications. It discusses what components are needed and considerations when building these components. It’s not about how to build AI applications and, therefore, does NOT discuss model evaluation, application evaluation, prompt engineering, finetuning, data annotation guidelines, or chunking strategies for RAGs. All these topics are covered in my upcoming book <a href="https://learning.oreilly.com/library/view/ai-engineering/9781098166298/">AI Engineering</a>.</em></p>

<hr />
<p><b>Table of contents</b><br />
<a href="#step_1_enhance_context">Step 1. Enhance Context</a><br />
….<a href="#rags">RAGs</a><br />
….<a href="#rags_with_tabular_data">RAGs with tabular data</a><br />
….<a href="#agentic_rags">Agentic RAGs</a><br />
….<a href="#query_rewriting">Query rewriting</a><br />
<a href="#step_2_put_in_guardrails">Step 2. Put in Guardrails</a><br />
….<a href="#input_guardrails">Input guardrails</a><br />
……..<a href="#leaking_private_information_to_external_apis">Leaking private information to external APIs</a><br />
……..<a href="#jailbreaking">Model jailbreaking</a><br />
….<a href="#output_guardrails">Output guardrails</a><br />
……..<a href="#output_quality_measurement">Output quality measurement</a><br />
……..<a href="#failure_management">Failure management</a><br />
….<a href="#guardrail_tradeoffs">Guardrail tradeoffs</a><br />
<a href="#step_3_add_model_router_and_gateway">Step 3. Add Model Router and Gateway</a><br />
….<a href="#router">Router</a><br />
….<a href="#gateway">Gateway</a><br />
<a href="#step_4_reduce_latency_with_cache">Step 4. Reduce Latency with Cache</a><br />
….<a href="#prompt_cache">Prompt cache</a><br />
….<a href="#exact_cache">Exact cache</a><br />
….<a href="#semantic_cache">Semantic cache</a><br />
<a href="#step_5_add_complex_logic_and_write_actions">Step 5. Add complex logic and write actions</a><br />
….<a href="#complex_logic">Complex logic</a><br />
….<a href="#write_actions">Write actions</a><br />
<a href="#observability">Observability</a><br />
….<a href="#metrics">Metrics</a><br />
….<a href="#logs">Logs</a><br />
….<a href="#traces">Traces</a><br />
<a href="#ai_pipeline_orchestration">AI Pipeline Orchestration</a><br />
<a href="#conclusion">Conclusion</a><br />
<a href="#references_and_acknowledgments">References and Acknowledgments</a><br /></p>

<hr />
<p><br /></p>

<h2 id="step_1_enhance_context">Step 1. Enhance Context</h2>

<p>The initial expansion of a platform usually involves adding mechanisms to allow the system to augment each query with the necessary information. Gathering the relevant information is called context construction.</p>

<p>Many queries require context to answer. The more relevant information there is in the context, the less the model has to rely on its internal knowledge, which can be unreliable due to its training data and training methodology. Studies have shown that having access to relevant information in the context can help the model generate more detailed responses while reducing hallucinations (<a href="https://arxiv.org/abs/2005.11401">Lewis et al.</a>, 2020).</p>

<p>For example, given the query “Will Acme’s fancy-printer-A300 print 100pps?”, the model will be able to respond better if it’s given the specifications of fancy-printer-A300. (Thanks Chetan Tekur for the example.)</p>

<p>Context construction for foundation models is equivalent to feature engineering for classical ML models. They serve the same purpose: giving the model the necessary information to process an input.</p>

<p>In-context learning, learning from the context, is a form of continual learning. It enables a model to incorporate new information continually to make decisions, preventing it from becoming outdated. For example, a model trained on last-week data won’t be able to answer questions about this week unless the new information is included in its context. By updating a model’s context with the latest information, e.g. fancy-printer-A300’s latest specifications, the model remains up-to-date and can respond to queries beyond its cut-off date.</p>

<h3 id="rags">RAGs</h3>

<p>The most well-known pattern for context construction is RAG, Retrieval-Augmented Generation. RAG consists of two components: a generator (e.g. a language model) and a retriever, which retrieves relevant information from external sources.</p>

<center>
    <figure>
    <img alt="Overview of a genai platform" src="/assets/pics/genai-platform/3-rag.png" style="float: center; margin: 0 0 0em 0em;" />
    </figure>
</center>
<p><br />
Retrieval isn’t unique to RAGs. It’s the backbone of search engines, recommender systems, log analytics, etc. Many retrieval algorithms developed for traditional retrieval systems can be used for RAGs.</p>

<p>External memory sources typically contain unstructured data, such as memos, contracts, news updates, etc. They can be collectively called <em>documents</em>. A document can be 10 tokens or 1 million tokens. Naively retrieving whole documents can cause your context to be arbitrarily long. RAG typically requires documents to be split into <em>manageable chunks</em>, which can be determined from the model’s maximum context length and your application’s latency requirements. To learn more about chunking and the optimal chunk size, see <a href="https://www.pinecone.io/learn/chunking-strategies/">Pinecone</a>, <a href="https://js.langchain.com/v0.1/docs/modules/data_connection/document_transformers/">Langchain</a>, <a href="https://docs.llamaindex.ai/en/stable/optimizing/production_rag/">Llamaindex</a>, and <a href="https://www.youtube.com/watch?v=8OJC21T2SL4">Greg Kamradt</a>’s tutorials.</p>

<p>Once data from external memory sources has been loaded and chunked, retrieval is performed using two main approaches.</p>

<ol>
  <li><strong>Term-based retrieval</strong> <br />
This can be as simple as keyword search. For example, given the query “transformer”, fetch all documents containing this keyword. More sophisticated algorithms include BM25 (which leverages TF-IDF) and Elasticsearch (which leverages inverted index). <br />
 <br />
Term-based retrieval is usually used for text data, but it also works for images and videos that have text metadata such as titles, tags, captions, comments, etc.
<br />
<br /></li>
  <li>
    <p><strong>Embedding-based retrieval</strong> (also known as vector search) <br />
You convert chunks of data into embedding vectors using an embedding model such as <a href="https://arxiv.org/abs/1810.04805">BERT</a>, <a href="https://github.com/UKPLab/sentence-transformers">sentence-transformers</a>, and proprietary embedding models provided by OpenAI or Google. Given a query, the data whose vectors are closest to the query embedding, as determined by the vector search algorithm, is retrieved. <br />
 <br />
Vector search is usually framed as nearest-neighbor search, using approximate nearest neighbor (ANN) algorithms such as <a href="https://arxiv.org/abs/1702.08734">FAISS</a> (Facebook AI Similarity Search), Google’s <a href="https://research.google/blog/announcing-scann-efficient-vector-similarity-search/">ScaNN</a>, Spotify’s <a href="https://github.com/spotify/annoy">ANNOY</a>, and <a href="https://github.com/nmslib/hnswlib">hnswlib</a> (<a href="https://arxiv.org/abs/1603.09320">Hierarchical Navigable Small World</a>).
  <br />
The <a href="https://ann-benchmarks.com/">ANN-benchmarks website </a>compares different ANN algorithms on multiple datasets using four main metrics, taking into account the tradeoffs between indexing and querying.</p>

    <ul>
      <li><strong>Recall</strong>: the fraction of the nearest neighbors found by the algorithm.</li>
      <li><strong>Query per second (QPS)</strong>: the number of queries the algorithm can handle per second. This is crucial for high-traffic applications.</li>
      <li><strong>Build time</strong>: the time required to build the index. This metric is important especially if you need to frequently update your index (e.g. because your data changes).</li>
      <li><strong>Index size</strong>: the size of the index created by the algorithm, which is crucial for assessing its scalability and storage requirements.</li>
    </ul>

    <p><br />
This works with not just text documents, but also images, videos, audio, and code. Many teams even try to summarize SQL tables and dataframes and then use these summaries to generate embeddings for retrieval.</p>
  </li>
</ol>

<p>Term-based retrieval is much faster and cheaper than embedding-based retrieval. It can work well out of the box, making it an attractive option to start. Both BM25 and Elasticsearch are widely used in the industry and serve as formidable baselines for more complex retrieval systems. Embedding-based retrieval, while computationally expensive, can be significantly improved over time to outperform term-based retrieval.</p>

<p>A production retrieval system typically combines several approaches. Combining term-based retrieval and embedding-based retrieval is called <em>hybrid search</em>.</p>

<p>One common pattern is sequential. First, a cheap, less precise retriever, such as a term-based system, fetches candidates. Then, a more precise but more expensive mechanism, such as k-nearest neighbors, finds the best of these candidates. The second step is also called reranking.</p>

<p>For example, given the term “transformer”, you can fetch all documents that contain the word transformer, regardless of whether they are about the electric device, the neural architecture, or the movie. Then you use vector search to find among these documents those that are actually related to your transformer query.</p>

<p>Context reranking differs from traditional search reranking in that the exact position of items is less critical. In search, the rank (e.g., first or fifth) is crucial. In context reranking, the order of documents still matters because it affects how well a model can process them. Models might better understand documents at the beginning and end of the context, as suggested by the paper <a href="https://arxiv.org/abs/2307.03172">Lost in the middle</a> (Liu et al., 2023). However, as long as a document is included, the impact of its order is less significant compared to in search ranking.</p>

<p>Another pattern is ensemble. Remember that a retriever works by ranking documents by their relevance scores to the query. You use multiple retrievers to fetch candidates at the same time, then combine these different rankings together to generate a final ranking.</p>

<h3 id="rags_with_tabular_data">RAGs with tabular data</h3>

<p>External data sources can also be structured, such as dataframes or SQL tables. Retrieving data from an SQL table is significantly different from retrieving data from unstructured documents. Given a query, the system works as follows.</p>

<ol>
  <li><strong>Text-to-SQL</strong>: Based on the user query and the table schemas, determine what SQL query is needed.</li>
  <li><strong>SQL execution</strong>: Execute the SQL query.</li>
  <li><strong>Generation</strong>: Generate a response based on the SQL result and the original user query.</li>
</ol>

<center>
    <figure>
    <img alt="Overview of a genai platform" src="/assets/pics/genai-platform/4-rag-with-tabular-data.png" style="float: center; margin: 0 0 0em 0em;" />
    </figure>
</center>
<p><br />
For the text-to-SQL step, if there are many available tables whose schemas can’t all fit into the model context, you might need an intermediate step to predict what tables to use for each query. Text-to-SQL can be done by the same model used to generate the final response or one of many specialized text-to-SQL models.</p>

<h3 id="agentic_rags">Agentic RAGs</h3>

<p>An important source of data is the Internet. A web search tool like Google or Bing API can give the model access to a rich, up-to-date resource to gather relevant information for each query. For example, given the query “Who won Oscar this year?”, the system searches for information about the latest Oscar and uses this information to generate the final response to the user.</p>

<p>Term-based retrieval, embedding-based retrieval, SQL execution, and web search are actions that a model can take to augment its context. You can think of each action as a function the model can call. A workflow that can incorporate external actions is also called <em>agentic</em>. The architecture then looks like this.</p>

<center>
    <figure>
    <img alt="Overview of a genai platform" src="/assets/pics/genai-platform/5-agentic-rag.png" style="float: center; margin: 0 0 0em 0em;" />
    </figure>
</center>
<p><br /></p>

<p><strong>» Action vs. tool «</strong></p>

<p>A tool allows one or more actions. For example, a people search tool might allow two actions: search by name and search by email. However, the difference is minimal, so many people use <em>action</em> and <em>tool</em> interchangeably.</p>

<p><strong>» Read-only actions vs. write actions «</strong></p>

<p>Actions that retrieve information from external sources but don’t change their states are read-only actions. Giving a model write actions, e.g. updating the values in a table, enables the model to perform more tasks but also poses more risks, which will be discussed later.</p>

<h3 id="query_rewriting">Query rewriting</h3>

<p>Often, a user query needs to be rewritten to increase the likelihood of fetching the right information. Consider the following conversation.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>User: When was the last time John Doe bought something from us?
AI: John last bought a Fruity Fedora hat from us two weeks ago, on January 3, 2030.
User: How about Emily Doe?
</code></pre></div></div>

<p>The last question, “How about Emily Doe?”, is ambiguous. If you use this query verbatim to retrieve documents, you’ll likely get irrelevant results. You need to rewrite this query to reflect what the user is actually asking. The new query should make sense on its own. The last question should be rewritten to “When was the last time Emily Doe bought something from us?”</p>

<p>Query rewriting is typically done using other AI models, using a prompt similar to “Given the following conversation, rewrite the last user input to reflect what the user is actually asking.”</p>

<center>
    <figure>
    <img alt="Overview of a genai platform" src="/assets/pics/genai-platform/6-query-rewriting.png" style="float: center; margin: 0 0 0em 0em;" />
    </figure>
</center>
<p><br /></p>

<p>Query rewriting can get complicated, especially if you need to do identity resolution or incorporate other knowledge. If the user asks “How about his wife?”, you will first need to query your database to find out who his wife is. If you don’t have this information, the rewriting model should acknowledge that this query isn’t solvable instead of hallucinating a name, leading to a wrong answer.</p>

<h2 id="step_2_put_in_guardrails">Step 2. Put in Guardrails</h2>

<p>Guardrails help reduce AI risks and protect not just your users but also you, the developers. They should be placed whenever there is potential for failures. This post discusses two types of guardrails: input guardrails and output guardrails.</p>

<h3 id="input_guardrails">Input guardrails</h3>

<p>Input guardrails are typically protection against two types of risks: leaking private information to external APIs, and executing bad prompts that compromise your system (model jailbreaking).</p>

<h4 id="leaking_private_information_to_external_apis">Leaking private information to external APIs</h4>

<p>This risk is specific to using external model APIs when you need to send your data outside your organization. For example, an employee might copy the company’s secret or a user’s private information into a prompt and send it to wherever the model is hosted. <br />
 <br />
One of the most notable early incidents was when Samsung employees put Samsung’s proprietary information into ChatGPT, accidentally <a href="https://www.techradar.com/news/samsung-workers-leaked-company-secrets-by-using-chatgpt">leaking the company’s secrets</a>. It’s unclear how Samsung discovered this leak and how the leaked information was used against Samsung. However, the incident was serious enough for Samsung to <a href="https://www.bloomberg.com/news/articles/2023-05-02/samsung-bans-chatgpt-and-other-generative-ai-use-by-staff-after-leak">ban ChatGPT in May 2023</a>. <br />
 <br />
There’s no airtight way to eliminate potential leaks when using third-party APIs. However, you can mitigate them with guardrails. You can use one of the many available tools that automatically detect sensitive data. What sensitive data to detect is specified by you. Common sensitive data classes are:</p>

<ul>
  <li>Personal information (ID numbers, phone numbers, bank accounts).</li>
  <li>Human faces.</li>
  <li>Specific keywords and phrases associated with the company’s intellectual properties or privileged information.</li>
</ul>

<p>Many sensitive data detection tools use AI to identify potentially sensitive information, such as determining if a string resembles a valid home address. If a query is found to contain sensitive information, you have two options: block the entire query or remove the sensitive information from it. For instance, you can mask a user’s phone number with the placeholder [PHONE NUMBER]. If the generated response contains this placeholder, use a PII reversible dictionary that maps this placeholder to the original information so that you can unmask it, as shown below.</p>

<center>
    <figure>
    <img alt="Overview of a genai platform" src="/assets/pics/genai-platform/7-reversible-pii-mapping.png" style="float: center; margin: 0 0 0em 0em;" />
    </figure>
</center>
<p><br /></p>
<h4 id="jailbreaking">Model jailbreaking</h4>

<p>It’s become an online sport to try to jailbreak AI models, getting them to say or do bad things. While some might find it amusing to get ChatGPT to make controversial statements, it’s much less fun if your customer support chatbot, branded with your name and logo, does the same thing. This can be especially dangerous for AI systems that have access to tools. Imagine if a user finds a way to get your system to execute an SQL query that corrupts your data. <br />
 <br />
To combat this, you should first put guardrails on your system so that no harmful actions can be automatically executed. For example, no SQL queries that can insert, delete, or update data can be executed without human approval. The downside of this added security is that it can slow down your system.</p>

<p>To prevent your application from making outrageous statements it shouldn’t be making, you can define out-of-scope topics for your application. For example, if your application is a customer support chatbot, it shouldn’t answer political or social questions. A simple way to do so is to filter out inputs that contain predefined phrases typically associated with controversial topics, such as “immigration” or “antivax”. More sophisticated algorithms use AI to classify whether an input is about one of the pre-defined restricted topics. <br />
 <br />
If harmful prompts are rare in your system, you can use an anomaly detection algorithm to identify unusual prompts.</p>

<h3 id="output_guardrails">Output guardrails</h3>

<p>AI models are probabilistic, making their outputs unreliable. You can put in guardrails to significantly improve your application’s reliability. Output guardrails have two main functionalities:</p>

<ol>
  <li>Evaluate the quality of each generation.</li>
  <li>Specify the policy to deal with different failure modes.</li>
</ol>

<h4 id="output_quality_measurement">Output quality measurement</h4>

<p>To catch outputs that fail to meet your standards, you need to understand what failures look like. Here are examples of failure modes and how to catch them.</p>

<ol>
  <li>
    <p><strong>Empty responses</strong>.</p>
  </li>
  <li>
    <p><strong>Malformatted responses</strong> that don’t follow the expected output format. For example, if the application expects JSON and the generated response has a missing closing bracket. There are validators for certain formats, such as regex, JSON, and Python code validators. There are also tools for <a href="https://huyenchip.com/2024/01/16/sampling.html#constraint_sampling">constrained sampling</a> such as guidance, outlines, and instructor.</p>
  </li>
  <li>
    <p><strong>Toxic responses</strong>, such as those that are racist or sexist. These responses can be caught using one of many toxicity detection tools.</p>
  </li>
  <li>
    <p><strong>Factual inconsistent responses</strong> hallucinated by the model. Hallucination detection is an active area of research with solutions such as <a href="https://arxiv.org/abs/2303.08896">SelfCheckGPT</a> (Manakul et al., 2023) and <a href="https://arxiv.org/abs/2403.18802">SAFE</a>, Search Engine Factuality Evaluator (Wei et al., 2024). You can mitigate hallucinations by providing models with sufficient context and prompting techniques such as chain-of-thought. Hallucination detection and mitigation are discussed further in my upcoming book <a href="https://learning.oreilly.com/library/view/ai-engineering/9781098166298/">AI Engineering</a>.</p>
  </li>
  <li><strong>Responses that contain sensitive information</strong>. This can happen in two scenarios.
    <ol>
      <li>Your model was trained on sensitive data and regurgitates it back.</li>
      <li>Your system retrieves sensitive information from your internal database to enrich its context, and then it passes this sensitive information on to the response.</li>
    </ol>

    <p>This failure mode can be prevented by not training your model on sensitive data and not allowing it to retrieve sensitive data in the first place. Sensitive data in outputs can be detected using the same tools used for input guardrails.</p>
  </li>
  <li>
    <p><strong>Brand-risk responses</strong>, such as responses that mischaracterize your company or your competitors. An example is when Grok, a model trained by X, generated a response <a href="https://x.com/JaxWinterbourne/status/1733339886155968714">suggesting that Grok was trained by OpenAI</a>, causing the Internet to suspect X of stealing OpenAI’s data. This failure mode can be mitigated with keyword monitoring. Once you’ve identified outputs concerning your brands and competitors, you can either block these outputs, pass them onto human reviewers, or use other models to detect the sentiment of these outputs to ensure that only the right sentiments are returned.</p>
  </li>
  <li><strong>Generally bad responses</strong>. For example, if you ask the model to write an essay and that essay is just bad, or if you ask the model for a low-calorie cake recipe and the generated recipe contains an excessive amount of sugar. It’s become a popular practice to use AI judges to evaluate the quality of models’ responses. These AI judges can be general-purpose models (think ChatGPT, Claude) or specialized scorers trained to output a concrete score for a response given a query.</li>
</ol>

<h4 id="failure_management">Failure management</h4>

<p>AI models are probabilistic, which means that if you try a query again, you might get a different response. Many failures can be mitigated using a basic retry logic. For example, if the response is empty, try again X times or until you get a non-empty response. Similarly, if the response is malformatted, try again until the model generates a correctly formatted response.</p>

<p>This retry policy, however, can incur extra latency and cost. One retry means 2x the number of API calls. If the retry is carried out after failure, the latency experienced by the user will double. To reduce latency, you can make calls in parallel. For example, for each query, instead of waiting for the first query to fail before retrying, you send this query to the model twice at the same time, get back two responses, and pick the better one. This increases the number of redundant API calls but keeps latency manageable.</p>

<p>It’s also common to fall back on humans to handle tricky queries. For example, you can transfer a query to human operators if it contains specific key phrases. Some teams use a specialized model, potentially trained in-house, to decide when to transfer a conversation to humans. One team, for instance, transfers a conversation to human operators when their sentiment analysis model detects that the user is getting angry. Another team transfers a conversation after a certain number of turns to prevent users from getting stuck in an infinite loop.</p>

<h3 id="guardrail_tradeoffs">Guardrail tradeoffs</h3>

<p><strong>Reliability vs. latency tradeoff</strong>: While acknowledging the importance of guardrails, some teams told me that latency is more important. They decided not to implement guardrails because they can significantly increase their application’s latency. However, these teams are in the minority. Most teams find that the increased risks are more costly than the added latency.</p>

<p>Output guardrails might not work well in the stream completion mode. By default, the whole response is generated before shown to the user, which can take a long time. In the stream completion mode, new tokens are streamed to the user as they are generated, reducing the time the user has to wait to see the response. The downside is that it’s hard to evaluate partial responses, so unsafe responses might be streamed to users before the system guardrails can determine that they should be blocked.</p>

<p><strong>Self-hosted vs. third-party API tradeoff</strong>: Self-hosting your models means that you don’t have to send your data to a third party, reducing the need for input guardrails. However, it also means that you must implement all the necessary guardrails yourself, rather than relying on the guardrails provided by third-party services.</p>

<p>Our platform now looks like this. Guardrails can be independent tools or parts of model gateways, as discussed later. Scorers, if used, are grouped under model APIs since scorers are typically AI models, too. Models used for scoring are typically smaller and faster than models used for generation.</p>

<center>
    <figure>
    <img alt="Overview of a genai platform" src="/assets/pics/genai-platform/8-guardrails.png" style="float: center; margin: 0 0 0em 0em;" />
    </figure>
</center>
<p><br /></p>

<h2 id="step_3_add_model_router_and_gateway">Step 3. Add Model Router and Gateway</h2>

<p>As applications grow in complexity and involve more models, two types of tools emerged to help you work with multiple models: routers and gateways.</p>

<h3 id="router">Router</h3>
<p>An application can use different models to respond to different types of queries. Having different solutions for different queries has several benefits. First, this allows you to have specialized solutions, such as one model specialized in technical troubleshooting and another specialized in subscriptions. Specialized models can potentially perform better than a general-purpose model. Second, this can help you save costs. Instead of routing all queries to an expensive model, you can route simpler queries to cheaper models.</p>

<p>A router typically consists of <strong>an intent classifier</strong> that predicts what the user is trying to do. Based on the predicted intent, the query is routed to the appropriate solution. For example, for a customer support chatbot, if the intent is:</p>
<ul>
  <li>To reset a password –&gt; route this user to the page about password resetting.</li>
  <li>To correct a billing mistake –&gt; route this user to a human operator.</li>
  <li>To troubleshoot a technical issue –&gt; route this query to a model finetuned for troubleshooting.</li>
</ul>

<p>An intent classifier can also help your system avoid out-of-scope conversations. For example, you can have an intent classifier that predicts whether a query is out of the scope. If the query is deemed inappropriate (e.g. if the user asks who you would vote for in the upcoming election), the chatbot can politely decline to engage using one of the stock responses (“As a chatbot, I don’t have the ability to vote. If you have questions about our products, I’d be happy to help.”) without wasting an API call.</p>

<p>If your system has access to multiple actions, a router can involve a <strong>next-action predictor</strong> to help the system decide what action to take next. One valid action is to ask for clarification if the query is ambiguous. For example, in response to the query “Freezing,” the system might ask, “Do you want to freeze your account or are you talking about the weather?” or simply say, “I’m sorry. Can you elaborate?”</p>

<p>Intent classifiers and next-action predictors can be general-purpose models or specialized classification models. Specialized classification models are typically much smaller and faster than general-purpose models, allowing your system to use multiple of them without incurring significant extra latency and cost.</p>

<p>When routing queries to models with varying context limits, the query’s context might need to be adjusted accordingly. Consider a query of 1,000 tokens that is slated for a model with a 4K context limit. The system then takes an action, e.g. web search, that brings back 8,000-token context. You can either truncate the query’s context to fit the originally intended model or route the query to a model with a larger context limit.</p>

<h3 id="gateway">Gateway</h3>
<p>A model gateway is an intermediate layer that allows your organization to interface with different models in a unified and secure manner. The most basic functionality of a model gateway is to enable developers to access different models – be it self-hosted models or models behind commercial APIs such as OpenAI or Google – the same way. A model gateway makes it easier to maintain your code. If a model API changes, you only need to update the model gateway instead of having to update all applications that use this model API.</p>

<center>
    <figure>
    <img alt="Overview of a genai platform" src="/assets/pics/genai-platform/9-llm-gateway.png" style="float: center; margin: 0 0 0em 0em;" />
    </figure>
</center>
<p><br /></p>

<p>In its simplest form, a model gateway is a unified wrapper that looks like the following code example. This example is to give you an idea of how a model gateway might be implemented. It’s not meant to be functional as it doesn’t contain any error checking or optimization.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import google.generativeai as genai
import openai

def openai_model(input_data, model_name, max_tokens):
    openai.api_key = os.environ["OPENAI_API_KEY"]
    response = openai.Completion.create(
        engine=model_name,
        prompt=input_data,
        max_tokens=max_tokens
    )
    return {"response": response.choices[0].text.strip()}

def gemini_model(input_data, model_name, max_tokens):
    genai.configure(api_key=os.environ["GOOGLE_API_KEY"])
    model = genai.GenerativeModel(model_name=model_name)
    response = model.generate_content(input_data, max_tokens=max_tokens)
    return {"response": response["choices"][0]["message"]["content"]}

@app.route('/model', methods=['POST'])
def model_gateway():
    data = request.get_json()
    model_type = data.get("model_type")
    model_name = data.get("model_name")
    input_data = data.get("input_data")
    max_tokens = data.get("max_tokens")

    if model_type == "openai":
        result = openai_model(input_data, model_name, max_tokens)
    elif model_type == "gemini":
        result = gemini_model(input_data, model_name, max_tokens)
    return jsonify(result)
</code></pre></div></div>

<p>A model gateway is <strong>access control and cost management</strong>. Instead of giving everyone who wants access to the OpenAI API your organizational tokens, which can be easily leaked, you only give people access to the model gateway, creating a centralized and controlled point of access. The gateway can also implement fine-grained access controls, specifying which user or application should have access to which model. Moreover, the gateway can monitor and limit the usage of API calls, preventing abuse and managing costs effectively.</p>

<p>A model gateway can also be used to implement fallback policies to overcome rate limits or API failures (the latter is unfortunately common). When the primary API is unavailable, the gateway can route requests to alternative models, retry after a short wait, or handle failures in other graceful manners. This ensures that your application can operate smoothly without interruptions.</p>

<p>Since requests and responses are already flowing through the gateway, it’s a good place to implement other functionalities such as load balancing, logging, and analytics. Some gateway services even provide caching and guardrails.</p>

<p>Given that gateways are relatively straightforward to implement, there are many off-the-shelf gateways. Examples include Portkey’s <a href="https://github.com/Portkey-AI/gateway">gateway</a>, <a href="https://mlflow.org/docs/latest/llms/gateway/index.html">MLflow AI Gateway</a>, WealthSimple’s <a href="https://github.com/wealthsimple/llm-gateway">llm-gateway</a>, <a href="https://docs.truefoundry.com/docs/ai-gateway">TrueFoundry</a>, <a href="https://konghq.com/products/kong-ai-gateway">Kong</a>, and <a href="https://developers.cloudflare.com/ai-gateway/">Cloudflare</a>.</p>

<p>With the added gateway and routers, our platform is getting more exciting. Like scoring, routing is also in the model gateway. Like models used for scoring, models used for routing are typically smaller than models used for generation.</p>

<center>
    <figure>
    <img alt="Overview of a genai platform" src="/assets/pics/genai-platform/10-model-gateway.png" style="float: center; margin: 0 0 0em 0em;" />
    </figure>
</center>
<p><br /></p>

<h2 id="step_4_reduce_latency_with_cache">Step 4. Reduce Latency with Cache</h2>

<p>When I shared this post with my friend Eugene Yan, he said that cache is perhaps the most underrated component of an AI platform. Caching can significantly reduce your application’s latency and cost.</p>

<p>Cache techniques can also be used during training, but since this post is about deployment, I’ll focus on cache for inference. Some common inference caching techniques include prompt cache, exact cache, and semantic cache. Prompt cache are typically implemented by the inference APIs that you use. When evaluating an inference library, it’s helpful to understand what cache mechanism it supports.</p>

<p><em>KV cache for the attention mechanism is out of scope for this discussion.</em></p>

<h3 id="prompt_cache">Prompt cache</h3>

<p>Many prompts in an application have overlapping text segments. For example, all queries can share the same system prompt. A prompt cache stores these overlapping segments for reuse, so you only need to process them once. A common overlapping text segment in different prompts is the system prompt. Without prompt cache, your model needs to process the system prompt with every query. With prompt cache, it only needs to process the system prompt once for the first query.</p>

<p>For applications with long system prompts, prompt cache can significantly reduce both latency and cost. If your system prompt is 1000 tokens and your application generates 1 million model API calls today, a prompt cache will save you from processing approximately 1 billion repetitive input tokens a day! However, this isn’t entirely free. Like KV cache, prompt cache size can be quite large and require significant engineering effort.</p>

<p>Prompt cache is also useful for queries that involve long documents. For example, if many of your user queries are related to the same long document (such as a book or a codebase), this long document can be cached for reuse across queries.</p>

<p>Since its introduction in November 2023 by <a href="https://arxiv.org/pdf/2311.04934">Gim et al.</a>, prompt cache has already been incorporated into model APIs. Google announced that Gemini APIs will offer this functionality in June 2024 under the name <em><a href="https://ai.google.dev/gemini-api/docs/caching">context cache</a></em>. Cached input tokens are given a 75% discount compared to regular input tokens, but you’ll have to pay extra for cache storage (as of writing, $1.00 / 1 million tokens per hour). Given the obvious benefits of prompt cache, I wouldn’t be surprised if it becomes as popular as KV cache.</p>

<p>While llama.cpp also has <a href="https://github.com/ggerganov/llama.cpp/blob/master/examples/main/README.md#prompt-caching">prompt cache</a>, it seems to only cache whole prompts and work for queries in the same chat session. Its documentation is limited, but my guess from reading the code is that in a long conversation, it caches the previous messages and only processes the newest message.</p>

<h3 id="exact_cache">Exact cache</h3>

<p>If prompt cache and KV cache are unique to foundation models, exact cache is more general and straightforward. Your system stores processed items for reuse later when the exact items are requested. For example, if a user asks a model to summarize a product, the system checks the cache to see if a summary of this product is cached. If yes, fetch this summary. If not, summarize the product and cache the summary.</p>

<p>Exact cache is also used for embedding-based retrieval to avoid redundant vector search. If an incoming query is already in the vector search cache, fetch the cached search result. If not, perform a vector search for this query and cache the result.</p>

<p>Cache is especially appealing for queries that require multiple steps (e.g. chain-of-thought) and/or time-consuming actions (e.g. retrieval, SQL execution, or web search).</p>

<p>An exact cache can be implemented using in-memory storage for fast retrieval. However, since in-memory storage is limited, a cache can also be implemented using databases like PostgreSQL, Redis, or tiered storage to balance speed and storage capacity. Having an eviction policy is crucial to manage the cache size and maintain performance. Common eviction policies include Least Recently Used (LRU), Least Frequently Used (LFU), and First In, First Out (FIFO).</p>

<p>How long to cache a query depends on how likely this query is to be called again. User-specific queries such as “What’s the status of my recent order” are less likely to be reused by other users, and therefore, shouldn’t be cached. Similarly, it makes less sense to cache time-sensitive queries such as “How’s the weather?” Some teams train a small classifier to predict whether a query should be cached.</p>

<h3 id="semantic_cache">Semantic cache</h3>

<p>Unlike exact cache, semantic cache doesn’t require the incoming query to be identical to any of the cached queries. Semantic cache allows the reuse of similar queries. Imagine one user asks “What’s the capital of Vietnam?” and the model generates the answer “Hanoi”. Later, another user asks “What’s the capital <strong><em>city</em></strong> of Vietnam?”, which is the same question but with the extra word “city”. The idea of semantic cache is that the system can reuse the answer “Hanoi” instead of computing the new query from scratch.</p>

<p>Semantic cache only works if you have a reliable way to determine if two queries are semantically similar. One common approach is embedding-based similarity, which works as follows:</p>

<ol>
  <li>For each query, generate its embedding using an embedding model.</li>
  <li>Use vector search to find the cached embedding closest to the current query embedding. Let’s say this similarity score is X.</li>
  <li>If X is less than the similarity threshold you set, the cached query is considered the same as the current query, and the cached results are returned. If not, process this current query and cache it together with its embedding and results.</li>
</ol>

<p>This approach requires a vector database to store the embeddings of cached queries.</p>

<p><strong>Compared to other caching techniques, semantic cache’s value is more dubious because many of its components are prone to failure.</strong> Its success relies on high-quality embeddings, functional vector search, and a trustworthy similarity metric. Setting the right similarity threshold can also be tricky and require a lot of trial and error. If the system mistakes the incoming query as being similar to another query, the returned response, fetched from the cache, will be incorrect.</p>

<p>In addition, semantic cache can be time-consuming and compute-intensive, as it involves a vector search. The speed and cost of this vector search depend on the size of your database of cached embeddings.</p>

<p>Semantic cache might still be worth it if the cache hit rate is high, meaning that a good portion of queries can be effectively answered by leveraging the cached results. However, before incorporating the complexities of semantic cache, make sure to evaluate the efficiency, cost, and performance risks associated with it.</p>

<p>With the added cache systems, the platform looks as follows. KV cache and prompt cache are typically implemented by model API providers, so they aren’t shown in this image. If I must visualize them, I’d put them in the Model API box. There’s a new arrow to add generated responses to the cache.</p>

<center>
    <figure>
    <img alt="Overview of a genai platform" src="/assets/pics/genai-platform/12-cache.png" style="float: center; margin: 0 0 0em 0em;" />
    </figure>
</center>
<p><br /></p>

<h2 id="step_5_add_complex_logic_and_write_actions">Step 5. Add complex logic and write actions</h2>

<p>The applications we’ve discussed so far have fairly simple flows. The outputs generated by foundation models are mostly returned to users (unless they don’t pass the guardrails). However, an application flow can be more complex with loops and conditional branching. A model’s outputs can also be used to invoke write actions, such as composing an email or placing an order.</p>

<h3 id="complex_logic">Complex logic</h3>

<p>Outputs from a model can be conditionally passed onto another model or fed back to the same model as part of the input to the next step. This goes on until a model in the system decides that the task has been completed and that a final response should be returned to the user.</p>

<p>This can happen when you give your system the ability to plan and decide what to do next. As an example, consider the query “Plan a weekend itinerary for Paris.” The model might first generate a list of potential activities: visiting the Eiffel Tower, having lunch at a café, touring the Louvre, etc. Each of these activities can then be fed back into the model to generate more detailed plans. For instance, “visiting the Eiffel Tower” could prompt the model to generate sub-tasks like checking the opening hours, buying tickets, and finding nearby restaurants. This iterative process continues until a comprehensive and detailed itinerary is created.</p>

<p>Our infrastructure now has an arrow pointing the generated response back to context construction, which in turn feeds back to models in the model gateway.</p>

<center>
    <figure>
    <img alt="Overview of a genai platform" src="/assets/pics/genai-platform/13-loop.png" style="float: center; margin: 0 0 0em 0em;" />
    </figure>
</center>
<p><br /></p>

<h3 id="write_actions">Write actions</h3>

<p>Actions used for context construction are <em>read-only actions</em>. They allow a model to read from its data sources to gather context. But a system can also <em>write actions</em>, making changes to the data sources and the world. For example, if the model outputs: “send an email to X with the message Y”, the system will invoke the action <code class="language-plaintext highlighter-rouge">send_email(recipient=X, message=Y)</code>.</p>

<p>Write actions make a system vastly more capable. They can enable you to automate the whole customer outreach workflow: researching potential customers, finding their contacts, drafting emails, sending first emails, reading responses, following up, extracting orders, updating your databases with new orders, etc.</p>

<p>However, the prospect of giving AI the ability to automatically alter our lives is frightening. Just as you shouldn’t give an intern the authority to delete your production database, you shouldn’t allow an unreliable AI to initiate bank transfers. Trust in the system’s capabilities and its security measures is crucial. You need to ensure that the system is protected from bad actors who might try to manipulate it into performing harmful actions.</p>

<p>AI systems are vulnerable to cyber attacks like other software systems, but they also have another weakness: <em>prompt injection</em>. Prompt injection happens when an attacker manipulates input prompts into a model to get it to express undesirable behaviors. You can think of prompt injection as social engineering done on AI instead of humans.</p>

<p>A scenario that many companies fear is that they give an AI system access to their internal databases, and attackers trick this system into revealing private information from these databases. If the system has write access to these databases, attackers can trick the system into corrupting the data.</p>

<p>Any organization that wants to leverage AI needs to take safety and security seriously. However, these risks don’t mean that AI systems should never be given the ability to act in the real world. AI systems can fail, but humans can fail too. If we can get people to trust a machine to take us up into space, I hope that one day, securities will be sufficient for us to trust autonomous AI systems.</p>

<center>
    <figure>
    <img alt="Overview of a genai platform" src="/assets/pics/genai-platform/14-write-actions.png" style="float: center; margin: 0 0 0em 0em;" />
    </figure>
</center>
<p><br /></p>

<h2 id="observability">Observability</h2>

<p>While I have placed observability in its own section, it should be integrated into the platform from the beginning rather than added later as an afterthought. Observability is crucial for projects of all sizes, and its importance grows with the complexity of the system.</p>

<p>This section provides the least information compared to the others. It’s impossible to cover all the nuances of observability in a blog post. Therefore, I will only give a brief overview of the three pillars of monitoring: logs, traces, and metrics. I won’t go into specifics or cover user feedback, drift detection, and debugging.</p>

<h3 id="metrics">Metrics</h3>

<p>When discussing monitoring, most people think of metrics. What metrics to track depends on what you want to track about your system, which is application-specific. However, in general, there are two types of metrics you want to track: model metrics and system metrics.</p>

<p>System metrics tell you the state of your overall system. Common metrics are throughput, memory usage, hardware utilization, and service availability/uptime. System metrics are common to all software engineering applications. In this post, I’ll focus on model metrics.</p>

<p>Model metrics assess your model’s performance, such as accuracy, toxicity, and hallucination rate. Different steps in an application pipeline also have their own metrics. For example, in a RAG application, the retrieval quality is often evaluated using context relevance and context precision. A vector database can be evaluated by how much storage it needs to index the data and how long it takes to query the data</p>

<p>There are various ways a model’s output can fail. It’s crucial to identify these issues and develop metrics to monitor them. For example, you might want to track how often your model times out, returns empty responses or produces malformatted responses. If you’re worried about your model revealing sensitive information, find a way to track that too.</p>

<p>Length-related metrics such as query, context, and response length are helpful for understanding your model’s behaviors. Is one model more verbose than another? Are certain types of queries more likely to result in lengthy answers? They are especially useful for detecting changes in your application. If the average query length suddenly decreases, it could indicate an underlying issue that needs investigation.</p>

<p>Length-related metrics are also important for tracking latency and costs, as longer contexts and responses typically increase latency and incur higher costs.</p>

<p>Tracking latency is essential for understanding the user experience. Common latency metrics include:</p>

<ul>
  <li><strong>Time to First Token</strong> (TTFT): The time it takes for the first token to be generated.</li>
  <li><strong>Time Between Tokens</strong> (TBT): The interval between each token generation.</li>
  <li><strong>Tokens Per Second</strong> (TPS): The rate at which tokens are generated.</li>
  <li><strong>Time Per Output Token</strong> (TPOT): The time it takes to generate each output token.</li>
  <li><strong>Total Latency</strong>: The total time required to complete a response.</li>
</ul>

<p>You’ll also want to track costs. Cost-related metrics are the number of queries and the volume of input and output tokens. If you use an API with rate limits, tracking the number of requests per second is important to ensure you stay within your allocated limits and avoid potential service interruptions.</p>

<p>When calculating metrics, you can choose between spot checks and exhaustive checks. Spot checks involve sampling a subset of data to quickly identify issues, while exhaustive checks evaluate every request for a comprehensive performance view. The choice depends on your system’s requirements and available resources, with a combination of both providing a balanced monitoring strategy.</p>

<p>When computing metrics, ensure they can be broken down by relevant axes, such as users, releases, prompt/chain versions, prompt/chain types, and time. This granularity helps in understanding performance variations and identifying specific issues.</p>

<h3 id="logs">Logs</h3>

<p>Since this blog post is getting long and I’ve written at length about <a href="https://learning.oreilly.com/library/view/designing-machine-learning/9781098107956/ch08.html#software_system_failures">logs</a> in <a href="https://www.amazon.com/Designing-Machine-Learning-Systems-Production-Ready/dp/1098107969?&amp;_encoding=UTF8&amp;tag=chiphuyen-20&amp;linkCode=ur2&amp;linkId=0a1dbab0e76f5996e29e1a97d45f14a5&amp;camp=1789&amp;creative=9325">Designing Machine Learning Systems</a>, I will be quick here. The philosophy for logging is simple: log everything. Log the system configurations. Log the query, the output, and the intermediate outputs. Log when a component starts, ends, when something crashes, etc. When recording a piece of log, make sure to give it tags and IDs that can help you know where in the system this log comes from.</p>

<p>Logging everything means that the amount of logs you have can grow very quickly. Many tools for automated log analysis and log anomaly detection are powered by AI.</p>

<p>While it’s impossible to manually process logs, it’s useful to manually inspect your production data daily to get a sense of how users are using your application. Shankar et al. (2024) found that the developers’ perceptions of what constitutes good and bad outputs change as they interact with more data, allowing them to both rewrite their prompts to increase the chance of good responses and update their evaluation pipeline to catch bad responses.</p>

<h3 id="traces">Traces</h3>

<p>Trace refers to the detailed recording of a request’s execution path through various system components and services. In an AI application, tracing reveals the entire process from when a user sends a query to when the final response is returned, including the actions the system takes, the documents retrieved, and the final prompt sent to the model. It should also show how much time each step takes and its associated cost, if measurable. As an example, this is a visualization of a <a href="https://blog.langchain.dev/announcing-langsmith/">Langsmith</a> trace.</p>

<center>
    <figure>
    <img alt="Overview of a genai platform" src="/assets/pics/genai-platform/15-traces.png" style="float: center; margin: 0 0 0em 0em;" />
    </figure>
</center>
<p><br />
Ideally, you should be able to trace each query’s transformation through the system step-by-step. If a query fails, you should be able to pinpoint the exact step where it went wrong: whether it was incorrectly processed, the retrieved context was irrelevant, or the model generated a wrong response.</p>

<h2 id="ai_pipeline_orchestration">AI Pipeline Orchestration</h2>

<p>An AI application can get fairly complex, consisting of multiple models, retrieving data from many databases, and having access to a wide range of tools. An orchestrator helps you specify how these different components are combined (chained) together to create an end-to-end application flow.</p>

<p>At a high level, an orchestrator works in two steps: components definition and chaining (also known as pipelining).</p>

<ol>
  <li>
    <p><strong>Components Definition</strong> <br />
You need to tell the orchestrator what components your system uses, such as models (including models for generation, routing, and scoring), databases from which your system can retrieve data, and actions that your system can take. Direct integration with model gateways can help simplify model onboarding, and some orchestrator tools want to be gateways. Many orchestrators also support integration with tools for evaluation and monitoring.</p>
  </li>
  <li>
    <p><strong>Chaining (or pipelining)</strong> <br />
You tell the orchestrator the sequence of steps your system takes from receiving the user query until completing the task. In short, chaining is just function composition. Here’s an example of what a pipeline looks like.</p>
    <ol>
      <li>Process the raw query.</li>
      <li>Retrieve the relevant data based on the processed query.</li>
      <li>The original query and the retrieved data are combined to create a prompt in the format expected by the model.</li>
      <li>The model generates a response based on the prompt.</li>
      <li>Evaluate the response.</li>
      <li>If the response is considered good, return it to the user. If not, route the query to a human operator.</li>
    </ol>

    <p>The orchestrator is responsible for passing data between steps and can provide toolings that help ensure that the output from the current step is in the format expected by the next step.</p>
  </li>
</ol>

<p>When designing the pipeline for an application with strict latency requirements, try to do as much in parallel as possible. For example, if you have a routing component (deciding where to send a query to) and a PII removal component, they can do both at the same time.</p>

<p>There are many AI orchestration tools, including <a href="https://github.com/langchain-ai/langchain">LangChain</a>, <a href="https://github.com/run-llama/llama_index">LlamaIndex</a>, <a href="https://github.com/FlowiseAI/Flowise">Flowise</a>, <a href="https://github.com/langflow-ai/langflow">Langflow</a>, and <a href="https://github.com/deepset-ai/haystack">Haystack</a>. Each tool has its own APIs so I won’t show the actual code here.</p>

<p><strong>While it’s tempting to jump straight to an orchestration tool when starting a project, start building your application without one first.</strong> Any external tool brings added complexity. An orchestrator can abstract away critical details of how your system works, making it hard to understand and debug your system.</p>

<p>As you advance to the later stages of your application development process, you might decide that an orchestrator can make your life easier. Here are three aspects to keep in mind when evaluating orchestrators.</p>

<ol>
  <li><strong>Integration and extensibility</strong> <br />
Evaluate whether the orchestrator supports the components you’re already using or might adopt in the future. For example, if you want to use a Llama model, check if the orchestrator supports that. Given how many models, databases, and frameworks there are, it’s impossible for an orchestrator to support everything. Therefore, you’ll also need to consider an orchestrator’s extensibility. If it doesn’t support a specific component, how hard it is to change that?</li>
  <li><strong>Support for complex pipelines</strong> <br />
As your applications grow in complexity, you might need to manage intricate pipelines involving multiple steps and conditional logic. An orchestrator that supports advanced features like branching, parallel processing, and error handling will help you manage these complexities efficiently.</li>
  <li><strong>Ease of use, performance, and scalability</strong> <br />
Consider the user-friendliness of the orchestrator. Look for intuitive APIs, comprehensive documentation, and strong community support, as these can significantly reduce the learning curve for you and your team. Avoid orchestrators that initiate hidden API calls or introduce latency to your applications. Additionally, ensure that the orchestrator can scale effectively as the number of applications, developers, and traffic grows.</li>
</ol>

<h2 id="conclusion">Conclusion</h2>

<p>This post started with a basic architecture and then gradually added components to address the growing application complexities. Each addition brings its own set of benefits and challenges, requiring careful consideration and implementation.</p>

<p>While the separation of components is important to keep your system modular and maintainable, this separation is fluid. There are many overlaps between components. For example, a model gateway can share functionalities with guardrails. Cache can be implemented in different components, such as in vector search and inference services.</p>

<p>This post is much longer than I intended it to be, and yet there are many details I haven’t been able to explore further, especially around observability, context construction, complex logic, cache, and guardrails. I’ll dive deeper into all these components in my upcoming book <a href="https://learning.oreilly.com/library/view/ai-engineering/9781098166298/">AI Engineering</a>.</p>

<p>This post also didn’t discuss how to serve models, assuming that most people will be using models provided by third-party APIs. AI Engineering will also have a chapter dedicated to inference and model optimization.</p>

<h2 id="references_and_acknowledgments">References and Acknowledgments</h2>

<p>Special thanks to <a href="https://x.com/luke_metz">Luke Metz</a>, <a href="https://www.linkedin.com/in/findalexli/">Alex Li</a>, <a href="https://www.linkedin.com/in/chetantekur/">Chetan Tekur</a>, <a href="https://www.linkedin.com/in/kittipat-bot-kampa-1b1965/">Kittipat “Bot” Kampa</a>, <a href="https://www.linkedin.com/in/hienluu/">Hien Luu</a>, and <a href="https://www.linkedin.com/in/denyslinkov/">Denys Linkov</a> for feedback on the early versions of this post. Their insights greatly improved the content. Any remaining errors are my own.</p>

<p>I read many case studies shared by companies on how they adopted generative AI, and here are some of my favorites.</p>

<ul>
  <li><a href="https://www.linkedin.com/blog/engineering/generative-ai/musings-on-building-a-generative-ai-product?_l=en_US">Musings on Building a Generative AI Product</a> (LinkedIn, 2024)</li>
  <li><a href="https://medium.com/pinterest-engineering/how-we-built-text-to-sql-at-pinterest-30bad30dabff">How we built Text-to-SQL at Pinterest</a> (Pinterest, 2024)</li>
  <li><a href="https://medium.com/vimeo-engineering-blog/from-idea-to-reality-elevating-our-customer-support-through-generative-ai-101a2c5ea680">From idea to reality: Elevating our customer support through generative AI</a> (Vimeo, 2023)</li>
  <li><a href="https://www.shortwave.com/blog/deep-dive-into-worlds-smartest-email-ai/">A deep dive into the world’s smartest email AI</a> (Shortwave, 2023)</li>
  <li><a href="https://engineering.grab.com/llm-powered-data-classification">LLM-powered data classification for data entities at scale</a> (Grab, 2023)</li>
  <li><a href="https://www.uber.com/blog/from-predictive-to-generative-ai/">From Predictive to Generative - How Michelangelo Accelerates Uber’s AI Journey</a> (Uber, 2024)</li>
</ul>
]]></content:encoded>
<pubDate>Thu, 25 Jul 2024 00:00:00 +0000</pubDate>
</item>
<item>
<title>Measuring personal growth</title>
<link>https://huyenchip.com//2024/04/17/personal-growth.html</link>
<guid>https://huyenchip.com//2024/04/17/personal-growth.html</guid>
<content:encoded><![CDATA[
<div> rate of change, time to solve problems, number of future options, personal growth, heuristics

总结:
作者思考人生成长的衡量方法，提出三个指标：变化速率、解决问题所需时间、未来选择数量。他认为每3-6年会成为新的人，目标是在尽快解决大问题后，拥有更多未来选择。通过最大化未来选择来衡量个人成长。作者总结了个人成长的三条启发式规则，包括定期成为新的自己、尽早解决大问题、最大化未来选择。 <div>
<p>My founder friends constantly think about growth. They think about how to measure their business growth and how to get to the next order of magnitude scale. If they’re making $1M ARR today, they think about how to get to $10M ARR. If they have 1,000 users today, they think about how to get to 10,000 users.</p>

<p>This made me wonder if/how people are measuring personal growth. I don’t want to use metrics like net worth or the number of followers, because that’s not what I live for. After talking with a lot of friends, I found three interesting metrics: rate of change, time to solve problems, and number of future options.</p>

<p>Some friends told me they find this blog post mildly sociopathic. Why do I have to measure everything? Life is to be lived, not to be measured. As someone lowkey fascinated by numbers, I don’t see why measuring and living have to be mutually exclusive – measuring often helps me live better – but I see where they come from. This post is more of a thought exercise than a rigorous experiment.</p>

<h2 id="rate-of-change">Rate of change</h2>

<p>I have this theory that life has a circadian rhythm. Every 3-6 years, you become a different person. You work on different problems. Your lifestyle changes. The people you hang out with are different. If you haven’t caught up with a friend in 5 years, you might no longer have anything in common. It’s not a coincidence that schools are structured into chunks of 3-6 years.</p>

<p>Looking back, I realized that every 3-6 years, my life completely changed. From grade 3 to grade 10, I did competitive math. For the next 5 years, I worked as a writer. Then I went to college and studied computer science for 4 years. After that, I fumbled around for almost 6 years. It was only recently that I felt like I had a handle on life.</p>

<p>Sami, a new friend who loves designing strategy games, told me about the rule of 72 in finance. It’s a simple formula that estimates the number of years it will take for an investment to double in value. If the annual interest rate is 8%, it’ll take 72/8 = 9 years for the value of your investment to double.</p>

<p>I wonder if I could treat myself as an investment, and measure my growth by how long it’d take me to become a new person. Becoming a new person isn’t always a good thing, and probably not the goal for everyone. But for me, it is. I want to be able to see things from a new perspective. I want to be exposed to new challenges. I treasure old friends (I still talk to my best friends in elementary school), but I like learning from new friends.</p>

<h2 id="time-to-solve-problems">Time to solve problems</h2>

<p>Quynh, an old friend who runs a publishing house in Vietnam, believes that there are three big problems in life: career, family, and finance. It usually takes people a decade to figure each out.</p>

<ol>
  <li>For the first decade after graduation, you figure out what you want to do with your life.</li>
  <li>For the next decade, you get married, buy a house, and have kids.</li>
  <li>For the next decade, you build out your savings to retire.</li>
</ol>

<p>Her goal is to solve these problems as fast as possible, so she can focus on more interesting problems.</p>

<p>This made me think that perhaps I can measure my growth by looking at what big problems I’ve solved. What big problems was I worried about 5 years ago that I no longer worry about now? What big problems am I worried about now that I don’t want to worry about in 5 years?</p>

<p>What is considered a big problem depends on each person. For me, it’s career, finance, social, immigration, family, and health. Here are a couple of concrete examples that made me feel like I’ve made progress. 5 years ago, I was anxious about being in the US on a visa. This problem went away when I got my green card. 5 years ago, I constantly felt insecure like I was an imposter in the Bay. Today, I feel at home here.</p>

<h2 id="number-of-future-options">Number of future options</h2>

<p>A friend I’ve met through my Discord, Denys, told me that his friend has this theory that every few years, half of your dreams die. People give up on their dreams because they realize that they can no longer achieve them.</p>

<p>I disagree. As I grow older, I have more dreams. I now know many things that I didn’t know before, and I have access to more resources than I ever did. This allows me to do things that I used to think of as impossible.</p>

<p>During a reinforcement learning course in college, I learned about empowerment maximization. It’s a simple principle that enables robots/agents to exhibit relatively intelligent behavior. In the face of uncertainty, an agent following empowerment maximization would choose the action that maximizes future options. For example, facing multiple switches, it’d choose the switch that opens the most doors.</p>

<p>I realized that this is the same principle that I’ve followed. In the face of uncertainty, I lean towards the decision that would give me the most future options. For example, I’d choose a job that pays less but gives me more job options in the future (e.g. if the job gives me exposure like allowing me to work on open source or publish papers). I’d prioritize tasks that teach me transferable skills instead of tasks that teach me niche, narrow skills.</p>

<p>Perhaps I can measure my growth by how many new options I have gained/lost. What options are available to me today that were not available to me 5 years ago? What options were available to me 5 years ago that aren’t available to me now? More importantly, what options that are not available to me today do I want 5 years from now?</p>

<p>Sami pointed me to this <a href="https://twitter.com/waitbutwhy/status/1367871165319049221">image</a> from Wait But Why. As time goes by, many doors are closed to us, but many new doors open up. Denys’s friend was referring to the black lines on the left, and I focus on the green lines on the right.</p>

<center>
    <figure>
    <img alt="Generative AI Stack" src="https://huyenchip.com/assets/pics/life_path_waitbywhy.jpeg" style="float: center; margin: 0 0 0em 0em;" />
    </figure>
</center>
<p><br /></p>

<h2 id="conclusion">Conclusion</h2>

<p>There are three heuristics that I follow for personal growth:</p>

<ol>
  <li>I try to become a new person every 3-6 years.</li>
  <li>I try to solve big problems as fast as possible. I think of this as creating safety nets that allow me to take bigger risks and explore more things in the future.</li>
  <li>I take actions that help me maximize future options.</li>
</ol>

<p>These heuristics work for me (so far) because I have a strong bias towards novelty and exploration. Maybe one day, I’ll get tired of exploration, and these heuristics will change. When that happens, that’ll be growth.</p>
]]></content:encoded>
<pubDate>Wed, 17 Apr 2024 00:00:00 +0000</pubDate>
</item>
<item>
<title>What I learned from looking at 900 most popular open source AI tools</title>
<link>https://huyenchip.com//2024/03/14/ai-oss.html</link>
<guid>https://huyenchip.com//2024/03/14/ai-oss.html</guid>
<content:encoded><![CDATA[
<div> 开源AI、四年、生成模型、中国、应用开发
<br /><br />总结：本文作者对开源AI领域的发展进行了四年前后的比较分析，重点关注了围绕基础模型的技术堆栈。他发现中国的开源生态系统与西方有所不同，整体看来，应用领域和应用开发层在近两年中发展迅速，2023年被誉为AI工程的一年。在模型开发领域，推出了更多的优化、评估和参数高效微调技术。中国的AI生态系统也在迅速成长，拥有许多热门AI开源仓库。一些开源项目迅速蹿红，但也有很多是昙花一现。作者认为个人开发者可能会成为未来市场的主力军。 <div>
<p>[<em><a href="https://news.ycombinator.com/item?id=39709912">Hacker News discussion</a>, <a href="https://www.linkedin.com/posts/chiphuyen_generativeai-aiapplications-llmops-activity-7174153467844820993-ztSE">LinkedIn discussion</a>, <a href="https://twitter.com/chipro/status/1768388213008445837">Twitter thread</a></em>]</p>

<p>Four years ago, I did an analysis of the <a href="https://huyenchip.com/2020/06/22/mlops.html">open source ML ecosystem</a>. Since then, the landscape has changed, so I revisited the topic. This time, I focused exclusively on the stack around foundation models.</p>

<p>The full list of open source AI repos is hosted at <a href="https://huyenchip.com/llama-police">llama-police</a>. The list is updated every 6 hours. You can also find most of them on my <a href="https://github.com/stars/chiphuyen/lists/cool-llm-repos">cool-llm-repos</a> list on GitHub.</p>

<hr />
<p><b>Table of contents</b><br />
<a href="https://huyenchip.com/feed.xml#data">Data</a><br />
…. <a href="https://huyenchip.com/feed.xml#add_missing_repos">How to add missing repos</a><br />
<a href="https://huyenchip.com/feed.xml#the_new_ai_stack">The New AI Stack</a><br />
…. <a href="https://huyenchip.com/feed.xml#ai_stack_over_time">AI stack over time</a><br />
…….. <a href="https://huyenchip.com/feed.xml#applications">Applications</a><br />
…….. <a href="https://huyenchip.com/feed.xml#ai_engineering">AI engineering</a><br />
…….. <a href="https://huyenchip.com/feed.xml#model_development">Model development</a><br />
…….. <a href="https://huyenchip.com/feed.xml#infrastructure">Infrastructure</a><br />
<a href="https://huyenchip.com/feed.xml#open_source_ai_developers">Open source AI developers</a><br />
…. <a href="https://huyenchip.com/feed.xml#the_rise_of_one_person_companies">One-person billion-dollar companies?</a><br />
…. <a href="https://huyenchip.com/feed.xml#1_million_commits">1 million commits</a><br />
<a href="https://huyenchip.com/feed.xml#the_growing_china_open_source_ecosystem">The growing China’s open source ecosystem</a><br />
<a href="https://huyenchip.com/feed.xml#live_fast_die_young">Live fast, die young</a><br />
<a href="https://huyenchip.com/feed.xml#my_personal_favorite_ideas">My personal favorite ideas</a><br />
<a href="https://huyenchip.com/feed.xml#conclusion">Conclusion</a><br /></p>

<hr />
<p><br /></p>

<h2 id="data">Data</h2>

<p>I searched GitHub using the keywords <code class="language-plaintext highlighter-rouge">gpt</code>, <code class="language-plaintext highlighter-rouge">llm</code>, and <code class="language-plaintext highlighter-rouge">generative ai</code>. If AI feels so overwhelming right now, it’s because it is. There are 118K results for <code class="language-plaintext highlighter-rouge">gpt</code> alone.</p>

<p>To make my life easier, I limited my search to the repos with at least 500 stars. There were 590 results for <code class="language-plaintext highlighter-rouge">llm</code>, 531 for <code class="language-plaintext highlighter-rouge">gpt</code>, and 38 for <code class="language-plaintext highlighter-rouge">generative ai</code>. I also occasionally checked GitHub trending and social media for new repos.</p>

<p>After MANY hours, I found 896 repos. Of these, 51 are tutorials (e.g. <a href="https://github.com/dair-ai/Prompt-Engineering-Guide">dair-ai/Prompt-Engineering-Guide</a>) and aggregated lists (e.g. <a href="https://github.com/f/awesome-chatgpt-prompts">f/awesome-chatgpt-prompts</a>). While these tutorials and lists are helpful, I’m more interested in software. I still include them in the final list, but the analysis is done with the 845 software repositories.</p>

<p>It was a painful but rewarding process. It gave me a much better understanding of what people are working on, how incredibly collaborative the open source community is, and just how much China’s open source ecosystem diverges from the Western one.</p>

<h3 id="add_missing_repos">Add missing repos</h3>

<p>I undoubtedly missed a ton of repos. You can submit the missing repos <a href="https://forms.gle/1ijNSnizgWQaVYK16">here</a>. The list will be automatically updated every day.</p>

<p>Feel free to submit the repos with less than 500 stars. I’ll continue tracking them and add them to the list when they reach 500 stars!</p>

<h2 id="the_new_ai_stack">The New AI Stack</h2>

<p>I think of the AI stack as consisting of 4 layers: infrastructure, model development, application development, and applications.</p>

<center>
    <figure>
    <img alt="Generative AI Stack" src="https://huyenchip.com/assets/pics/ai-oss/1-ai-stack.png" style="float: center; margin: 0 0 0em 0em;" />
    </figure>
</center>
<p><br /></p>

<ol>
  <li>
    <p><strong>Infrastructure</strong></p>

    <p>At the bottom is the stack is infrastructure, which includes toolings for serving (<a href="https://github.com/vllm-project/vllm">vllm</a>, <a href="https://github.com/triton-inference-server/server">NVIDIA’s Triton</a>), compute management (<a href="https://github.com/skypilot-org/skypilot">skypilot</a>), vector search and database (<a href="https://github.com/facebookresearch/faiss">faiss</a>, <a href="https://milvus.io/">milvus</a>, <a href="https://github.com/qdrant/qdrant">qdrant</a>, <a href="https://github.com/lancedb/lancedb">lancedb</a>), ….</p>
  </li>
  <li>
    <p><strong>Model development</strong></p>

    <p>This layer provides toolings for developing models, including frameworks for modeling &amp; training (transformers, pytorch, DeepSpeed), inference optimization (ggml, openai/triton), dataset engineering, evaluation, ….. Anything that involves changing a model’s weights happens in this layer, including finetuning.</p>
  </li>
  <li>
    <p><strong>Application development</strong>
 With readily available models, anyone can develop applications on top of them. This is the layer that has seen the most actions in the last 2 years and is still rapidly evolving. This layer is also known as AI engineering.</p>

    <p>Application development involves prompt engineering, RAG, AI interface, …</p>
  </li>
  <li>
    <p><strong>Applications</strong></p>

    <p>There are many open sourced applications built on top of existing models. The most popular types of applications are coding, workflow automation, information aggregation, …</p>
  </li>
</ol>

<p>Outside of these 4 layers, I also have another category, <strong>Model repos</strong>, that are created by companies and researchers to share the code associated with their models. Examples of repos in this category are <code class="language-plaintext highlighter-rouge">CompVis/stable-diffusion</code>, <code class="language-plaintext highlighter-rouge">openai/whisper</code>, and <code class="language-plaintext highlighter-rouge">facebookresearch/llama</code>.</p>

<h3 id="ai_stack_over_time">AI stack over time</h3>
<p>I plotted the cumulative number of repos in each category month-over-month. There was an explosion of new toolings in 2023, after the introduction of Stable Diffusion and ChatGPT. The curve seems to flatten in September 2023 because of three potential reasons.</p>

<ol>
  <li>I only include repos with at least 500 stars in my analysis, and it takes time for repos to gather these many stars.</li>
  <li>Most low-hanging fruits have been picked. What is left takes more effort to build, hence fewer people can build them.</li>
  <li>People have realized that it’s hard to be competitive in the generative AI space, so the excitement has calmed down. Anecdotally, in early 2023, all AI conversations I had with companies centered around gen AI, but the recent conversations are more grounded. Several even brought up scikit-learn. I’d like to revisit this in a few months to verify if it’s true.</li>
</ol>

<center>
    <figure>
    <img alt="Generative AI Stack Over Time" src="https://huyenchip.com/assets/pics/ai-oss/2-ai-timeline.png" style="float: center; margin: 0 0 0em 0em;" />
    </figure>
</center>
<p><br /></p>

<p>In 2023, the layers that saw the highest increases were the applications and application development layers. The infrastructure layer saw a little bit of growth, but it was far from the level of growth seen in other layers.</p>

<h4 id="applications">Applications</h4>

<p>Not surprisingly, the most popular types of applications are coding, bots (e.g. role-playing, WhatsApp bots, Slack bots), and information aggregation (e.g. “let’s connect this to our Slack and ask it to summarize the messages each day”).</p>

<center>
    <figure>
    <img alt="Breakdown of popular AI applications" src="https://huyenchip.com/assets/pics/ai-oss/3-ai-applications.png" style="float: center; margin: 0 0 0em 0em;" />
    </figure>
</center>
<p><br /></p>

<h4 id="ai_engineering">AI engineering</h4>

<p>2023 was the year of AI engineering. Since many of them are similar, it’s hard to categorize the tools. I currently put them into the following categories: prompt engineering, AI interface, Agent, and AI engineering (AIE) framework.</p>

<p><strong>Prompt engineering</strong> goes way beyond fiddling with prompts to cover things like constrained sampling (structured outputs), long-term memory management, prompt testing &amp; evaluation, etc.</p>

<center>
    <figure>
    <img alt="A list of prompt engineering tools" src="https://huyenchip.com/assets/pics/ai-oss/4-prompt-engineering.png" style="float: center; margin: 0 0 0em 0em;" />
    </figure>
</center>
<p><br /></p>

<p><strong>AI interface</strong> provides an interface for your end users to interact with your AI application. This is the category I’m the most excited about. Some of the interfaces that are gaining popularity are:</p>

<ul>
  <li>Web and desktop apps.</li>
  <li>Browser extensions that let users quickly query AI models while browsing.</li>
  <li>Bots via chat apps like Slack, Discord, WeChat, and WhatsApp.</li>
  <li>Plugins that let developers embed AI applications to applications like VSCode, Shopify, and Microsoft Offices. The plugin approach is common for AI applications that can use tools to complete complex tasks (agents).</li>
</ul>

<p><strong>AIE framework</strong> is a catch-all term for all platforms that help you develop AI applications. Many of them are built around RAG, but many also provide other toolings such as monitoring, evaluation, etc.</p>

<p><strong>Agent</strong> is a weird category, as many agent toolings are just sophisticated prompt engineering with potentially constrained generation (e.g. the model can only output the predetermined action) and plugin integration (e.g. to let the agent use tools).</p>

<center>
    <figure>
    <img alt="AI engineering stack over time" src="https://huyenchip.com/assets/pics/ai-oss/5-ai-engineering.png" style="float: center; margin: 0 0 0em 0em;" />
    </figure>
</center>
<p><br /></p>

<h4 id="model_development">Model development</h4>

<p>Pre-ChatGPT, the AI stack was dominated by model development. Model development’s biggest growth in 2023 came from increasing interest in inference optimization, evaluation, and parameter-efficient finetuning (which is grouped under Modeling &amp; training).</p>

<p>Inference optimization has always been important, but the scale of foundation models today makes it crucial for latency and cost. The core approaches for optimization remain the same (quantization, low-ranked factorization, pruning, distillation), but many new techniques have been developed especially for the transformer architecture and the new generation of hardware. For example, in 2020, 16-bit quantization was considered state-of-the-art. Today, we’re seeing <a href="https://arxiv.org/abs/2212.09720">2-bit quantization</a> and <a href="https://arxiv.org/abs/2402.17764">even lower than 2-bit</a>.</p>

<p>Similarly, evaluation has always been essential, but with many people today treating models as blackboxes, evaluation has become even more so. There are many new evaluation benchmarks and evaluation methods, such as comparative evaluation (see <a href="https://huyenchip.com/2024/02/28/predictive-human-preference.html#correctness_of_chatbot_arena_ranking">Chatbot Arena</a>) and AI-as-a-judge.</p>

<center>
    <figure>
    <img alt="Model Development Stack Over Time" src="https://huyenchip.com/assets/pics/ai-oss/6-model-development.png" style="float: center; margin: 0 0 0em 0em;" />
    </figure>
</center>
<p><br /></p>

<h4 id="infrastructure">Infrastructure</h4>

<p>Infrastructure is about managing data, compute, and toolings for serving, monitoring, and other platform work. Despite all the changes that generative AI brought, the open source AI infrastructure layer remained more or less the same. This could also be because infrastructure products are typically not open sourced.</p>

<p>The newest category in this layer is vector database with companies like Qdrant, Pinecone, and LanceDB. However, many argue this shouldn’t be a category at all. Vector search has been around for a long time. Instead of building new databases just for vector search, existing database companies like DataStax and Redis are bringing vector search into where the data already is.</p>

<h2 id="open_source_ai_developers">Open source AI developers</h2>

<p>Open source software, like many things, follows the long tail distribution. A handful of accounts control a large portion of the repos.</p>

<h3 id="the_rise_of_one_person_companies">One-person billion-dollar companies?</h3>
<p>845 repos are hosted on 594 unique GitHub accounts. There are 20 accounts with at least 4 repos. These top 20 accounts host 195 of the repos, or 23% of all the repos on the list. These 195 repos have gained a total of 1,650,000 stars.</p>

<center>
    <figure>
    <img alt="Most active GitHub accounts" src="https://huyenchip.com/assets/pics/ai-oss/7-top-accounts.png" style="float: center; margin: 0 0 0em 0em;" />
    </figure>
</center>
<p><br /></p>

<p>On Github, an account can be either an organization or an individual. 19/20 of the top accounts are organizations. Of those, 3 belong to Google: <code class="language-plaintext highlighter-rouge">google-research</code>, <code class="language-plaintext highlighter-rouge">google</code>, <code class="language-plaintext highlighter-rouge">tensorflow</code>.</p>

<p>The only individual account in these top 20 accounts is lucidrains. Among the top 20 accounts with the most number of stars (counting only gen AI repos), 4 are individual accounts:</p>

<ul>
  <li><a href="https://github.com/lucidrains">lucidrains</a> (Phil Wang): who can implement state-of-the-art models insanely fast.</li>
  <li><a href="https://github.com/ggerganov">ggerganov</a> (Georgi Gerganov): an optimization god who comes from a physics background.</li>
  <li><a href="https://github.com/lllyasviel">Illyasviel</a> (Lyumin Zhang): creator of Foocus and ControlNet who’s currently a Stanford PhD.</li>
  <li><a href="https://github.com/xtekky">xtekky</a>: a full-stack developer who created gpt4free.</li>
</ul>

<center>
    <figure>
    <img alt="Most active GitHub accounts" src="https://huyenchip.com/assets/pics/ai-oss/8-top-accounts-stars.png" style="float: center; margin: 0 0 0em 0em;" />
    </figure>
</center>
<p><br /></p>

<p>Unsurprisingly, the lower we go in the stack, the harder it is for individuals to build. Software in the infrastructure layer is the least likely to be started and hosted by individual accounts, whereas more than half of the applications are hosted by individuals.</p>

<center>
    <figure>
    <img alt="Can you do this alone?" src="https://huyenchip.com/assets/pics/ai-oss/9-indie.png" style="float: center; margin: 0 0 0em 0em;" />
    </figure>
</center>
<p><br /></p>

<p>Applications started by individuals, on average, have gained more stars than applications started by organizations. Several people have speculated that we’ll see many very valuable one-person companies (see <a href="https://fortune.com/2024/02/04/sam-altman-one-person-unicorn-silicon-valley-founder-myth/">Sam Altman’s interview</a> and <a href="https://www.reddit.com/r/ChatGPT/comments/1ajwj5z/one_person_billion_dollar_company/">Reddit discussion</a>). I think they might be right.</p>

<center>
    <figure>
    <img alt="Can you do this alone?" src="https://huyenchip.com/assets/pics/ai-oss/10-indie-stars.png" style="float: center; margin: 0 0 0em 0em;" />
    </figure>
</center>
<p><br /></p>

<h3 id="1_million_commits">1 million commits</h3>

<p>Over 20,000 developers have contributed to these 845 repos. In total, they’ve made almost a million contributions!</p>

<p>Among them, the 50 most active developers have made over 100,000 commits, averaging over 2,000 commits each. See the full list of the top 50 most active open source developers <a href="https://huyenchip.com/llama-devs">here</a>.</p>

<center>
    <figure>
    <img alt="Most active open source developers" src="https://huyenchip.com/assets/pics/ai-oss/11-devs.png" style="float: center; margin: 0 0 0em 0em;" />
    </figure>
</center>
<p><br /></p>

<h2 id="the_growing_china_open_source_ecosystem">The growing China's open source ecosystem</h2>

<p>It’s been known for a long time that China’s AI ecosystem has diverged from the US (I also mentioned that in a <a href="https://huyenchip.com/2020/12/27/real-time-machine-learning.html#mlops_china_vs_us">2020 blog post</a>). At that time, I was under the impression that GitHub wasn’t widely used in China, and my view back then was perhaps colored by China’s 2013 ban on GitHub.</p>

<p>However, this impression is no longer true. There are many, many popular AI repos on GitHub targeting Chinese audiences, such that their descriptions are written in Chinese. There are repos for models developed for Chinese or Chinese + English, such as <a href="https://github.com/QwenLM/Qwen">Qwen</a>, <a href="https://github.com/THUDM/ChatGLM3">ChatGLM3</a>, <a href="https://github.com/ymcui/Chinese-LLaMA-Alpaca">Chinese-LLaMA</a>.</p>

<p>While in the US, many research labs have moved away from the RNN architecture for language models, the RNN-based model family <a href="https://github.com/BlinkDL/RWKV-LM">RWKV</a> is still popular.</p>

<p>There are also AI engineering tools providing ways to integrate AI models into products popular in China like WeChat, QQ, DingTalk, etc. Many popular prompt engineering tools also have mirrors in Chinese.</p>

<p>Among the top 20 accounts on GitHub, 6 originated in China:</p>

<ol>
  <li><a href="https://github.com/THUDM">THUDM</a>: Knowledge Engineering Group (KEG) &amp; Data Mining at Tsinghua University.</li>
  <li><a href="https://github.com/OpenGVLab">OpenGVLab</a>: General Vision team of Shanghai AI Laboratory</li>
  <li><a href="https://github.com/OpenBMB">OpenBMB</a>: Open Lab for Big Model Base, founded by ModelBest &amp; the NLP group at Tsinghua University.</li>
  <li><a href="https://github.com/InternLM">InternLM</a>: from Shanghai AI Laboratory.</li>
  <li><a href="https://github.com/open-mmlab">OpenMMLab</a>: from The Chinese University of Hong Kong.</li>
  <li><a href="https://github.com/QwenLM">QwenLM</a>: Alibaba’s AI lab, which publishes the Qwen model family.</li>
</ol>

<h2 id="live_fast_die_young">Live fast, die young</h2>

<p>One pattern that I saw last year is that many repos quickly gained a massive amount of eyeballs, then quickly died down. Some of my friends call this the “hype curve”. Out of these 845 repos with at least 500 GitHub stars, 158 repos (18.8%) haven’t gained any new stars in the last 24 hours, and 37 repos (4.5%) haven’t gained any new stars in the last week.</p>

<p>Here are examples of the growth trajectory of two of such repos compared to the growth curve of two more sustained software. Even though these two examples shown here are no longer used, I think they were valuable in showing the community what was possible, and it was cool that the authors were able to get things out so fast.</p>

<center>
    <figure>
    <img alt="Hype curve" src="https://huyenchip.com/assets/pics/ai-oss/12-hype-curve.png" style="float: center; margin: 0 0 0em 0em;" />
    </figure>
</center>
<p><br /></p>

<h2 id="my_personal_favorite_ideas">My personal favorite ideas</h2>

<p>So many cool ideas are being developed by the community. Here are some of my favorites.</p>

<ul>
  <li>Batch inference optimization: <a href="https://github.com/FMInference/FlexGen">FlexGen</a>, <a href="https://github.com/ggerganov/llama.cpp/pull/1375">llama.cpp</a></li>
  <li>Faster decoder with techniques such as <a href="https://github.com/FasterDecoding/Medusa">Medusa</a>, <a href="https://github.com/hao-ai-lab/LookaheadDecoding">LookaheadDecoding</a></li>
  <li>Model merging: <a href="https://github.com/cg123/mergekit">mergekit</a></li>
  <li>Constrained sampling: <a href="https://github.com/outlines-dev">outlines</a>, <a href="https://github.com/guidance-ai/guidance">guidance</a>, <a href="https://github.com/sgl-project/sglang">SGLang</a></li>
  <li>Seemingly niche tools that solve one problem really well, such as <a href="https://github.com/arogozhnikov/einops">einops</a> and <a href="https://github.com/huggingface/safetensors">safetensors</a>.</li>
</ul>

<h2 id="conclusion">Conclusion</h2>

<p>Even though I included only 845 repos in my analysis, I went through several thousands of repos. I found this helpful for me to get a big-picture view of the seemingly overwhelming AI ecosystem. I hope the <a href="https://huyenchip.com/llama-police">list</a> is useful for you too. Please do let me know what repos I’m missing, and I’ll add them to the list!</p>
]]></content:encoded>
<pubDate>Thu, 14 Mar 2024 00:00:00 +0000</pubDate>
</item>
<item>
<title>Predictive Human Preference: From Model Ranking to Model Routing</title>
<link>https://huyenchip.com//2024/02/28/predictive-human-preference.html</link>
<guid>https://huyenchip.com//2024/02/28/predictive-human-preference.html</guid>
<content:encoded><![CDATA[
<div> 关键词: AI应用，人类偏好，预测，模型选择，实验结果

总结:<br /><br />本文讨论了如何使用人类偏好来预测最适合的模型，进行模型选择。作者通过实验验证了人类偏好模型在匹配预测中的准确性，以及使用人类偏好进行领域特定的模型排名和路由。通过使用少量数据，作者展示了预测人类偏好的可行性，并指出了模型路由在经济上的潜在价值。此外，作者还提及了其他团队在模型选择方面的工作和应用。整体来说，预测人类偏好对模型选择和路由有着重要影响，是一个具有潜力的研究领域。 <div>
<p>A challenge of building AI applications is choosing which model to use. What if we don’t have to? What if we can predict the best model for any prompt? Predictive human preference aims to predict which model users might prefer for a specific query.</p>

<hr />
<p><b>Table of contents</b><br /></p>

<p><a href="https://huyenchip.com/feed.xml#ranking_models_using_human_preference">Ranking Models Using Human Preference</a><br />
…. <a href="https://huyenchip.com/feed.xml#how_preferential_ranking_works">How Preferential Ranking Works</a><br />
…. <a href="https://huyenchip.com/feed.xml#correctness_of_chatbot_arena_ranking">Correctness of Chatbot Arena Ranking</a><br />
…….. <a href="https://huyenchip.com/feed.xml#eval_data">Eval data</a><br />
…….. <a href="https://huyenchip.com/feed.xml#results">Results</a><br />
<a href="https://huyenchip.com/feed.xml#predicting_human_preference_for_each_prompt">Predicting Human Preference For Each Prompt</a><br />
…. <a href="https://huyenchip.com/feed.xml#experiment_setup">Experiment setup</a><br />
…. <a href="https://huyenchip.com/feed.xml#experiment_results">Experiment results</a><br />
…….. <a href="https://huyenchip.com/feed.xml#domain_specific_and_query_specific_leaderboards">Domain-specific and query-specific leaderboards</a><br />
<a href="https://huyenchip.com/feed.xml#conclusion">Conclusion</a><br /></p>

<hr />
<p><br /></p>

<p>Human preference has emerged to be both the Northstar and a powerful tool for AI model development. Human preference guides post-training techniques including <a href="https://huyenchip.com/2023/05/02/rlhf.html">RLHF</a> and <a href="https://arxiv.org/abs/2305.18290">DPO</a>. Human preference is also used to rank AI models, as used by LMSYS’s <a href="https://arena.lmsys.org/">Chatbot Arena</a>.</p>

<p>Chatbot Arena aims to determine which model is generally preferred. I wanted to see if it’s possible to predict which model is preferred <em>for each query</em>.</p>

<p>One use case of predictive human preference is model routing. For example, if we know in advance that for a prompt, users will prefer Claude Instant’s response over GPT-4, and Claude Instant is cheaper/faster than GPT-4, we can route this prompt to Claude Instant. Model routing has the potential to increase response quality while reducing costs and latency.</p>

<p>Another use case of predictive human preference is interpretability. Mapping out a model’s performance on different prompts can help us understand this model’s strengths and weaknesses. See section <strong>Experiment results</strong> for examples.</p>

<p>Here’s what predictive human preference for different model pairs looks like for the prompt “<em>What’s the best way to cluster text embeddings?</em>”. The predictions were generated by my toy preference predictor. The bright yellow color for the (GPT-4, GPT-3.5-Turbo) cell means that my predictor thinks GPT-4’s response is very likely to be preferred to that of GPT-3.5-Turbo’s for this prompt.</p>

<center>
    <figure>
    <img alt="Predictive human preference for all LLM model pairs" src="https://huyenchip.com/assets/pics/predictive-preference/1-cluster.png" style="float: center; margin: 0 0 0em 0em;" />
    </figure>
</center>
<p><br /></p>

<p>This post first discusses the correctness of Chatbot Arena, which will then be used as a baseline to evaluate the correctness of preference predictions. It then discusses how to build a preference predictor and the initial results.</p>

<h2 id="ranking_models_using_human_preference">Ranking Models Using Human Preference</h2>

<p>Using preferential signals (comparisons) to rank models has grown in popularity in the last few years. Other than powering LMSYS’s <a href="https://arena.lmsys.org/">Chatbot Arena</a>, it’s also used by many model providers (<a href="https://arxiv.org/abs/2112.00861">Anthropic</a>, Gemini, ChatGPT, etc.) to evaluate their models in production.</p>

<center>
    <figure>
    <img alt="Predictive human preference for all LLM model pairs" src="https://huyenchip.com/assets/pics/predictive-preference/2-chatgpt.png" style="float: center; margin: 0 0 0em 0em;" />
    </figure>
</center>
<p><br /></p>

<p><strong>Side note</strong>: Friends who have deployed this in production told me that most users don’t read both options and just randomly vote for one. This introduces a lot of noise. However, the signals from the small percentage of users who vote correctly can sometimes be sufficient to help determine which model is preferred, as long as there’s minimal bias in the random voting.</p>

<h3 id="how_preferential_ranking_works">How Preferential Ranking Works</h3>

<p>Preferential ranking works in two steps:</p>

<ol>
  <li>Collect comparison data about user preference.</li>
  <li>Compute a model ranking from these comparisons.</li>
</ol>

<p>For each request, two or more models are selected to respond. An evaluator, which can be human or AI, picks the winner. The evaluator shouldn’t know which models are being judged. Each comparison is called a <em>match</em>. This process results in a series of comparisons.</p>

<table>
    
    <tr>
      <td><strong>Match ID</strong></td>
    <td><strong>Prompt</strong>
    </td>
    <td><strong>Model A</strong>
    </td>
    <td><strong>Model B</strong>
    </td>
    <td><strong>Winner</strong>
    </td>
    </tr>
    <tr>
    <td>1
    </td>
    <td>…
    </td>
    <td>Model 1
    </td>
    <td>Model 2
    </td>
    <td>Model 1
    </td>
    </tr>
    <tr>
    <td>2
    </td>
    <td>…
    </td>
    <td>Model 3
    </td>
    <td>Model 1
    </td>
    <td>Model 1
    </td>
    </tr>
    <tr>
    <td>3
    </td>
    <td>…
    </td>
    <td>Model 1
    </td>
    <td>Model 4
    </td>
    <td>Model 4
    </td>
    </tr>
    <tr>
    <td> ...
    </td>
    <td> ...
    </td>
    <td> ...
    </td>
    <td> ...
    </td>
    <td> ...
    </td>
    </tr>
</table>
<p><br /></p>

<p>From these comparisons, we need to compute the rankings of all models. The two most common ranking algorithms are <a href="https://en.wikipedia.org/wiki/Elo_rating_system">Elo</a> (from chess) and <a href="https://en.wikipedia.org/wiki/TrueSkill">TrueSkill</a> (from video games).</p>

<p>While Chatbot Arena refers to their model scores “Elo scores”, they actually don’t use Elo. In December 2023, they switched to <a href="https://lmsys.org/blog/2023-12-07-leaderboard/#transition-from-online-elo-rating-system-to-bradley-terry-model">Bradley-Terry</a> but scaled the resulting scores to make them look Elo-like (see their <a href="https://colab.research.google.com/drive/1KdwokPjirkTmpO_P1WByFNFiqxWQquwH#scrollTo=HdZrGr4IcWCl">notebook</a>).</p>

<p>Given a history of match outcomes, the Bradley-Terry algorithm finds the model scores that maximize the likelihood of these match outcomes, turning model scoring into a maximum likelihood estimation problem. The input, for each training example, is the models that participate in the match. The output is the outcome of the match. Assuming there’s no draw, the outcome of a match is either 0 (a wins) or 1 (b wins).</p>

<center>
    <figure>
    <img alt="Predictive human preference for all LLM model pairs" src="https://huyenchip.com/assets/pics/predictive-preference/3-bradley-terry.png" style="float: center; margin: 0 0 0em 0em;" />
    </figure>
</center>
<p><br /></p>

<h3 id="correctness_of_chatbot_arena_ranking">Correctness of Chatbot Arena Ranking</h3>

<p>Given the same match outcomes, different ranking algorithms can produce different rankings. For example, the ranking computed by Elo might differ from the ranking computed by Bradley-Terry. How do we know that a ranking is correct?</p>

<p>At its core, model ranking is a predictive problem. We compute a ranking from historical match outcomes and use it to predict future match outcomes. The quality of a ranking is determined by how accurately it can predict future match outcomes.</p>

<p>Let’s say we have a match between model A and model B. If model A has a higher score, meaning that the ranking algorithm predicts that A wins. If users indeed prefer the higher-ranking model, the ranking algorithm makes a correct prediction.</p>

<h4 id="eval_data">Eval data</h4>

<p>To compute the accuracy of Chatbot Arena ranking, I used their data published in July 2023, which consists of <a href="https://drive.google.com/file/d/1ZXiBRtADf9HZ8eEarIFTy-qrPNDUP_H0/view">33K crowd-sourced comparisons</a> for matches among 20 models. I used this smaller dataset instead of <a href="https://drive.google.com/file/d/1ZXiBRtADf9HZ8eEarIFTy-qrPNDUP_H0/view">their Jan 2024 dataset</a> because this smaller dataset contains the prompt used for each match, which I need for predictive human preference. Benchmarking on this dataset allows me to compare my model with the Bradley-Terry algorithm later on.</p>

<p>Here’s an example from their July 2023 dataset.</p>

<table>
    
  <tr>
   <td><strong>prompt</strong>
   </td>
   <td><strong>model_a</strong>
   </td>
   <td><strong>model_b</strong>
   </td>
   <td><strong>winner</strong>
   </td>
   <td><strong>model_a's response</strong>
   </td>
   <td><strong>model_b's response</strong>
   </td>
  </tr>
  <tr>
   <td>who was the last monarch of uk
   </td>
   <td>koala-13b
   </td>
   <td>vicuna-13b
   </td>
   <td>model_a
   </td>
   <td>The last monarch of the United Kingdom was Queen Elizabeth II, who reigned from 1952 to 2020.
   </td>
   <td>The current monarch of the United Kingdom is Queen Elizabeth II. She has been the monarch since 1952, and is the longest-reigning monarch in British history.
   </td>
  </tr>
</table>
<p><br /></p>

<p>For reference, the Bradley-Terry (BT) scores of the top 7 models in this dataset are as follows.</p>

<ol>
  <li>GPT-4: 1189</li>
  <li>Claude-v1: 1150</li>
  <li>Claude-instant-v1: 1110</li>
  <li>GPT-3.5-Turbo: 1104</li>
  <li>WizardLM-13B: 1058</li>
  <li>Vicuna-13b: 1040</li>
  <li>Guanaco-33b: 1031</li>
</ol>

<p>To create a test set, I randomly select 10% of the data (3300 examples). Each match has three possible outcomes: model_a wins, model_b wins, or tie. This can still be framed as a binary classification problem if we treat a tied match as two matches: one in which model_a wins and one in which model_b wins.</p>

<h4 id="results">Results</h4>

<p>I found that for all non-tie matches in my test set, the model with the higher Bradley-Terry score is preferred 74.1% of the time. This means that if we always predict the higher-ranked model as the winner for a match, we’d have an accuracy of 74.1%.</p>

<table>
  <tr>
   <td><strong>Test data</strong>
   </td>
   <td><strong>Output classes</strong>
   </td>
   <td><strong># samples</strong>
   </td>
   <td><strong>BT's accuracy</strong>
   </td>
  </tr>
  <tr>
   <td>All matches
   </td>
   <td>
        <ul>
            <li>model_a wins</li>
            <li>model_b wins</li>
            <li>tie</li>
        </ul>  
   </td>
   <td>3,300
   </td>
   <td>53.33%
   </td>
  </tr>
  <tr>
   <td>Non-tie matches
   </td>
   <td>
<ul>
    <li>model_a wins</li>
    <li>model_b wins</li>
</ul>
   </td>
   <td>2,367
   </td>
   <td>74.1%
   </td>
  </tr>
  <tr>
   <td>Non-tie matches involving GPT-4
   </td>
   <td>
        <ul>
            <li>model_a wins</li>
            <li>model_b wins</li>
        </ul>
   </td>
   <td>355
   </td>
   <td>85.1% (always pick GPT-4 as winner) </td>
  </tr>
</table>
<p><br /></p>

<p>Back in July 2023, GPT-4 was considered the strongest model by a long shot (this was before Gemini, Mistral, Claude-v2). Did users always prefer GPT-4 to all other models? They didn’t. In 355 non-tie matches involving GPT-4, GPT-4 wins 85.1%.</p>

<p>This means that even though GPT-4 is the best model overall, there are prompts for which other models can outperform GPT-4. If we can figure out which prompts these are, and which models work best for them, we can route these prompts to the best-performing models, improving the response quality.</p>

<h2 id="predicting_human_preference_for_each_prompt">Predicting Human Preference For Each Prompt</h2>

<p>If a ranking algorithm is about figuring out which model is better overall, predictive human preference is about figuring out which model is better for each prompt. If we know in advance that for a particular prompt, GPT-3.5 works just as well as GPT-4, and GPT-3.5 is cheaper, we can route that prompt to GPT-3.5 instead. Or if we know that Mistral-7B works just as well as GPT-4 and Mistral-7B is faster, we can route our query to Mistral-7B instead.</p>

<p>Model routing can also help with budget planning. Say, you only have enough budget to serve 50% of queries on the strongest model, and the rest to a weaker model, you want to make sure that you send to the weaker model only the queries that you’re confident it can do well on.</p>

<h3 id="experiment_setup">Experiment setup</h3>

<p>I treat predictive human preference as a binary classification task. Given a match between 2 models, predict which one wins. If the probability of model_a winning is around 0.5, it can be considered a tie. If a Bradley-Terry model takes only <code class="language-plaintext highlighter-rouge">(model_a, model_b)</code> as the input, a preference predictor takes <code class="language-plaintext highlighter-rouge">(prompt, model_a, model_b)</code> as the input.</p>

<center>
    <figure>
    <img alt="Predictive human preference for all LLM model pairs" src="https://huyenchip.com/assets/pics/predictive-preference/4-preference-predictor.png" style="float: center; margin: 0 0 0em 0em;" />
    </figure>
</center>
<p><br /></p>

<p>The architecture of my preference predictor looks like this. The model encoder and preference predictor are neural networks that can be trained independently or together. I used DistilBERT as my prompt encoder.</p>

<center>
    <figure>
    <img alt="Predictive human preference for all LLM model pairs" src="https://huyenchip.com/assets/pics/predictive-preference/5-predictive-preference-architecture.png" style="float: center; margin: 0 0 0em 0em;" />
    </figure>
</center>
<p><br /></p>

<p>To train my model, I used 90% of LMSYS’s July 2023 dataset. I found that the predictor performed better using only non-tie matches (as opposed to using both tie and non-tie matches). I randomly flipped the order of models in a match 50% of the time.</p>

<p>To evaluate my model, I used 10% of this data. This is the same test data used to evaluate the correctness of Chatbot Arena’s ranking above.</p>

<table>
  <tr>
   <td><strong>Split</strong>
   </td>
   <td><strong>All matches</strong>
   </td>
   <td><strong>Non-tie matches</strong>
   </td>
  </tr>
  <tr>
   <td>Train
   </td>
   <td>29,700
   </td>
   <td>20,927
   </td>
  </tr>
  <tr>
   <td>Test
   </td>
   <td>3,300
   </td>
   <td>2,367
   </td>
  </tr>
</table>
<p><br /></p>

<p><strong>Note</strong>: I should’ve made a separate validation set for hyperparameter tuning. However, given that I didn’t have a lot of data and this is only a proof of concept, I didn’t do it. (I’m also lazy.) The matches are among 20 models, corresponding to 190 model pairs. 20,927 comparisons mean that, on average, there are only 110 comparisons per model pair.</p>

<h3 id="experiment_results">Experiment results</h3>

<p>I evaluated my preference predictor under two settings:</p>

<ol>
  <li>Using only <code class="language-plaintext highlighter-rouge">model_a</code> and <code class="language-plaintext highlighter-rouge">model_b</code> as the input. This is to see whether this predictor, using only model names, can make better predictions about match outcomes than Chatbot Arena scores.</li>
  <li>Using <code class="language-plaintext highlighter-rouge">(prompt, model_a, model_b)</code> as the input. This is to see whether including prompts helps improve match outcome prediction.</li>
</ol>

<p>I found that for all non-tie matches, my preference predictor can predict the match outcome accurately 75% of the time if not using prompts, and 76.2% of the time if using prompts. This suggests that human preference for models does change depending on the prompt. While the improvement doesn’t seem much, a 2.1% improvement can be significant at scale.</p>

<table>
  <tr>
   <td><strong>Eval data</strong>
   </td>
   <td><strong># eval samples</strong>
   </td>
   <td><strong>Chatbot Arena</strong>
   </td>
   <td><strong>Preference predictor</strong><br />(without prompts)
   </td>
   <td><strong>Preference predictor</strong><br />(with prompts)
   </td>
  </tr>
  <tr>
   <td>Non-tie matches
   </td>
   <td>2,367
   </td>
   <td>74.1%
   </td>
   <td>75%
   </td>
   <td>76.2%
   </td>
  </tr>
  <tr>
   <td>Non-tie matches involving GPT-4
   </td>
   <td>355
   </td>
   <td>85.1%
   </td>
   <td>86.2%
   </td>
   <td>87%
   </td>
  </tr>
</table>
<p><br /></p>

<p>Keep in mind that this predictor was trained with a small amount of crowd-sourced (e.g. noisy) data. The prompts crowdsourced are also simple. Among <a href="https://huggingface.co/datasets/lmsys/chatbot_arena_conversations">33K prompts</a>, 180 (0.55%) of them are “hello” and “hi”. These simple prompts are insufficient to distinguish strong models from weak ones. I suspect that with more/better data, the performance of this predictor can significantly improve.</p>

<h4 id="domain_specific_and_query_specific_leaderboards">Domain-specific and query-specific leaderboards</h4>

<p>Recall that 20 models correspond to 190 model pairs. To visualize how the predictor captures human preference, for each evaluation prompt, I generated 190 different inputs, one for each model pair.</p>

<center>
    <figure>
    <img alt="Predictive human preference for all LLM model pairs" src="https://huyenchip.com/assets/pics/predictive-preference/6-model-pairs.png" style="float: center; margin: 0 0 0em 0em;" />
    </figure>
</center>
<p><br /></p>

<p>I then visualized the 190 predictions for 190 model pairs in a 20 x 20 grid, as shown below for the prompt “Derive the elastic wave equation.” I only included 9 models in the plot to make it readable. The diagonal values refer to comparing a model to itself, so the predicted preference should be 0.5.</p>

<center>
    <figure>
    <img alt="Predictive human preference for all LLM model pairs" src="https://huyenchip.com/assets/pics/predictive-preference/7-derive.png" style="float: center; margin: 0 0 0em 0em;" />
    </figure>
</center>
<p><br /></p>

<p>Given the predicted preference for all model pairs for a prompt, I used a Bradley-Terry model (the same ranking algorithm that LMSYS uses) to create a leaderboard for this prompt. I used the same scaling that LMSYS uses to make the scores look Elo-like. Here’s the ranking of the 9 models shown above for the query “Derive the elastic wave equation.”</p>

<p>This also means that with this preference predictor, we can create a leaderboard for any arbitrary subset of data. We can have a leaderboard specific to any domain.</p>

<table>
  <tr>
   <td colspan="2"><center><strong>Model ranking for the prompt</strong><em>"Derive the elastic wave equation."</em></center>
   </td>
  </tr>
  <tr>
   <td>gpt-4
   </td>
   <td>1214
   </td>
  </tr>
  <tr>
   <td>claude-v1
   </td>
   <td>1162
   </td>
  </tr>
  <tr>
   <td>gpt-3.5-turbo
   </td>
   <td>1104
   </td>
  </tr>
  <tr>
   <td>claude-instant-v1
   </td>
   <td>1110
   </td>
  </tr>
  <tr>
   <td>guanaco-33b
   </td>
   <td>1023
   </td>
  </tr>
  <tr>
   <td>vicuna-13b
   </td>
   <td>1007
   </td>
  </tr>
  <tr>
   <td>vicuna-7b
   </td>
   <td>985
   </td>
  </tr>
  <tr>
   <td>RWKV-4-Raven-14B
   </td>
   <td>970
   </td>
  </tr>
  <tr>
   <td>gpt4all-13b-snoozy
   </td>
   <td>915
   </td>
  </tr>
</table>
<p><br /></p>

<p>Despite being a toy predictor, the model seems to be able to capture different models’ performance patterns. One pattern is that for simple prompts, weak models can do (nearly) as well as strong models. For more challenging prompts, however, users are much more likely to prefer stronger models. Here’s a visualization of predicted human preference for an easy prompt (“hello, how are you?”) and a challenging prompt (“Explain why Planc length …”).</p>

<center>
    <figure>
    <img alt="Predictive human preference for all LLM model pairs" src="https://huyenchip.com/assets/pics/predictive-preference/8-easy-hard-prompts.png" style="float: center; margin: 0 0 0em 0em;" />
    </figure>
</center>
<p><br /></p>

<p>Here are the model rankings for these two prompts. The score spread for the simple prompt is much less than the score spread for the challenging prompt. The models that are ranked differently for these two prompts are highlighted in red.</p>

<center>
    <figure>
    <img alt="Predictive human preference for all LLM model pairs" src="https://huyenchip.com/assets/pics/predictive-preference/10-ranking.png" style="float: center; margin: 0 0 0em 0em;" />
    </figure>
</center>
<p><br /></p>

<p>The predictor is also the most confident that GPT-4 will be preferred for queries in Russian and queries that involve code writing. For example, the average predicted win rate for the following Russian query of GPT-4 against all other models is 91.55%. Notice that for this query, while claude-v1 is predicted to do well on this query, claude-instant-v1 is predicted to do poorly.</p>

<center>
    <figure>
    <img alt="Predictive human preference for all LLM model pairs" src="https://huyenchip.com/assets/pics/predictive-preference/9-russian.png" style="float: center; margin: 0 0 0em 0em;" />
    </figure>
</center>
<p><br /></p>

<h2 id="conclusion">Conclusion</h2>
<p>My primitive experiment suggests that predictive human preference is feasible using a surprisingly small amount of data. There are many potential use cases for predictive human preference – model routing and interpretability are just two of them.</p>

<p>Predictive human reference is the first and the most important step in model routing (the other key step is routing strategy). With more and more models being developed, each with different capabilities and a cost structure, model routing has clear economic values.</p>

<p>I’m aware of four groups (two in stealth) that are working on model routing. One startup is Martian, which announced its <a href="https://techcrunch.com/2023/11/15/martians-tool-automatically-switches-between-llms-to-reduce-costs/">$9M seed round</a>. LMSYS is also working on model routing, which I think is a natural progression from their work in comparative evaluation.</p>

<p>While my experiment used human-annotated comparisons, LMSYS folks told me that due to the noisiness of crowd-sourced annotations and the costs of expert annotations, they’ve found that using GPT-4 to compare two responses works better. Depending on the complexity of the queries, generating 10,000 comparisons using GPT-4 would cost only $200 - 500, making this very affordable for companies that want to test it out.</p>

<p>This is the most fun side project I’ve worked on in a while, so I’d love to talk more about it. For those interested, I’ll be hosting a casual 30-minute discussion on predictive human preference on Tuesday, Mar 5, 9.30am PST. Join our <a href="https://discord.gg/Bgxhua5XVR">Discord</a> or email me if you want an invite!</p>

<h2 id="acknowledgment">Acknowledgment</h2>

<p>Thanks <a href="https://twitter.com/luke_metz">Luke Metz</a> for helping me with the experiments and coercing me into using JAX. While JAX is super cool and makes a lot of things easy, it also caused some of the weirdest bugs I’ve ever seen. I’m glad I used it though. Thanks <a href="https://www.linkedin.com/in/hanchunglee/">Han-chung Lee</a> for feedback on the plots.</p>
]]></content:encoded>
<pubDate>Wed, 28 Feb 2024 00:00:00 +0000</pubDate>
</item>
<item>
<title>Sampling for Text Generation</title>
<link>https://huyenchip.com//2024/01/16/sampling.html</link>
<guid>https://huyenchip.com//2024/01/16/sampling.html</guid>
<content:encoded><![CDATA[
<div> 采样、温度、抽样策略、结构化输出、测试时间抽样

<br /><br />总结:
本文讨论了AI模型生成输出时的采样策略，包括温度调节、top-k抽样、top-p抽样等技术。通过调整这些参数，可以在保持模型创造性的同时控制输出的准确性和一致性。此外，还介绍了测试时间抽样的方法，以及如何生成符合特定格式的结构化输出。对于希望利用AI解决问题的人来说，理解模型输出的采样过程至关重要。 <div>
<p>ML models are probabilistic. Imagine that you want to know what’s the best cuisine in the world. If you ask someone this question twice, a minute apart, their answers both times should be the same. If you ask a model the same question twice, its answer can change. If the model thinks that Vietnamese cuisine has a 70% chance of being the best cuisine and Italian cuisine has a 30% chance, it’ll answer “Vietnamese” 70% of the time, and “Italian” 30%.</p>

<p>This probabilistic nature makes AI great for creative tasks. What is creativity but the ability to explore beyond the common possibilities, to think outside the box?</p>

<p>However, this probabilistic nature also causes inconsistency and hallucinations. It’s fatal for tasks that depend on factuality. Recently, I went over 3 months’ worth of customer support requests of an AI startup I advise and found that ⅕ of the questions are because users don’t understand or don’t know how to work with this probabilistic nature.</p>

<p>To understand why AI’s responses are probabilistic, we need to understand how models generate responses, a process known as sampling (or decoding). This post consists of 3 parts.</p>

<ol>
  <li><strong>Sampling</strong>: sampling strategies and sampling variables including temperature, top-k, and top-p.</li>
  <li><strong>Test time sampling</strong>: sampling multiple outputs to help improve a model’s performance.</li>
  <li><strong>Structured outputs</strong>: how to get models to generate outputs in a certain format.</li>
</ol>

<hr />
<p><b>Table of contents</b><br /></p>

<p><a href="https://huyenchip.com/feed.xml#sampling">Sampling</a><br />
…. <a href="https://huyenchip.com/feed.xml#temperature">Temperature</a><br />
…. <a href="https://huyenchip.com/feed.xml#top_k">Top-k</a><br />
…. <a href="https://huyenchip.com/feed.xml#top_p">Top-p</a><br />
…. <a href="https://huyenchip.com/feed.xml#stopping_condition">Stopping condition</a><br />
<a href="https://huyenchip.com/feed.xml#test_time_sampling">Test Time Sampling</a><br />
<a href="https://huyenchip.com/feed.xml#structured_outputs">Structured Outputs</a><br />
…. <a href="https://huyenchip.com/feed.xml#how_to_generate_structured_outputs">How to generate structured outputs</a><br />
…. <a href="https://huyenchip.com/feed.xml#constraint_sampling">Constraint sampling</a><br /></p>

<hr />
<p><br /></p>

<h2 id="sampling">Sampling</h2>

<p>Given an input, a neural network produces an output by first computing the probabilities of all possible values. For a classifier, possible values are the available classes. For example, if a model is trained to classify whether an email is spam, there are only two possible values: spam and not spam. The model computes the probability of each of these two values, say being spam is 90% and not spam is 10%.</p>

<p>To generate the next token, a language model first computes the probability distribution over all tokens in the vocabulary.</p>

<center>
    <figure>
    <img alt="Sampling the next token based on token probabilities" src="https://huyenchip.com/assets/pics/sampling/1-sampling-tokens.png" style="float: center; margin: 0 0 0em 0em;" />
    </figure>
</center>
<p><br /></p>

<p>For the spam email classification task, it’s okay to output the value with the highest probability. If the email has a 90% chance of being spam, you classify the email as spam. However, for a language model, always picking the most likely token, <em>greedy sampling</em>, creates boring outputs. Imagine a model that, for whichever question you ask, always responds with the most common words.</p>

<p>Instead of always picking the next most likely token, we can sample the next token according to the probability distribution over all possible values. Given the context of <code class="language-plaintext highlighter-rouge">My favorite color is ...</code>, if <code class="language-plaintext highlighter-rouge">red</code> has a 30% chance of being the next token and <code class="language-plaintext highlighter-rouge">green</code> has a 50% chance, <code class="language-plaintext highlighter-rouge">red</code> will be picked 30% of the time, and “green” 50% of the time.</p>

<h3 id="temperature">Temperature</h3>

<p>One problem with sampling the next token according to the probability distribution is that the model can be less creative. In the previous example, common words for colors like <code class="language-plaintext highlighter-rouge">red</code>, <code class="language-plaintext highlighter-rouge">green</code>, <code class="language-plaintext highlighter-rouge">purple</code>, etc. have the highest probabilities. The language model’s answer ends up sounding like that of a five-year-old: <code class="language-plaintext highlighter-rouge">My favorite color is green.</code> Because <code class="language-plaintext highlighter-rouge">the</code> has a low probability, the model has a low chance of generating a creative sentence such as <code class="language-plaintext highlighter-rouge">My favorite color is the color of a still lake on a spring morning.</code></p>

<p>Temperature is a technique used to redistribute the probabilities of the possible values. Intuitively, it reduces the probabilities of common tokens, and as a result, increases the probabilities of rarer tokens. This enables models to create more creative responses.</p>

<p>To understand how temperature works, let’s take a step back to see how a model computes the probabilities. Given an input, a neural network processes this input and outputs a logit vector. Each logit corresponds to one possible. In the case of a language model, each logit corresponds to one token in the model’s vocabulary. The logit vector size is the size of the vocabulary.</p>

<center>
    <figure>
    <img alt="Sampling the next token based on token probabilities" src="https://huyenchip.com/assets/pics/sampling/2-logits.png" style="float: center; margin: 0 0 0em 0em;" />
    </figure>
</center>
<p><br /></p>

<p>While larger logits correspond to higher probabilities, the logits don’t represent the probabilities. Logits don’t sum up to one. Logits can even be negative, while probabilities have to be non-negative. To convert logits to probabilities, a softmax layer is often used. Let’s say the model has a vocabulary of N and the logit vector is \([x_1, x_2, ..., x_N]\). The probability for the \(i^{th}\) token, \(p_i\), is computed as follows:</p>

\[p_i = \text{softmax}(x_i) = \frac{e^{x_i}}{\sum_j e^{x_j}}\]

<p>Temperature is a constant used to adjust the logits before the softmax transformation. Logits are divided by temperature. For a given temperature of \(T\), the adjusted logit for the \(i^{th}\) token is \(\frac{x_i}{T}\). Softmax is then applied on this adjusted logit instead of on \(x_i\).</p>

<p>Let’s walk through a simple example to understand the effect of temperature on probabilities. Imagine that we have a model that has only two possible outputs: A and B. The logits computed from the last layer are <code class="language-plaintext highlighter-rouge">[1, 3]</code>. The logit for A is 1 and B is 3.</p>

<ul>
  <li>Without using temperature, equivalent to temperature = 1, the softmax probabilities are <code class="language-plaintext highlighter-rouge">[0.12, 0.88]</code>. The model picks B 88% of the time.</li>
  <li>With temperature = 0.5, the probabilities are <code class="language-plaintext highlighter-rouge">[0.02, 0.98]</code>. The model picks B 98% of the time.</li>
  <li>With temperature = 2, the probabilities are <code class="language-plaintext highlighter-rouge">[0.27, 0.73]</code>. The model picks B 73% of the time.</li>
</ul>

<p>The higher the temperature, the less likely the model is going to pick the most obvious value (the value with the highest logit), making the model’s outputs more creative but potentially less coherent. The lower the temperature, the more likely the model is going to pick the most obvious value, making the model’s out more consistent but potentially more boring.</p>

<p>The graph below shows the softmax probability for token B at different temperatures. As the temperature gets closer to 0, the probability that the model picks token B becomes closer to 1. In our example, for temperature below 0.1, the model almost always outputs B. Model providers typically limit temperature to be between 0 and 2. If you own your model, you can use any non-negative temperature. A temperature of 0.7 is often recommended for creative use cases, as it balances creativity and determinism, but you should experiment and find the temperature that works best for you.</p>

<center>
    <figure>
    <img alt="Sampling the next token based on token probabilities using temperature" src="https://huyenchip.com/assets/pics/sampling/3-temperature.png" style="float: center; margin: 0 0 0em 0em;" />
    </figure>
</center>
<p><br /></p>

<p>It’s common practice to set the temperature to 0 for the model’s outputs to be more consistent. Technically, temperature can never be 0 – logits can’t be divided by 0. In practice, when we set the temperature to 0, the model just picks the token with the value with the largest logit, e.g. performing an <code class="language-plaintext highlighter-rouge">argmax</code>, without doing the logit adjustment and softmax calculation.</p>

<p>A common debugging technique when working with an AI model is looking at the probabilities this model computes for given inputs. For example, if the probabilities look random, the model hasn’t learned much. OpenAI returns probabilities generated by their models as <em><a href="https://cookbook.openai.com/examples/using_logprobs">logprobs</a></em>. Logprobs, short for log probabilities, are probabilities in the log scale. Log scale is preferred when working with a neural network’s probabilities because it helps reduce the underflow problem. A language model can work with a vocabulary size of 100,000, which means the probabilities for many of the tokens can be too small to be represented by a machine. The small numbers might be rounded down to 0. Log scale helps reduce this problem.</p>

<center>
    <figure>
    <img alt="Sampling the next token based on token probabilities using logprobs" src="https://huyenchip.com/assets/pics/sampling/4-logprobs.png" style="float: center; margin: 0 0 0em 0em;" />
    </figure>
</center>
<p><br /></p>

<h3 id="top_k">Top-k</h3>

<p>Top-k is a sampling strategy to reduce the computation workload without sacrificing too much of the model’s response diversity. Recall that to compute the probability distribution over all possible values, a softmax layer is used. Softmax requires two passes over all possible values: one to perform the exponential sum \(\sum_j e^{x_j}\) and one to perform \(\frac{e^{x_i}}{\sum_j e^{x_j}}\) for each value. For a language model with a large vocabulary, this process is computationally expensive.</p>

<p>To avoid this problem, after the model has computed the logits, we pick the top k logits and perform softmax over these top k logits only. Depending on how diverse you want your application to be, k can be anywhere from 50 to 500, much smaller than a model’s vocabulary size. The model then samples from these top values. A smaller k value makes the text more predictable but less interesting, as the model is limited to a smaller set of likely words.</p>

<h3 id="top_p">Top-p</h3>

<p>In top-k sampling, the number of values considered is fixed to k. However, this number should change depending on the situation. For example, given the prompt <code class="language-plaintext highlighter-rouge">Do you like music? Answer with only yes or no.</code>, the number of values considered should be two: <code class="language-plaintext highlighter-rouge">yes</code> and <code class="language-plaintext highlighter-rouge">no</code>. Given the prompt <code class="language-plaintext highlighter-rouge">What's the meaning of life?</code>, the number of values considered should be much larger.</p>

<p>Top-p, also known as nucleus sampling, allows for a more dynamic selection of values to be sampled from. In top-p sampling, the model sums the probabilities of the most likely next values in descending order and stops when the sum reaches p. Only the values within this cumulative probability are considered. Common values for top-p (nucleus) sampling in language models typically range from 0.9 to 0.95. A top-p value of 0.9, for example, means that the model will consider the smallest set of values whose cumulative probability exceeds 90%.</p>

<p>Let’s say the probabilities of all tokens are as shown in the image below. If top_p = 90%, only <code class="language-plaintext highlighter-rouge">yes</code> and <code class="language-plaintext highlighter-rouge">maybe</code> will be considered, as their cumulative probability is greater than 90%. If top_p = 99%, then <code class="language-plaintext highlighter-rouge">yes</code>, <code class="language-plaintext highlighter-rouge">maybe</code>, and <code class="language-plaintext highlighter-rouge">no</code> are considered.</p>

<center>
    <figure>
    <img alt="Sampling the next token based on token probabilities with top-p" src="https://huyenchip.com/assets/pics/sampling/5-top-p.png" style="float: center; margin: 0 0 0em 0em;" />
    </figure>
</center>
<p><br /></p>

<p>Unlike top-k, top-p doesn’t necessarily reduce the softmax computation load. Its benefit is that because it focuses on only the set of most relevant values for each context, it allows outputs to be more contextually appropriate. In theory, there doesn’t seem to be a lot of benefits to top-p sampling. However, in practice, top-p has proven to work well, causing its popularity to rise.</p>

<h3 id="stopping_condition">Stopping condition</h3>

<p>An autoregressive language model generates sequences of tokens by generating one token after another. A long output sequence takes more time, costs more compute (money), and can sometimes be annoying to users. We might want to set a condition for the model to stop the sequence.</p>

<p>One easy method is to ask models to stop generating after a fixed number of tokens. The downside is that the output is likely to be cut off mid-sentence. Another method is to use stop tokens. For example, you can ask models to stop generating when it encounters “&lt;EOS&gt;”. Stopping conditions are helpful to keep the latency and cost down.</p>

<h2 id="test_time_sampling">Test Time Sampling</h2>

<p>One simple way to improve a model’s performance is to generate multiple outputs and select the best one. This approach is called <em>test time sampling</em> or <em>test time compute</em>. I find “test time compute” confusing, as it can be interpreted as the amount of compute needed to run tests.</p>

<p>You can either show users multiple outputs and let them choose the one that works best for them or devise a method to select the best one. If you want your model’s responses to be consistent, you want to keep all sampling variables fixed. However, if you want to generate multiple outputs and pick the best one, you don’t want to vary your sampling variables.</p>

<p>One selection method is to pick the output with the highest probability. A language model’s output is a sequence of tokens, each token has a probability computed by the model. The probability of an output is the product of the probabilities of all tokens in the output.</p>

<p>Consider the sequence of tokens [<code class="language-plaintext highlighter-rouge">I</code>, <code class="language-plaintext highlighter-rouge">love</code>, <code class="language-plaintext highlighter-rouge">food</code>] and:</p>

<ul>
  <li>the probability for <code class="language-plaintext highlighter-rouge">I</code> is 0.2</li>
  <li>the probability for <code class="language-plaintext highlighter-rouge">love</code> given <code class="language-plaintext highlighter-rouge">I</code> is 0.1</li>
  <li>the probability for <code class="language-plaintext highlighter-rouge">food</code> given <code class="language-plaintext highlighter-rouge">I</code> and <code class="language-plaintext highlighter-rouge">love</code> is 0.3</li>
</ul>

<p>The sequence’s probability is then: 0.2 * 0.1 * 0.3 = 0.006.</p>

<p>Mathematically, this can be denoted as follows:</p>

\[p(\text{I love food}) = p(\text{I}) \times p(\text{love}|\text{I}) \times p(\text{food}|\text{I, love})\]

<p>Remember that it’s easier to work with probabilities on a log scale. The logarithm of a product is equal to a sum of logarithms, so the logprob of a sequence of tokens is the sum of the logprob of all tokens in the sequence.</p>

\[\text{logprob}(\text{I love food}) = \text{logprob}(\text{I}) + \text{logprob}(\text{love}|\text{I}) + \text{logprob}(\text{food}|\text{I, love})\]

<p>With summing, longer sequences are likely to have to lower total logprob (log(1) = 0, and log of all positive values less than 1 is negative). To avoid biasing towards short sequences, we use the average logprob by dividing the sum by its sequence length. After sampling multiple outputs, we pick the one with the highest average logprob. As of writing, this is what OpenAI API uses. You can set the parameter <em><a href="https://platform.openai.com/docs/api-reference/completions/create#completions-create-best_of">best_of</a></em> to a specific value, say 10, to ask OpenAI models to return the output with the highest average logprob out of 10 different outputs.</p>

<p>Another method is to use a reward model to score each output, as discussed in the previous section. Recall that both <a href="https://multithreaded.stitchfix.com/blog/2023/03/06/expert-in-the-loop-generative-ai-at-stitch-fix/">Stitch Fix</a> and <a href="https://engineering.grab.com/llm-powered-data-classification">Grab</a> pick the outputs given high scores by their reward models or verifiers. OpenAI also trained verifiers to help their models pick the best solutions to math problems (<a href="https://arxiv.org/pdf/2110.14168.pdf">Cobbe et al., 2021</a>). They found that sampling more outputs led to better performance, but only up to a certain point. In their experiment, this point is 400 outputs. Beyond this point, performance starts to decrease, as shown below. They hypothesized that as the number of sampled outputs increases, the chance of finding adversarial outputs that can fool the verifiers also increases. While this is an interesting experiment, I don’t believe anyone in production samples 400 different outputs for each input. The cost would be astronomical.</p>

<center>
    <figure>
    <img alt="Sampling the next token based on token probabilities" src="https://huyenchip.com/assets/pics/sampling/6-test-time-sampling.png" style="float: center; margin: 0 0 0em 0em;" />
    </figure>
</center>
<p><br /></p>

<p>You can also choose heuristics based on the needs of your application. For example, if your application benefits from shorter responses, you can pick the shortest one. If your application is to convert from natural language to SQL queries, you can pick the valid SQL query that is the most efficient.</p>

<p>Sampling multiple outputs can be useful for tasks that expect exact answers. For example, given a math problem, the model can solve it multiple times and pick the most frequent answer as its final solution. Similarly, for a multiple-choice question, a model can pick the most frequently output option. This is what Google did when <a href="https://storage.googleapis.com/deepmind-media/gemini/gemini_1_report.pdf">evaluating their model Gemini on MMLU</a>, a benchmark of multiple-choice questions. They sampled 32 outputs for each question. While this helped Gemini achieve a high score on this benchmark, it’s unclear whether their model is better than another model that gets a lower score by only generating one output for each question.</p>

<p>The more fickle a model is, the more we can benefit from sampling multiple outputs. The optimal thing to do with a fickle model, however, is to swap it out for another. For one project, we used AI to extract certain information from an image of the product. We found that for the same image, our model could read the information only half of the time. For the other half, the model said that the image was too blurry or the text was too small to read. For each image, we queried the model at most three times, until it could extract the information.</p>

<p>While we can usually expect some model performance improvement by sampling multiple outputs, it’s expensive. On average, generating two outputs costs approximately twice as much as generating one.</p>

<h2 id="structured_outputs">Structured Outputs</h2>

<p>Oftentimes, in production, we need models to generate text following certain formats. Having structured outputs is essential for the following two scenarios.</p>

<ol>
  <li>Tasks whose outputs need to follow certain grammar. For example, for text-to-SQL or text-to-regex, outputs have to be valid SQL queries and regexes. For classification, outputs have to be valid classes.</li>
  <li>Tasks whose outputs are then parsed by downstream applications. For example, if you use an AI model to write product descriptions, you want to extract only the product descriptions without buffer texts like “<em>Here’s the description</em>” or “<em>As a language model, I can’t …</em>”. Ideally, for this scenario, models should generate structured outputs, such as JSON with specific keys, that can be parseable.</li>
</ol>

<p>OpenAI was the first model provider to introduce <em><a href="https://platform.openai.com/docs/guides/text-generation/json-mode">JSON mode</a></em> in their text generation API. Note that their JSON mode guarantees only that the outputs are valid JSON, not what’s inside the JSON.  As of writing, OpenAI’s JSON mode doesn’t yet work for vision models, but I’m sure it’ll just be a matter of time.</p>

<p>The generated JSONs can also be truncated due to the model’s stopping condition, such as when it reaches the maximum output token length. If the max token length is set too short, the output JSONs can be truncated and hence not parseable. If it’s set too long, the model’s responses become both too slow and expensive.</p>

<p>Independent tools like <a href="https://github.com/guidance-ai/guidance">guidance</a> and <a href="https://github.com/outlines-dev/outlines">outlines</a> let you structure the outputs of certain models. Here are two examples of using guidance to generate outputs constrained to a set of options and a regex.</p>

<center>
    <figure>
    <img alt="Sampling structured outputs" src="https://huyenchip.com/assets/pics/sampling/7-guidance.png" style="float: center; margin: 0 0 0em 0em;" />
    </figure>
</center>
<p><br /></p>

<h3 id="how_to_generate_structured_outputs">How to generate structured outputs</h3>

<p>You can guide a model to generate constrained outputs at different layers of the AI stack: during prompting, sampling, and finetuning. Prompting is currently the easiest but least effective method. You can instruct a model to output valid JSON following a specific schema. However, there’s no guarantee that the model will always follow this instruction.</p>

<p>Finetuning is currently the go-to approach to get models to generate outputs in the style and format that you want. You can do finetuning with or without changing the model’s architecture. For example, you can finetune a model on examples with the output format you want. While this still doesn’t guarantee the model will always output the expected format, this is much more reliable than prompting. It also has the added benefit of reducing inference costs, assuming that you no longer have to include instructions and examples of the desirable format in your prompt.</p>

<p>For certain tasks, you can guarantee the output format with finetuning by modifying the model’s architecture. For example, for classification, you can append a classifier head to the foundation model’s architecture to make sure that the model only outputs one of the pre-specified classes. During finetuing, you can retrain the entire architecture or only this classifier head.</p>

<center>
    <figure>
    <img alt="Sampling the next token based on token probabilities" src="https://huyenchip.com/assets/pics/sampling/8-finetuning-classifier.png" style="float: center; margin: 0 0 0em 0em;" />
    </figure>
</center>
<p><br /></p>

<p>Both sampling and finetuning techniques are needed because of the assumption that the model, by itself, isn’t capable of doing it. As models become more powerful, we can expect them to get better at following instructions. I suspect that in the future, it’ll be easier to get models to output exactly what we need with minimal prompting, and these techniques will become less important.</p>

<h3 id="constraint_sampling">Constraint sampling</h3>

<p>Constraint sampling is a technique used to guide the generation of text towards certain constraints. The simplest but expensive way to do so is to keep on generating outputs until you find one that fits your constraints, as discussed in the section Test Time Sampling.</p>

<p>Constraint sampling can also be done during token sampling. I wasn’t able to find a lot of literature on how companies today are doing it. What’s written below is from my understanding, which can be wrong, so feedback and pointers are welcome!</p>

<p>At a high level, to generate a token, the model samples among values that meet the constraints. Recall that to generate a token, your model first outputs a logit vector, each logit corresponds to one possible value. With constrained sampling, we filter this logit vector to keep only the values that meet our constraints. Then we sample from these valid values.</p>

<center>
    <figure>
    <img alt="Sampling the next token based on token probabilities" src="https://huyenchip.com/assets/pics/sampling/9-constrained-sampling.png" style="float: center; margin: 0 0 0em 0em;" />
    </figure>
</center>
<p><br /></p>

<p>In the above example, the constraint is straightforward to filter for. However, in most cases, it’s not that straightforward. We need to have a grammar that specifies what is and isn’t allowed at each step. For example, JSON grammar dictates that after <code class="language-plaintext highlighter-rouge">{</code>, we can’t have another <code class="language-plaintext highlighter-rouge">{</code> unless it’s part of a string, as in <code class="language-plaintext highlighter-rouge">{"key": ""}</code>.</p>

<p>Building out that grammar and incorporating that grammar into the sampling process is non-trivial. We’d need a separate grammar for every output format we want: JSON, regex, CSV, etc. Some are against constrained sampling because they believe the resources needed for constrained sampling are better invested in training models to become better at following instructions.</p>

<h2 id="conclusion">Conclusion</h2>

<p>I believe understanding how an AI model samples its outputs is essential for anyone who wishes to leverage AI to solve their problems. Probability is magical but can also be confusing. Writing this post has been a lot of fun as it gave me a chance to dig deeper into many concepts that I’ve been curious about for a long time.</p>

<p>As always, feedback is much appreciated. Thanks <a href="https://leehanchung.github.io/">Han Lee</a> and <a href="https://twitter.com/luke_metz">Luke Metz</a> for graciously agreeing to be my first readers.</p>
]]></content:encoded>
<pubDate>Tue, 16 Jan 2024 00:00:00 +0000</pubDate>
</item>
<item>
<title>Multimodality and Large Multimodal Models (LMMs)</title>
<link>https://huyenchip.com//2023/10/10/multimodal.html</link>
<guid>https://huyenchip.com//2023/10/10/multimodal.html</guid>
<content:encoded><![CDATA[
<div> CLIP, Flamingo, Multimodal, 数据模态,图像文本编码<br />
<br />要点1: 为何需要多模态系统，多模态数据的重要性和应用领域
要点2: 不同数据模态的表达形式，以及数据模态之间的转换
要点3: 多模态任务包括生成和视觉-语言理解两类任务
要点4: CLIP模型的架构和训练方法，以及其应用领域
要点5: Flamingo模型的架构，包括视觉编码器和语言模型部分，以及训练方式<br /><br />总结: 本文介绍了多模态系统的重要性和发展现状，分析了CLIP和Flamingo两个模型的架构和训练方法。未来的研究方向包括整合更多数据模态、多模态输出生成以及提高多模态训练效率等方面。 <div>
<p>For a long time, each ML model operated in one data mode – text (translation, language modeling), image (object detection, image classification), or audio (speech recognition).</p>

<p>However, natural intelligence is not limited to just a single modality. Humans can read, talk, and see. We listen to music to relax and watch out for strange noises to detect danger. Being able to work with multimodal data is essential for us or any AI to operate in the real world.</p>

<p>OpenAI noted in their <a href="https://cdn.openai.com/papers/GPTV_System_Card.pdf">GPT-4V system card</a> that “<em>incorporating additional modalities (such as image inputs) into LLMs is viewed by some as a key frontier in AI research and development</em>.”</p>

<p>Incorporating additional modalities to LLMs (Large Language Models) creates LMMs (Large Multimodal Models). Not all multimodal systems are LMMs. For example, text-to-image models like Midjourney, Stable Diffusion, and Dall-E are multimodal but don’t have a language model component. Multimodal can mean one or more of the following:</p>

<ol>
  <li>Input and output are of different modalities (e.g. text-to-image, image-to-text)</li>
  <li>Inputs are multimodal (e.g. a system that can process both text and images)</li>
  <li>Outputs are multimodal (e.g. a system that can generate both text and images)</li>
</ol>

<p>This post covers multimodal systems in general, including LMMs. It consists of 3 parts.</p>

<ul>
  <li>Part 1 covers the context for multimodality, including why multimodal, different data modalities, and types of multimodal tasks.</li>
  <li>Part 2 discusses the fundamentals of a multimodal system, using the examples of CLIP, which lays the foundation for many future multimodal systems, and Flamingo, whose impressive performance gave rise to LMMs.</li>
  <li>Part 3 discusses some active research areas for LMMs, including generating multimodal outputs and adapters for more efficient multimodal training, covering newer multimodal systems such as BLIP-2, LLaVA, LLaMA-Adapter V2, LAVIN, etc.</li>
</ul>

<p>The post is long. Feel free to skip to the sections most interesting to you.</p>

<p><b>⚠ Ambiguous terminology ⚠</b><br />
Multimodal data can also refer to multimodal distributions, e.g. bimodal distribution, which is different from multimodal data in this post.
<br /><br /></p>

<hr />
<p><b>Table of contents</b><br />
<a href="https://huyenchip.com/feed.xml#part_1_understanding_multimodal">Part 1. Understanding Multimodal</a><br />
…. <a href="https://huyenchip.com/feed.xml#why_multimodal">Why multimodal</a><br />
…. <a href="https://huyenchip.com/feed.xml#data_modalities">Data modalities</a><br />
…. <a href="https://huyenchip.com/feed.xml#multimodal_tasks">Multimodal tasks</a><br />
…….. <a href="https://huyenchip.com/feed.xml#generation">Generation</a><br />
…….. <a href="https://huyenchip.com/feed.xml#vision_language_understanding">Vision-language understanding</a><br />
<a href="https://huyenchip.com/feed.xml#part_2_multimodal_training">Part 2. Fundamentals of Multimodal Training</a><br />
…. <a href="https://huyenchip.com/feed.xml#clip">CLIP: Contrastive Language-Image Pre-training</a><br />
…….. <a href="https://huyenchip.com/feed.xml#clip_s_high_level_architecture">CLIP’s high-level architecture</a><br />
…….. <a href="https://huyenchip.com/feed.xml#natural_language_supervision">Natural language supervision</a><br />
…….. <a href="https://huyenchip.com/feed.xml#contrastive_learning">Contrastive learning</a><br />
…….. <a href="https://huyenchip.com/feed.xml#clip_applications">CLIP applications</a><br />
…. <a href="https://huyenchip.com/feed.xml#flamingo">Flamingo: the dawns of LMMs</a><br />
…….. <a href="https://huyenchip.com/feed.xml#flamingo_s_high_level_architecture">Flamingo’s high-level architecture</a><br />
…….. <a href="https://huyenchip.com/feed.xml#data">Data</a><br />
…….. <a href="https://huyenchip.com/feed.xml#flamingo_s_vision_encoder">Flamingo’s vision encoder</a><br />
…….. <a href="https://huyenchip.com/feed.xml#flamingo_s_language_model">Flamingo’s language model</a><br />
…. <a href="https://huyenchip.com/feed.xml#clip_vs_flamingo">TL;DR: CLIP vs. Flamingo</a><br />
<a href="https://huyenchip.com/feed.xml#part_3_research_directions_for_lmms">Part 3. Research Directions for LMMs</a><br />
…. <a href="https://huyenchip.com/feed.xml#incorporating_more_data_modalities">Incorporating more data modalities</a><br />
…. <a href="https://huyenchip.com/feed.xml#multimodal_systems_for_instruction_following">Multimodal systems for instruction-following</a><br />
…. <a href="https://huyenchip.com/feed.xml#adapters_for_more_efficient_multimodal_training">Adapters for more efficient multimodal training</a><br />
…. <a href="https://huyenchip.com/feed.xml#generating_multimodal_outputs">Generating multimodal outputs</a><br />
<a href="https://huyenchip.com/feed.xml#conclusion">Conclusion</a><br />
<a href="https://huyenchip.com/feed.xml#resources">Resources</a><br /></p>

<hr />
<p><br /></p>

<h2 id="part_1_understanding_multimodal">Part 1. Understanding Multimodal</h2>

<h2 id="why_multimodal">Why multimodal</h2>

<p>Many use cases are impossible without multimodality, especially those in industries that deal with a mixture of data modalities such as healthcare, robotics, e-commerce, retail, gaming, etc.</p>

<center>
    <figure>
    <img alt="Multimodal AI in healthcare" src="https://huyenchip.com/assets/pics/multimodal/26-healthcare.png" style="float: center; margin: 0 0 0em 0em;" />
    </figure>
    An example of how multimodality can be used in healthcare. Image from Multimodal biomedical AI (Acosta et al., Nature Medicine 2022)
</center>
<p><br /></p>

<p>Not only that, incorporating data from other modalities can help boost model performance. Shouldn’t a model that can learn from both text and images perform better than a model that can learn from only text or only image?</p>

<p>Multimodal systems can provide a more flexible interface, allowing you to interact with them in whichever way works best for you at the moment. Imagine you can ask a question by typing, talking, or just pointing your camera at something.</p>

<p>One use case that I’m especially excited about, is that multimodality can also enable visually impaired people to browse the Internet and also navigate the real world.</p>

<center>
    <figure>
    <img alt="Some cool multimodal use cases from GPT-4V" src="https://huyenchip.com/assets/pics/multimodal/1-gpt-4v-use-cases.png" style="float: center; margin: 0 0 0em 0em;" />
    </figure>
    Some cool multimodal use cases from GPT-4V
</center>
<p><br /></p>

<h2 id="data_modalities">Data modalities</h2>

<p>Different data modes are text, image, audio, tabular data, etc. One data mode can be represented or <em>approximated</em> in another data mode. For example:</p>

<ul>
  <li>Audio can be represented as images (mel spectrograms).</li>
  <li>Speech can be transcribed into text, though its text-only representation loses information such as volume, intonation, pauses, etc.</li>
  <li>An image can be represented as a vector, which, in turn, can be flattened and represented as a sequence of text tokens.</li>
  <li>A video is a sequence of images plus audio. ML models today mostly treat videos as sequences of images. This is a severe limitation, as sounds have proved to be just as important as visuals for videos. <a href="https://www.kantar.com/uki/inspiration/advertising-media/the-power-of-tiktok">88% of TikTok users shared that sound is essential for their TikTok experience</a>.</li>
  <li>A text can be represented as an image if you simply take a picture of it.</li>
  <li>A data table can be converted into a chart, which is an image.</li>
</ul>

<hr />
<p><b>How about other data modalities?<b><br /></b></b></p>

<p>All digital data formats can be represented using bitstrings (strings of 0 and 1) or bytestrings. A model that can effectively learn from bitstrings or bytestrings will be very powerful, and it can learn from any data mode.<br /></p>

<p>There are other data modalities we haven’t touched on, such as graphs and 3D assets. We also haven’t touched on the formats used to represent smell and touch (haptics).</p>

<hr />
<p><br />
In ML today, audio is still largely treated as a voice-based alternative to text. The most common use cases for audio are still speech recognition (speech-to-text) and speech synthesis (text-to-speech). Non-speech audio use cases, e.g. music generation, are still pretty niche. See the fake Drake &amp; Weeknd song and <a href="https://huggingface.co/spaces/facebook/MusicGen">MusicGen model on HuggingFace</a>.</p>

<p>Image is perhaps the most versatile format for model inputs, as it can be used to represent text, tabular data, audio, and to some extent, videos. There’s also so much more visual data than text data. We have phones/webcams that constantly take pictures and videos today.</p>

<p>Text is a much more powerful mode for model outputs. A model that can generate images can only be used for image generation, whereas a model that can generate text can be used for many tasks: summarization, translation, reasoning, question answering, etc.</p>

<p>For simplicity, we’ll focus on 2 modalities: images and text. The learnings can be somewhat generalized to other modalities.</p>

<h2 id="multimodal_tasks">Multimodal tasks</h2>
<p>To understand multimodal systems, it’s helpful to look at the tasks they are built to solve. In literature, I commonly see vision-language tasks divided into two groups: <strong>generation</strong> and <strong>vision-language understanding</strong> (VLU), which is the umbrella term for all tasks that don’t require generation. The line between these two groups is blurred, as being able to generate answers requires understanding too.</p>

<h3 id="generation">Generation</h3>

<p>For generative tasks, the output can be unimodal (e.g. text, image, 3D rendering) or multimodal. While unimodal outputs are common today, multimodal outputs are still shaping up. We’ll discuss multimodal outputs at the end of this post.</p>

<h4 id="image-generation-text-to-image-synthesis">Image generation (text-to-image synthesis)</h4>

<p>This category is straightforward. Examples: Dall-E, Stable Diffusion, and Midjourney.</p>

<h4 id="text-generation">Text generation</h4>

<p>A common text generation task is visual question answering. Instead of relying only on text for the context, you can give the model both text and images. Imagine you can point your camera to anything and ask questions like: “My car won’t start. What’s wrong with it?”, “How to make this dish?”, or “What is this meme about?”.</p>

<p>Another common use case is image captioning, which can be used as part of a text-based image retrieval system. An organization might have millions, if not billions, of images: product images, graphs, designs, team pictures, promotional materials, etc. AI can automatically generate captions and metadata for them, making it easier to find the exact images you want.</p>

<h3 id="vision_language_understanding">Vision-language understanding</h3>
<p>We’ll zoom into two task types: classification and text-based image retrieval (TBIR).</p>

<h4 id="classification">Classification</h4>

<p>Classification models can only generate outputs that belong to a pre-determined list of classes. This works when you only care about a fixed number of outcomes. For example, an OCR system only needs to predict if a visual is one of the known characters (e.g. a digit or a letter).</p>

<p><strong>Side note</strong>: An OCR system processes data at the character level. When used together with a system that can understand the broader context, it can improve use cases such as allowing you to “talk” to any textbook, contract, assembly instructions, etc.</p>

<center>
    <figure>
    <img alt="Document processing with GPT-4V" src="https://huyenchip.com/assets/pics/multimodal/2-gpt-4v-ocr.png" style="float: center; margin: 0 0 0em 0em;" />
    </figure>
    Document processing with GPT-4V. The model's mistake is highlighted in red.
</center>
<p><br /></p>

<p>One related task to classification is <strong>image-to-text retrieval</strong>: given an image and a pool of pre-defined texts, find the text that’s most likely to accompany the image. This can be helpful for product image search, i.e. retrieving product reviews from a picture.</p>

<h4 id="text-based-image-retrieval-image-search">Text-based image retrieval (image search)</h4>

<p>Image search matters not only for search engines but also for enterprises to be able to search through all their internal images and documents. Some people call text-based image retrieval “text-to-image retrieval”.</p>

<p>There are several approaches to text-based image retrieval. Two of them are:</p>

<ol>
  <li>Generate captions and metadata for each image, either manually or automatically (see image captioning in <strong>Text generation</strong>). Given a text query, find images whose captions/metadata are closest to this text query.</li>
  <li>Train a joint embedding space for both images and text. Given a text query, generate an embedding for this query, and find all images whose embeddings are closest to this embedding.</li>
</ol>

<p>The second approach is more flexible, and I believe will be more widely used. This approach requires having a strong joint embedding space for both vision and language, like the one that OpenAI’s <a href="https://arxiv.org/abs/2103.00020">CLIP</a> developed.</p>

<h2 id="part_2_multimodal_training">Part 2. Fundamentals of Multimodal Training</h2>

<p>Given the existence of so many amazing multimodal systems, a challenge of writing this post is choosing which systems to focus on. In the end, I decided to focus on two models: <a href="https://arxiv.org/abs/2103.00020">CLIP</a> (2021) and <a href="https://arxiv.org/abs/2204.14198">Flamingo</a> (2022) both for their significance as well as availability and clarity of public details.</p>

<ul>
  <li>CLIP was the first model that could generalize to multiple <strong>image classification tasks</strong> with zero- and few-shot learning.</li>
  <li>Flamingo wasn’t the first large multimodal model that could <strong>generate open-ended responses</strong> (<a href="https://arxiv.org/abs/2201.12086">Salesforce’s BLIP</a> came out 3 months prior). However, Flamingo’s strong performance prompted some to consider it <a href="https://arxiv.org/abs/2304.08485">the GPT-3 moment in the multimodal domain</a>.</li>
</ul>

<p>Even though these two models are older, many techniques they use are still relevant today. I hope they serve as the foundation to understanding newer models. The multimodal space is evolving repaidly, with many new ideas being developed. We’ll go over these newer models in <a href="https://huyenchip.com/feed.xml#part_3_research_directions_for_lmms">Part 3</a>.</p>

<p>At a high level, a multimodal system consists of the following components:</p>
<ol>
  <li>An <strong>encoder</strong> for each data modality to generate the embeddings for data of that modality.</li>
  <li>A way to <strong>align embeddings</strong> of different modalities into the same <strong>multimodal embedding space</strong>.</li>
  <li>[Generative models only] A <strong>language model to generate text responses</strong>. Since inputs can contain both text and visuals, new techniques need to be developed to allow the language model to condition its responses on not just text, but also visuals.</li>
</ol>

<p>Ideally, as many of these components should be pretrained and reusable as possible.</p>

<h2 id="clip">CLIP: Contrastive Language-Image Pre-training</h2>

<p>CLIP’s key contribution is its ability to map data of different modalities, text and images, into a shared embedding space. This shared multimodal embedding space makes text-to-image and image-to-text tasks so much easier.</p>

<p>Training this multimodal embedding space also produced a strong image encoder, which allows CLIP to achieve <strong>competitive zero-shot performance on many image classification tasks</strong>. This strong image encoder can be used for many other tasks: image generation, visual question answering, and text-based image retrieval. Flamingo and LLaVa use CLIP as their image encoder. DALL-E uses CLIP to rerank generated images. It’s unclear if GPT-4V uses CLIP.</p>

<center>
    <figure>
    <img alt="Zero-shot image classification with CLIP" src="https://huyenchip.com/assets/pics/multimodal/3-CLIP-image-classification.png" style="float: center; margin: 0 0 0em 0em;" />
    </figure>
    Zero-shot image classification with CLIP
</center>
<p><br /></p>

<p>CLIP leveraged <strong>natural language supervision</strong> and <strong>contrastive learning</strong>, which allowed CLIP to both scale up their data and make training more efficient. We’ll go over why/how these two techniques work.</p>

<h3 id="clip_s_high_level_architecture">CLIP's high-level architecture</h3>

<center>
    <figure>
    <img alt="Architecture of OpenAI's CLIP" src="https://huyenchip.com/assets/pics/multimodal/4-CLIP-architecture.png" style="float: center; margin: 0 0 0em 0em;" />
    </figure>
    CLIP's architecture. Both encoders and projection matrices are jointly trained together from scratch. The training goal is to maximize the similarity scores of the right (image, text) pairings while minimizing the similarity scores of the wrong pairings (contrastive learning). 
</center>
<p><br /></p>

<p>For the <strong>image encoder</strong>, the authors experimented with both ResNet and ViT. Their best-performing model is <code class="language-plaintext highlighter-rouge">ViT-L/14@336px</code>:</p>

<ul>
  <li>Large vision transformer (ViT-L)</li>
  <li>14 patches (each image is divided into 14x14 pixel patches/sub-images)</li>
  <li>on 336x336 pixel input</li>
</ul>

<p>For the <strong>text encoder</strong>, CLIP uses a Transformer model similar to <a href="https://openai.com/research/better-language-models">GPT-2</a> but smaller. Their base model has only 63M parameters with 8 attention heads. The authors found CLIP’s performance to be less sensitive to the capacity of the text encoder.</p>

<p>Embeddings generated by the image encoder and text encoder are projected into the same embedding space using two projection matrices \(W_v\) and \(W_l\).</p>

<ul>
  <li>Given an image embedding \(V_i\), the corresponding multimodal embedding is computed as: \(W_vV_i\).</li>
  <li>Given a text embedding \(L_i\), the corresponding multimodal embedding is computed as: \(W_lL_i\).</li>
</ul>

<p>When people say CLIP embeddings, they either refer to these multimodal embeddings or the embeddings generated by CLIP’s image encoder.</p>

<h3 id="natural_language_supervision">Natural language supervision</h3>

<p>For many years, image models were trained with manually annotated (image, text) datasets (e.g. ImageNet, MS COCO). This isn’t scalable. Manual annotation is time-consuming and expensive.</p>

<p>The CLIP paper noted that none of the then-available (image, text) datasets was big and high quality enough. They created their own dataset – 400M (image, text) pairs – as follows.</p>

<ol>
  <li>Construct a list of 500,000 queries. Queries are common words, bigrams, and titles of popular Wikipedia articles.</li>
  <li>Find images matching these queries (string and substring match). The paper mentioned this search did NOT happen on search engines but didn’t specify where. My theory is that since OpenAI already scraped the entire Internet for their GPT models, they probably just queried their internal database.</li>
  <li>Each image is paired with a text that co-occurs with it (e.g. captions, comments) instead of the query since queries are too short to be descriptive.</li>
</ol>

<p>Because some queries are more popular than others, to avoid data imbalance, they used at most 20K images for a query.</p>

<h3 id="contrastive_learning">Contrastive learning</h3>
<p>Pre-CLIP, most vision-language models were trained using a classifier or language model objectives. Contrastive objective is a clever technique that allows CLIP to scale and generalize to multiple tasks.</p>

<p>We’ll show why the constrastive objective works better for CLIP using an example task of image captioning: given an image, generate a text that describes it.</p>

<h4 id="classifier-objective">Classifier objective</h4>

<p>A classifier predicts the correct class among a predetermined list of classes. This works when the output space is finite. Previous models that work with (image, text) pair datasets all had this limitation. For example, models working with <a href="https://www.image-net.org/challenges/LSVRC/2012/">ILSVRC-2012</a> limited themselves to 1,000 classes, and <a href="https://arxiv.org/abs/1707.02968">JFT-300M</a> to 18,291 classes.</p>

<p>This objective limits not only the model’s capacity to output meaningful responses but also its capacity for zero-shot learning. Say, if the model was trained to predict among 10 classes, it won’t work for a task that has 100 classes.</p>

<h4 id="language-model-objective">Language model objective</h4>

<p>If a classifier outputs only one class for each input, a language model outputs a sequence of classes. Each generated class is called a token. Each token is from a predetermined list, the vocabulary, of the language model.</p>

<center>
    <figure>
    <img alt="Classifier vs. language model objectives" src="https://huyenchip.com/assets/pics/multimodal/5-classifier-vs-language-model-objectives.png" style="float: center; margin: 0 0 0em 0em;" />
    </figure>
    Classifier vs. language model objectives
</center>
<p><br /></p>

<h4 id="contrastive-objective">Contrastive objective</h4>

<p>While the language model objective allows for vastly more flexible outputs, CLIP authors noted this objective made the training difficult. They hypothesized that this is because the model tries to generate <em>exactly</em> the text accompanying each image, while many possible texts can accompany an image: alt-text, caption, comments, etc.</p>

<p>For example, in the <a href="https://arxiv.org/abs/1509.04942">Flickr30K dataset</a>, each image has 5 captions provided by human annotators, and the captions for the same image can be very different.</p>

<center>
    <figure>
    <img alt="Multiple captions for the same image" src="https://huyenchip.com/assets/pics/multimodal/6-multiple-captions.png" style="float: center; margin: 0 0 0em 0em;" />
    </figure>
</center>
<p><br /></p>

<p>Contrastive learning is to overcome this challenge. Instead of predicting the exact text of each image, CLIP was trained to predict whether a text is more likely to accompany an image than other texts.</p>

<p>For each batch of \(N\) (image, text) pairs, the model generates N text embeddings and N image embeddings.</p>

<ul>
  <li>Let \(V_1, V_2, ..., V_n\) be the embeddings for the \(N\) images.</li>
  <li>Let \(L_1, L_2, ..., L_n\) be the embeddings for the \(N\) texts.</li>
</ul>

<p>CLIP computes the cosine similarity scores of the \(N^2\) possible (\(V_i, L_j\)) pairings. The model is trained to maximize the similarity scores of the \(N\) correct pairings while minimizing the scores of the \(N^2 - N\) incorrect pairings. For CLIP, \(N = 32,768\).</p>

<center>
    <figure>
    <img alt="How CLIP works" src="https://huyenchip.com/assets/pics/multimodal/7-clip.png" style="float: center; margin: 0 0 0em 0em;" />
    </figure>
</center>
<p><br /></p>

<p>Another way to look at this is that each training batch of CLIP is two classification tasks.</p>

<ol>
  <li>
    <p>Each image can be paired with N possible texts, and the model tries to predict the correct one. This is the same setup as image-to-text retrieval.</p>

\[L_{\text{contrastive:txt2im}} = -\frac{1}{N}\sum_i^N\log(\frac{\exp(L_i^TV_i\beta)}{\sum_j^N\exp(L_i^TV_j\beta)})\]
  </li>
  <li>
    <p>Each text can be paired with N possible images, and the model tries to predict the correct image. This is the same setup as text-to-image retrieval.</p>

\[L_{\text{contrastive:im2txt}} = -\frac{1}{N}\sum_i^N\log(\frac{\exp(V_i^TL_i\beta)}{\sum_j^N\exp(V_i^TL_j\beta)})\]
  </li>
</ol>

<p>The sum of these two losses is minimized. 𝛽 is a trainable inverse temperature parameter.</p>

<p>This is what it all looks like in pseudocode.</p>

<center>
    <figure>
    <img alt="CLIP pseudocode" src="https://huyenchip.com/assets/pics/multimodal/8-clip-pseudocode.png" style="float: center; margin: 0 0 0em 0em;" />
    </figure>
</center>

<p>CLIP authors found that the contrastive objective provided a 12x improvement in efficiency compared to the language model objective baseline while producing higher-quality image embeddings.</p>

<center>
    <figure>
    <img alt="CLIP constrastive learning" src="https://huyenchip.com/assets/pics/multimodal/9-contrastive-learning-efficiency.png" style="float: center; margin: 0 0 0em 0em;" />
    </figure>
</center>

<h3 id="clip_applications">CLIP applications</h3>

<h4 id="classification-1">Classification</h4>

<p>Today, for many image classification tasks, CLIP is still a strong out-of-the-box baseline to be used as-is or fine-tuned.</p>

<center>
    <figure>
    <img alt="CLIP as a strong baseline for image classification" src="https://huyenchip.com/assets/pics/multimodal/10-clip-perf.png" style="float: center; margin: 0 0 0em 0em;" />
    </figure>
</center>

<h4 id="text-based-image-retrieval">Text-based image retrieval</h4>

<p>Since CLIP’s training process was conceptually similar to image-to-text retrieval and text-to-image retrieval, CLIP “<em>displays significant promise for widely-applicable tasks like image retrieval or search</em>.” However, “<em>on image retrieval, CLIP’s performance relative to the overall state of the art is noticeably lower.</em>”</p>

<p>There are attempts to use CLIP for image retrieval. For example, <a href="https://github.com/rom1504/clip-retrieval">clip-retrieval</a> package works as follows:</p>

<ol>
  <li>Generate CLIP embeddings for all your images and store them in a vector database.</li>
  <li>For each text query, generate a CLIP embedding for this text.</li>
  <li>Query in the vector database for all images whose embeddings are close to this text query embedding.</li>
</ol>

<h4 id="image-generation">Image generation</h4>

<p>CLIP’s joint image-text embeddings are useful for image generation. Given a text prompt, <a href="https://openai.com/research/dall-e">DALL-E</a> (2021) generates many different visuals and uses CLIP to rerank these visuals before showing the top visuals to users.</p>

<p>In 2022, OpenAI introduced <a href="https://openai.com/research/hierarchical-text-conditional-image-generation-with-clip-latents">unCLIP</a>, a text-to-image synthesis model conditioned on CLIP latents. It consists of two main components:</p>

<ol>
  <li>CLIP is trained and frozen. The pretrained CLIP model can generate embeddings for both text and images in the same embedding space.</li>
  <li>Two things happen at image generation:
    <ul>
      <li>Use CLIP to generate embedding for this text.</li>
      <li>Use a diffusion decoder to generate images conditioned on this embedding.</li>
    </ul>
  </li>
</ol>

<center>
    <figure>
    <img alt="unCLIP" src="https://huyenchip.com/assets/pics/multimodal/11-unCLIP.png" style="float: center; margin: 0 0 0em 0em;" />
    </figure>
</center>
<p><br /></p>

<h4 id="text-generation-visual-question-answering-captioning">Text generation: visual question answering, captioning</h4>

<p>CLIP authors did attempt to create a model for text generation. One version they experimented with is called LM RN50. Though this model could generate text responses, its performance was consistently around 10% below CLIP’s best-performing model on all the vision-language understanding tasks that CLIP was evaluated on.</p>

<p>While today CLIP isn’t used directly for text generation, its image encoder is often the backbone for LMMs that can generate texts.</p>

<h2 id="flamingo">Flamingo: the dawns of LMMs</h2>

<p>Unlike CLIP, Flamingo can generate text responses. In a reductive view, Flamingo is CLIP + a language model, with added techniques to make it possible for the language model to generate text tokens conditioned on both visual and text inputs.</p>

<center>
    <figure>
    <img alt="Conversations with Flamingo LMMs" src="https://huyenchip.com/assets/pics/multimodal/12-flamingo-chatbots.png" style="float: center; margin: 0 0 0em 0em;" />
    </figure>
    Flamingo can generate text responses conditioned on both text and images
</center>
<p><br /></p>

<h3 id="flamingo_s_high_level_architecture">Flamingo's high-level architecture</h3>

<p>At a high level, Flamingo consists of 2 parts:</p>

<ol>
  <li><strong>Vision encoder</strong>: a CLIP-like model is trained using contrastive learning. The text encoder of this model is then discarded. The vision encoder is frozen to be used in the main model.</li>
  <li><strong>Language model</strong>: Flamingo finetunes Chinchilla to generate text tokens, conditioned on visuals and text, using language model loss, with two additional components Perceiver Resampler and GATED XATTN-DENSE layers. We’ll discuss them later in this blog.</li>
</ol>

<center>
    <figure>
    <img alt="Flamingo high level architecture" src="https://huyenchip.com/assets/pics/multimodal/13-flamingo-architecture.png" style="float: center; margin: 0 0 0em 0em;" />
    </figure>
</center>
<p><br /></p>

<h3 id="data">Data</h3>

<p>Flamingo used 4 datasets: 2 (image, text) pair datasets, 1 (video, text) pair dataset, and 1 interleaved image and text dataset.</p>

<center>
    <figure>
    <img alt="Flamingo's 4 datasets" src="https://huyenchip.com/assets/pics/multimodal/14-flamingo-data.png" style="float: center; margin: 0 0 0em 0em;" />
    </figure>
</center>
<p><br /></p>

<table>
    
  <tr>
   <td><strong>Dataset</strong>
   </td>
   <td><strong>Type</strong>
   </td>
   <td><strong>Size</strong>
   </td>
   <td><strong>How</strong>
   </td>
   <td><strong>Training weight</strong>
   </td>
  </tr>
  <tr>
   <td>M3W
   </td>
   <td>Interleaved image and text dataset
   </td>
   <td>43M webpages
   </td>
   <td>For each webpage, they sample a random subsequence of 256 tokens and take up to the first 5 images included in the sampled sequence.
   </td>
   <td>1.0
   </td>
  </tr>
  <tr>
   <td>ALIGN
   </td>
   <td>(Image, text) pairs
   </td>
   <td>1.8B pairs
   </td>
   <td>Texts are alt-texts, averaging 12 tokens/text.
   </td>
   <td>0.2
   </td>
  </tr>
  <tr>
   <td>LTIP
   </td>
   <td>(Image, text) pairs
   </td>
   <td>312M pairs
   </td>
   <td>Texts are long descriptions, averaging 20.5 tokens/text.
   </td>
   <td>0.2
   </td>
  </tr>
  <tr>
   <td>VTP
   </td>
   <td>(Video, text) pairs
   </td>
   <td>27M short videos
   </td>
   <td>~22 seconds/video on average
   </td>
   <td>0.03
   </td>
  </tr>
</table>
<p><br /></p>

<h3 id="flamingo_s_vision_encoder">Flamingo's vision encoder</h3>

<p>Flamingo first trains a CLIP-like model from scratch using contrastive learning. This component only uses the 2 (image, text) pair datasets, ALIGN and LTIP, totaling 2.1M (image, text) pairs. This is 5x larger than the dataset CLIP was trained on.</p>

<ul>
  <li>For the text encoder, Flamingo uses BERT instead of GPT-2.</li>
  <li>For the vision encoder, Flamingo uses a NormalizerFree ResNet (NFNet) F6 model.</li>
  <li>Text and vision embeddings are meanpooled before being projected to the joint embedding space.</li>
</ul>

<h3 id="flamingo_s_language_model">Flamingo's language model</h3>

<p>Flamingo uses Chinchilla as their language model. More specifically, they freeze the 9 pretrained Chinchilla LM layers. A traditional language model predicts the next text token based on the preceding text tokens. Flamingo predicts the next text token based on both the preceding text and visual tokens.</p>

<center>
    <figure>
    <img alt="Flamingo's 4 datasets" src="https://huyenchip.com/assets/pics/multimodal/15-lmm-text-generation.png" style="float: center; margin: 0 0 0em 0em;" />
    </figure>
    Next token generation is conditioned on both text and visual tokens. Illustration taken from Chunyuan Li's CVPR 2023 tutorial: Large Multimodal Models.
</center>
<p><br /></p>

<p>To be able to generate text conditioned on both text and visual inputs, Flamingo relied on Perceiver Resampler and GATED XATTN-DENSE layers.</p>

<h4 id="perceiver-resampler">Perceiver Resampler</h4>

<p>As the visual inputs can be both images and videos, the vision encoder can produce a variable number of image or video features. Perceiver Resampler converts these variable features into a consistent 64 visual outputs.</p>

<p>Interestingly enough, while training the vision encoder, the resolution used was 288 x 288. However, at this phase, visual inputs are resized to 320 × 320. It’s been shown that <a href="https://arxiv.org/abs/1906.06423">a higher test-time resolution can lead to improved performance when using CNNs</a>.</p>

<center>
    <figure>
    <img alt="Flamingo's Perceiver Resampler" src="https://huyenchip.com/assets/pics/multimodal/16-flamingo-perceiver-resampler.png" style="float: center; margin: 0 0 0em 0em;" />
    </figure>
</center>
<p><br /></p>

<h4 id="gated-xattn-dense-layers">GATED XATTN-DENSE layers</h4>

<p>GATED XATTN-DENSE layers are inserted between existing and frozen LM layers to allow the language model to attend more efficiently to the visual tokens when generating text tokens. Without these layers, Flamingo authors noted a drop of 4.2% in the overall score.</p>

<center>
    <figure>
    <img alt="Flamingo's GATED ATTN-DENSE layers" src="https://huyenchip.com/assets/pics/multimodal/17-gated xattn-dense.png" style="float: center; margin: 0 0 0em 0em;" />
    </figure>
</center>
<p><br /></p>

<h4 id="loss-function">Loss function</h4>
<p>Flamingo computes the likelihood of text \(y\) conditioned on the interleaved images and videos \(x\).</p>

\[p(y|x) = \prod_{l=1}^N p(y_l|y_{&lt;l}, x_{\leq l})\]

<p>The training loss function was a weighted sum of expected negative log-likelihoods of generated text across all 4 datasets, with \(\lambda_m\) being the training weight of dataset \(m\).</p>

\[\sum_{m=1}^M \lambda_m E_{(x, y)\sim D_m} [ -\sum_{l=1}^L \log p(y|x)]\]

<h4 id="training">Training</h4>

<p>While the Chinchilla LM layers are finetuned and frozen, the additional components are trained from scratch, using all 4 Flamingo datasets, with different weights. <em>Finding the right per-dataset weights was key to performance.</em> The weight for each dataset is in the <strong>Training weight</strong> column in the dataset table above.</p>

<p>VTP’s weight is much smaller than other datasets (0.03 compared to 0.2 and 1), so its contribution to the training should be minimal. However, the authors noted that removing this dataset negatively affects performance on all video tasks.</p>

<p>While Flamingo isn’t open-sourced, there are many open-source replications of Flamingo.</p>

<ul>
  <li><a href="https://huggingface.co/spaces/HuggingFaceM4/idefics_playground">IDEFICS</a> (HuggingFace)</li>
  <li><a href="https://github.com/mlfoundations/open_flamingo/issues">mlfoundations/open_flamingo</a></li>
</ul>

<h2 id="clip_vs_flamingo">TL;DR: CLIP vs. Flamingo</h2>

<center>
    <figure>
    <img alt="Flamingo's 4 datasets" src="https://huyenchip.com/assets/pics/multimodal/18-clip-flamingo.png" style="float: center; margin: 0 0 0em 0em;" />
    </figure>
</center>
<p><br /></p>

<h2 id="part_3_research_directions_for_lmms">Part 3. Research Directions for LMMs</h2>

<p>CLIP is 3 years old and Flamingo is almost 2. While their architectures serve as a good foundation for us to understand how LMMs are built, there have been many new progresses in the space.</p>

<p>Here are a few directions that I’m excited about. This is far from an exhaustive list, both because this post has been long and because I’m still learning about the space too. If you have any pointers or suggestions, please let me know!</p>

<h2 id="incorporating_more_data_modalities">Incorporating more data modalities</h2>

<p>Today, most multimodal systems work with text and images. It’s only a matter of time before we need systems that can incorporate other modalities such as videos, music, and 3D. Wouldn’t it be amazing to have one shared embedding space for ALL data modalities?</p>

<p>Examples of works in this space:</p>
<ul>
  <li><a href="https://arxiv.org/abs/2212.05171">ULIP: Learning a Unified Representation of Language, Images, and Point Clouds for 3D Understanding</a> (Xue et al., Dec 2022)</li>
  <li><a href="https://browse.arxiv.org/abs/2305.05665">ImageBind: One Embedding Space To Bind Them All</a> (Girdhar et al., May 2023)</li>
  <li><a href="https://next-gpt.github.io/">NExT-GPT: Any-to-Any Multimodal Large Language Model</a> (Wu et al., Sep 2023)</li>
  <li>Jeff Dean’s ambitious <a href="https://blog.google/technology/ai/introducing-pathways-next-generation-ai-architecture/">Pathways</a> project (2021): its vision is to “<em>enable multimodal models that encompass vision, auditory, and language understanding simultaneously</em>.”</li>
</ul>

<center>
    <figure>
    <img alt="Imagebind" src="https://huyenchip.com/assets/pics/multimodal/19-imagebind.png" style="float: center; margin: 0 0 0em 0em;" />
    </figure>
</center>

<h2 id="multimodal_systems_for_instruction_following">Multimodal systems for instruction-following</h2>

<p>Flamingo was trained for completion, but not for dialogue or for following instructions. (If you’re not familiar with completion vs. dialogue, check out my post on <a href="https://huyenchip.com/2023/05/02/rlhf.html">RLHF</a>). Many people are working on building LMMs that can follow instructions and have conversations, such as:</p>

<ul>
  <li><a href="https://arxiv.org/abs/2212.10773">MultiInstruct: Improving Multi-Modal Zero-Shot Learning via Instruction Tuning</a> (Xu et al., Dec 2022)</li>
  <li><a href="https://arxiv.org/abs/2304.08485">LLaVA: Visual Instruction Tuning</a> (Liu et al., Apr 28, 2023)</li>
  <li><a href="https://arxiv.org/abs/2305.06500">InstructBLIP: Towards General-purpose Vision-Language Models with Instruction Tuning</a> (Salesforce, May 11, 2023)</li>
  <li>LaVIN: <a href="https://arxiv.org/abs/2305.15023">Cheap and Quick: Efficient Vision-Language Instruction Tuning for Large Language Models</a> (Luo et al., May 24, 2023)</li>
</ul>

<center>
    <figure>
    <img alt="LaVIN" src="https://huyenchip.com/assets/pics/multimodal/20-LaVIN.png" style="float: center; margin: 0 0 0em 0em;" />
    </figure>
    Examples of LaVIN's outputs compared to other LMMs, shown in LaVIN's paper
</center>
<p><br /></p>

<h2 id="adapters_for_more_efficient_multimodal_training">Adapters for more efficient multimodal training</h2>

<p>While Flamingo used 9 pretrained and frozen layers from Chinchilla, it had to pretrain its vision encoder, Perceiver Resampler, and GATED XATTN-DENSE layers from scratch. These train-from-scratch modules could be compute-intensive. Many works focus on more efficient ways to bootstrap multimodal systems using less training from scratch.</p>

<p>Some works are quite promising. BLIP-2, for example, outperformed Flamingo-80B by 8.7% on zero-shot VQA-v2 with 54x fewer trainable parameters.</p>

<p>Works in this space include:</p>
<ul>
  <li><a href="https://arxiv.org/abs/2301.12597">BLIP-2: Bootstrapping Language-Image Pre-training with Frozen Image Encoders and Large Language Models</a></li>
  <li>[LAVIN] <a href="https://arxiv.org/abs/2305.15023">Cheap and Quick: Efficient Vision-Language Instruction Tuning for Large Language Models</a></li>
  <li><a href="https://arxiv.org/abs/2304.15010">LLaMA-Adapter V2: Parameter-Efficient Visual Instruction Model</a></li>
</ul>

<p>The two images below are from Chunyuan Li’s <a href="https://datarelease.blob.core.windows.net/tutorial/vision_foundation_models_2023/slides/Chunyuan_cvpr2023_tutorial_lmm.pdf">Large Multimodal Models</a> tutorial at CVPR 2023, which is, btw, an excellent tutorial.</p>

<center>
    <figure>
    <img alt="Adapters for LMMs" src="https://huyenchip.com/assets/pics/multimodal/21-adapters-1.png" style="float: center; margin: 0 0 0em 0em;" />
    </figure>
</center>
<p><br /></p>

<center>
    <figure>
    <img alt="Adapters for LMMs" src="https://huyenchip.com/assets/pics/multimodal/22-adapters-2.png" style="float: center; margin: 0 0 0em 0em;" />
    </figure>
</center>
<p><br /></p>

<h2 id="generating_multimodal_outputs">Generating multimodal outputs</h2>

<p>While models that can process multimodal inputs are becoming the norm, multimodal output is still lagging. Many use cases require multimodal outputs. For example, if we ask ChatGPT to explain RLHF, an effective explanation might require graphs, equations, and even simple animations.</p>

<p>To generate multimodal outputs, a model would first need to generate a shared intermediate output. One key question is what the intermediate output would look like.</p>

<p>One option for intermediate output is text, which will then be used to generate/synthesize other actions.</p>

<p>For example, <a href="https://arxiv.org/abs/2201.07520">CM3</a> (Aghajanyan et al., 2022) outputs HTML markup which can be compiled into webpages that contain not only text but also formattings, links, and images. GPT-4V generates Latex code, which can then be reconstructed as data tables.</p>

<center>
    <figure>
    <img alt="CM3" src="https://huyenchip.com/assets/pics/multimodal/23-cm3.png" style="float: center; margin: 0 0 0em 0em;" />
    </figure>
    Sampled outputs from CM3
</center>
<p><br /></p>

<center>
    <figure>
    <img alt="GPT-4V generating LaTeX" src="https://huyenchip.com/assets/pics/multimodal/24-gpt-4v-latex.png" style="float: center; margin: 0 0 0em 0em;" />
    </figure>
    GPT-4V generates Latex code, which can then be reconstructed as a data table
</center>
<p><br /></p>

<p>Another option for intermediate output would be multimodal tokens. This is the option that <a href="https://www.linkedin.com/in/caiming-xiong-150a1417">Caiming Xiong</a>, whose team at Salesforce has done a lot of awesome work on multimodality, told me. Each token will have a tag to denote whether it’s a text token or an image token. Image tokens will then be input into an image model like Diffusion to generate images. Text tokens will then be input into a language model.</p>

<p><a href="https://arxiv.org/abs/2305.17216">Generating Images with Multimodal Language Models</a> (Koh et al., Jun 2023) is an awesome paper that shows how LMMs can generate and retrieve images together with generating texts. See below.</p>

<center>
    <figure>
    <img alt="LMMs generating text and images" src="https://huyenchip.com/assets/pics/multimodal/27-lmms-generating-images.png" style="float: center; margin: 0 0 0em 0em;" />
    </figure>
</center>
<p><br /></p>

<!-- <h2 id="bigger_evaluation_benchmarks_for_multimodal">Bigger evaluation benchmarks for multimodal</h2>

There have been a lot of complaints about the lack of standardized evaluation benchmarks. Compared to evaluation for standard LLMs, multimodal evaluation is even worse. 

[LLaVA](https://arxiv.org/abs/2304.08485) (Liu et al., 2023) was evaluated on 30 unseen images and 90 new language-image instructions. We need bigger evaluation benchmarks for multimodal!

<center>
    <figure>
    <img
        alt="LlaVA evaluation"
        src="/assets/pics/multimodal/25-eval.png"
        style="float: center; max-width: 90%; margin: 0 0 0em 0em">
    </figure>
</center>
<br>

I'm only aware of one work in this space -- [LAMM: Language-Assisted Multi-Modal Instruction-Tuning Dataset, Framework, and Benchmark](https://arxiv.org/abs/2306.06687) (Yin et al., 2023). I'd appreciate your pointers to similar works! -->

<h2 id="conclusion">Conclusion</h2>
<p>It’s been a lot of fun going over so many multimodal papers as well as talking to people doing awesome work and trying to summarize the key patterns in one blog post. There’s so much about multimodality that I’m sure there are many things that I’ve missed, but I hope that this post provides the core patterns that will help you develop multimodal systems and apply them to your work.</p>

<p>As you see in part 3 of this post, we’re still in the early days of multimodal systems (so early that a friend told me he’s not sure if the LMM abbreviation would catch on). Yes, in most of my conversations, there’s little doubt that multimodal systems in general, and LMMs in particular, will be even more impactful than large language models. However, keep in mind that LMMs do not make LLMs obsolete. As LMMs extend upon LLMs, the performance of an LMM relies on the performance of its base LLM. Many labs that work on multimodal systems work on LLMs in parallel.</p>

<h2 id="early-reviewers">Early reviewers</h2>

<p>I’d like to thank the amazing early reviewers who gave me plenty of pointers and suggestions to make this post better: <a href="https://www.linkedin.com/in/hanchunglee/">Han-chung Lee</a>, <a href="https://www.linkedin.com/in/samreiswig/">Sam Reiswig</a>, and <a href="https://twitter.com/Luke_Metz">Luke Metz</a>.</p>

<h2 id="resources">Resources</h2>

<h3 id="models">Models</h3>

<p>An incomplete list of multimodal systems by time to give you a sense of how fast the space is moving!</p>

<ul>
  <li><a href="https://arxiv.org/abs/1504.00325">Microsoft COCO Captions: Data Collection and Evaluation Server</a> (Apr 2015)</li>
  <li><a href="https://arxiv.org/abs/1505.00468">VQA: Visual Question Answering</a> (May 2015)</li>
  <li><a href="https://arxiv.org/abs/1904.01766">VideoBERT: A Joint Model for Video and Language Representation Learning</a> (Google, Apr 3, 2019)</li>
  <li><a href="https://arxiv.org/abs/1908.07490">LXMERT: Learning Cross-Modality Encoder Representations from Transformers</a> (UNC Chapel Hill, Aug 20, 2019)</li>
  <li><a href="https://arxiv.org/abs/2103.00020">[CLIP] Learning Transferable Visual Models From Natural Language Supervision</a> (OpenAI, 2021)</li>
  <li><a href="https://arxiv.org/abs/2102.02779">Unifying Vision-and-Language Tasks via Text Generation</a> (UNC Chapel Hill, May 2021)</li>
  <li><a href="https://arxiv.org/abs/2201.12086">BLIP: Bootstrapping Language-Image Pre-training for Unified Vision-Language Understanding and Generation</a> (Salesforce, Jan 28, 2022)</li>
  <li><a href="https://arxiv.org/abs/2204.14198">Flamingo: a Visual Language Model for Few-Shot Learning</a> (DeepMind, April 29, 2022)</li>
  <li><a href="https://arxiv.org/abs/2205.14100">GIT: A Generative Image-to-text Transformer for Vision and Language</a> (Microsoft, May 2, 2022)</li>
  <li><a href="https://arxiv.org/abs/2212.10773">MultiInstruct: Improving Multi-Modal Zero-Shot Learning via Instruction Tuning</a> (Xu et al., Dec 2022)</li>
  <li><a href="https://arxiv.org/abs/2301.12597">BLIP-2: Bootstrapping Language-Image Pre-training with Frozen Image Encoders and Large Language Models</a> (Salesforce, Jan 30, 2023)</li>
  <li><a href="https://arxiv.org/abs/2302.05738">Cross-Modal Fine-Tuning: Align then Refine</a> (Shen et al., Feb 11, 2023)</li>
  <li><a href="https://arxiv.org/abs/2302.14045">KOSMOS-1: Language Is Not All You Need: Aligning Perception with Language Models</a> (Microsoft, Feb 27, 2023)</li>
  <li><a href="https://arxiv.org/abs/2303.03378">PaLM-E: An Embodied Multimodal Language Model</a> (Google, Mar 10, 2023)</li>
  <li><a href="https://arxiv.org/abs/2303.16199">LLaMA-Adapter: Efficient Fine-tuning of Language Models with Zero-init Attention</a> (Zhang et al., Mar 28, 2023)</li>
  <li><a href="https://arxiv.org/abs/2304.14178">mPLUG-Owl: Modularization Empowers Large Language Models with Multimodality</a> (Ye et al., Apr 2, 2023)</li>
  <li><a href="https://arxiv.org/abs/2304.15010">LLaMA-Adapter V2: Parameter-Efficient Visual Instruction Model</a> (Gao et al., Apr 28, 2023)</li>
  <li><a href="https://arxiv.org/abs/2304.08485">LLaVA: Visual Instruction Tuning</a> (Liu et al., Apr 28, 2023)</li>
  <li><a href="https://arxiv.org/abs/2305.04160">X-LLM: Bootstrapping Advanced Large Language Models by Treating Multi-Modalities as Foreign Languages</a> (Chen et al., May 7, 2023)</li>
  <li><a href="https://arxiv.org/abs/2305.06500">InstructBLIP: Towards General-purpose Vision-Language Models with Instruction Tuning</a> (Salesforce, May 11, 2023)</li>
  <li><a href="https://arxiv.org/abs/2305.09617">Towards Expert-Level Medical Question Answering with Large Language Models</a> (Singhal et al., May 16, 2023)</li>
  <li><a href="https://arxiv.org/abs/2305.15023">Cheap and Quick: Efficient Vision-Language Instruction Tuning for Large Language Models</a> (Luo et al., May 24, 2023)</li>
  <li><a href="https://arxiv.org/abs/2306.15195">Shikra: Unleashing Multimodal LLM’s Referential Dialogue Magic</a> (SenseTime, Jun 3, 2023)</li>
  <li><a href="https://arxiv.org/abs/2306.09093">Macaw-LLM: Multi-Modal Language Modeling with Image, Audio, Video, and Text Integration</a> (Tencent, Jun 15, 2023)</li>
</ul>

<h3 id="other-resources">Other resources</h3>

<ul>
  <li>[CVPR2023 Tutorial Talk] <a href="https://www.youtube.com/watch?v=mkI7EPD1vp8">Large Multimodal Models: Towards Building and Surpassing Multimodal GPT-4</a>
    <ul>
      <li>Slides: <a href="https://datarelease.blob.core.windows.net/tutorial/vision_foundation_models_2023/slides/Chunyuan_cvpr2023_tutorial_lmm.pdf">Large Multimodal Models</a></li>
    </ul>
  </li>
  <li>[CMU course] <a href="https://cmu-multicomp-lab.github.io/mmml-course/fall2022/">11-777 MMML</a></li>
  <li>[Open source] <a href="https://github.com/salesforce/LAVIS">Salesforce’s LAVIS</a></li>
</ul>
]]></content:encoded>
<pubDate>Tue, 10 Oct 2023 00:00:00 +0000</pubDate>
</item>
<item>
<title>Open challenges in LLM research</title>
<link>https://huyenchip.com//2023/08/16/llm-research-open-challenges.html</link>
<guid>https://huyenchip.com//2023/08/16/llm-research-open-challenges.html</guid>
<content:encoded><![CDATA[
<div> LLM、hallucination、context learning、multimodality、new architecture
<br /><br />
总结：LLM研究的开放挑战包括减少和衡量hallucination、优化上下文长度和构建、整合其他数据模态、设计新的模型架构以及开发GPU替代方案。在这些研究方向中，特别关注减少hallucination、提高学习效率和改进聊天接口。同时，构建非英语语言的LLM以及利用人类偏好进行学习也是重要的领域。各个问题的解决需要技术、政策和用户体验等多方面的努力。 <div>
<p>[<em><a href="https://www.linkedin.com/posts/chiphuyen_llm-airesearch-generativeai-activity-7097619722363408385-s5Cp">LinkedIn discussion</a>, <a href="https://twitter.com/chipro/status/1691858084824838427">Twitter thread</a></em>]</p>

<p>Never before in my life had I seen so many smart people working on the same goal: making LLMs better. After talking to many people working in both industry and academia, I noticed the 10 major research directions that emerged. The first two directions, hallucinations and context learning, are probably the most talked about today. I’m the most excited about numbers 3 (multimodality), 5 (new architecture), and 6 (GPU alternatives).</p>

<hr />
<p><b>Open challenges in LLM research</b>
<br />
<br />
<a href="https://huyenchip.com/feed.xml#1_reduce_and_measure_hallucinations">1. Reduce and measure hallucinations</a><br />
 <a href="https://huyenchip.com/feed.xml#2_context_learning">2. Optimize context length and context construction</a><br />
 <a href="https://huyenchip.com/feed.xml#3_incorporate_other_data_modalities">3. Incorporate other data modalities</a><br />
 <a href="https://huyenchip.com/feed.xml#4_make_llms_faster_and_cheaper">4. Make LLMs faster and cheaper</a><br />
 <a href="https://huyenchip.com/feed.xml#5_design_a_new_model_architecture">5. Design a new model architecture</a><br />
 <a href="https://huyenchip.com/feed.xml#6_develop_gpu_alternatives">6. Develop GPU alternatives</a><br />
 <a href="https://huyenchip.com/feed.xml#7_make_agents_usable">7. Make agents usable</a><br />
 <a href="https://huyenchip.com/feed.xml#8_improve_learning_from_human_preference">8. Improve learning from human preference</a><br />
 <a href="https://huyenchip.com/feed.xml#9_improve_the_efficiency_of_the_chat_interface">9. Improve the efficiency of the chat interface</a><br />
 <a href="https://huyenchip.com/feed.xml#10_build_llms_for_non_english_languages">10. Build LLMs for non-English languages</a><br /></p>

<hr />

<p><br /></p>

<h2 id="1_reduce_and_measure_hallucinations">1. Reduce and measure hallucinations</h2>

<p><a href="https://huyenchip.com/2023/05/02/rlhf.html#rlhf_and_hallucination">Hallucination</a> is a heavily discussed topic already so I’ll be quick. Hallucination happens when an AI model makes stuff up. For many creative use cases, hallucination is a feature. However, for most other use cases, hallucination is a bug. I was at a panel on LLM with Dropbox, Langchain, Elastics, and Anthropic recently, and the #1 roadblock they see for companies to adopt LLMs in production is hallucination.</p>

<p>Mitigating hallucination and developing metrics to measure hallucination is a blossoming research topic, and I’ve seen many startups focus on this problem. There are also ad-hoc tips to reduce hallucination, such as adding more context to the prompt, chain-of-thought, self-consistency, or asking your model to be concise in its response.</p>

<p>To learn more about hallucination:</p>

<ul>
  <li><a href="https://arxiv.org/abs/2202.03629">Survey of Hallucination in Natural Language Generation</a> (Ji et al., 2022)</li>
  <li><a href="https://arxiv.org/abs/2305.13534">How Language Model Hallucinations Can Snowball</a> (Zhang et al., 2023)</li>
  <li><a href="https://arxiv.org/abs/2302.04023">A Multitask, Multilingual, Multimodal Evaluation of ChatGPT on Reasoning, Hallucination, and Interactivity</a> (Bang et al., 2023)</li>
  <li><a href="https://arxiv.org/abs/2212.10400">Contrastive Learning Reduces Hallucination in Conversations</a> (Sun et al., 2022)</li>
  <li><a href="https://arxiv.org/abs/2203.11171">Self-Consistency Improves Chain of Thought Reasoning in Language Models</a> (Wang et al., 2022)</li>
  <li><a href="https://arxiv.org/abs/2303.08896">SelfCheckGPT: Zero-Resource Black-Box Hallucination Detection for Generative Large Language Models</a> (​​Manakul et al., 2023)</li>
  <li>A simple example of fact-checking and hallucination by <a href="https://github.com/NVIDIA/NeMo-Guardrails/blob/main/examples/grounding_rail/README.md#grounding-fact-checking-and-hallucination">NVIDIA’s NeMo-Guardrails</a></li>
</ul>

<h2 id="2_context_learning">2. Optimize context length and context construction</h2>

<p>A vast majority of questions require context. For example, if we ask ChatGPT: “What’s the best Vietnamese restaurant?”, the context needed would be “where” because the best Vietnamese restaurant in Vietnam would be different from the best Vietnamese in the US.</p>

<p>According to this cool paper <a href="https://arxiv.org/pdf/2109.06157.pdf">SituatedQA</a> (Zhang &amp; Choi, 2021), a significant proportion of information-seeking questions have context-dependent answers, e.g. roughly 16.5% of the <a href="https://ai.google.com/research/NaturalQuestions">Natural Questions NQ-Open dataset</a>. Personally, I suspect that this percentage would be even higher for enterprise use cases. For example, say a company builds a chatbot for customer support, for this chatbot to answer any customer question about any product, the context needed might be that customer’s history or that product’s information.</p>

<p>Because the model “learns” from the context provided to it, this process is also called context learning.</p>

<center>
    <figure>
    <img alt="Context needed for a customer support query" src="https://huyenchip.com/assets/pics/llm-research/2-context.png" style="float: center; margin: 0 0 0em 0em;" />
    </figure>
</center>
<p><br /></p>

<p>Context length is especially important for RAG – <a href="https://arxiv.org/abs/2005.11401">Retrieval Augmented Generation</a> (Lewis et al., 2020) – which has emerged to be the predominant pattern for LLM industry use cases. For those not yet swept away in the RAG rage, RAG works in two phases:</p>

<p>Phase 1: chunking (also known as indexing)</p>

<ol>
  <li>Gather all the documents you want your LLM to use</li>
  <li>Divide these documents into chunks that can be fed into your LLM to generate embeddings and store these embeddings in a vector database.</li>
</ol>

<p>Phase 2: querying</p>

<ol>
  <li>When user sends a query, like “<em>Does my insurance policy pay for this drug X</em>”, your LLM converts this query into an embedding, let’s call it QUERY_EMBEDDING</li>
  <li>Your vector database fetches the chunks whose embeddings are the most similar to QUERY_EMBEDDING</li>
</ol>

<p>Screenshot from <a href="https://www.youtube.com/watch?v=njzB6fm0U8g">Jerry Liu’s talk on LlamaIndex</a> (2023)</p>
<center>
    <figure>
    <img alt="Context needed for a customer support query" src="https://huyenchip.com/assets/pics/llm-research/2-rag.jpg" style="float: center; margin: 0 0 0em 0em;" />
    </figure>
</center>
<p><br /></p>

<p>The longer the context length, the more chunks we can squeeze into the context. The more information the model has access to, the better its response will be, right?</p>

<p>Not always. How much context a model can use and how efficiently that model will use it are two different questions. In parallel with the effort to increase model context length is the effort to make the context more efficient. Some people call it “prompt engineering” or “prompt construction”. For example, a paper that has made the rounds recently is about how models are much better at understanding information at the beginning and the end of the index rather than in the middle of it – <a href="https://arxiv.org/abs/2307.03172">Lost in the Middle: How Language Models Use Long Contexts</a> (Liu et al., 2023).</p>

<h2 id="3_incorporate_other_data_modalities">3. Incorporate other data modalities</h2>

<p>Multimodality, IMO, is so powerful and yet so underrated. There are many reasons for multimodality.</p>

<p>First, there are many use cases where multimodal data is required, especially in industries that deal with a mixture of data modalities such as healthcare, robotics, e-commerce, retail, gaming, entertainment, etc. Examples:</p>

<ul>
  <li>Oftentimes, medical predictions require both text (e.g. doctor’s notes, patients’ questionnaires) and images (e.g. CT, X-ray, MRI scans).</li>
  <li>Product metadata often contains images, videos, descriptions, and even tabular data (e.g. production date, weight, color). You might want to automatically fill in missing product information based on users’ reviews or product photos. You might want to enable users to search for products using visual information, like shape or color.</li>
</ul>

<p>Second, multimodality promises a big boost in model performance. Shouldn’t a model that can understand both text and images perform better than a model that can only understand text? Text-based models require so much text that there’s a realistic concern that <a href="https://huyenchip.com/2023/05/02/rlhf.html#data_bottleneck_for_pretraining">we’ll soon run out of Internet data to train text-based models</a>. Once we run out of text, we’d need to leverage other data modalities.</p>

<center>
    <figure>
    <img alt="Multimodal Flamingo's architecture" src="https://huyenchip.com/assets/pics/llm-research/3-flamingo.png" style="float: center; margin: 0 0 0em 0em;" />
    </figure>
    Flamingo architecture (Alayrac et al., 2022)
</center>
<p><br /></p>

<p>One use case I’m especially excited about is that multimodality can enable visually impaired people to browse the Internet and navigate the real world.</p>

<p>Cool multimodal work:</p>

<ul>
  <li><a href="https://arxiv.org/abs/2103.00020">[CLIP] Learning Transferable Visual Models From Natural Language Supervision</a> (OpenAI, 2021)</li>
  <li><a href="https://arxiv.org/abs/2204.14198">Flamingo: a Visual Language Model for Few-Shot Learning</a> (DeepMind, 2022)</li>
  <li><a href="https://arxiv.org/abs/2301.12597">BLIP-2: Bootstrapping Language-Image Pre-training with Frozen Image Encoders and Large Language Models</a> (Salesforce, 2023)</li>
  <li><a href="https://arxiv.org/abs/2302.14045">KOSMOS-1: Language Is Not All You Need: Aligning Perception with Language Models</a> (Microsoft, 2023)</li>
  <li><a href="https://ai.googleblog.com/2023/03/palm-e-embodied-multimodal-language.html">PaLM-E: An embodied multimodal language model</a> (Google, 2023)</li>
  <li><a href="https://arxiv.org/abs/2304.08485">LLaVA: Visual Instruction Tuning</a> (Liu et al., 2023)</li>
  <li><a href="https://catalog.ngc.nvidia.com/orgs/nvidia/teams/playground/models/neva">NeVA: NeMo Vision and Language Assistant</a> (NVIDIA, 2023)</li>
</ul>

<p>I’ve been working on a post on multimodality that hopefully I can share soon!</p>

<h2 id="4_make_llms_faster_and_cheaper">4. Make LLMs faster and cheaper</h2>

<p>When GPT-3.5 first came out in late November 2022, many people had concerns about latency and cost of using it in production. However, latency/cost analysis has changed rapidly since then. Within half a year, the community found a way to create a model that came pretty close to GPT-3.5 in terms of performance, yet required just under 2% of GPT-3.5’s memory footprint.</p>

<p>My takeaway: if you create something good enough, people will figure out a way to make it fast and cheap.</p>

<table>

  <tr>
   <td><strong>Date</strong>
   </td>
   <td><strong>Model</strong>
   </td>
   <td><strong># params</strong>
   </td>
   <td><strong>Quantization</strong>
   </td>
   <td><strong>Memory to finetune</strong>
   </td>
   <td><strong>Can be trained on</strong>
   </td>
  </tr>
  <tr>
   <td>Nov 2022
   </td>
   <td>GPT-3.5
   </td>
   <td>175B
   </td>
   <td>16-bit
   </td>
   <td>375GB
   </td>
   <td>Many, many machines
   </td>
  </tr>
  <tr>
   <td>Mar 2023
   </td>
   <td><a href="https://crfm.stanford.edu/2023/03/13/alpaca.html">Alpaca 7B</a>
   </td>
   <td>7B
   </td>
   <td>16-bit
   </td>
   <td>15GB
   </td>
   <td>Gaming desktop
   </td>
  </tr>
  <tr>
   <td>May 2023
   </td>
   <td><a href="https://arxiv.org/abs/2305.14314">Guanaco 7B</a>
   </td>
   <td>7B
   </td>
   <td>4-bit
   </td>
   <td>6GB
   </td>
   <td>Any Macbook
   </td>
  </tr>
</table>
<p><br /></p>

<p>Below is Guanaco 7B’s performance compared to ChatGPT GPT-3.5 and GPT-4, as reported in the Guanco paper. Caveat: in general, the performance comparison is far from perfect. LLM evaluation is very, very hard.</p>

<center>
    <figure>
    <img alt="Guanaco 7B's performance compared to ChatGPT GPT-3.5 and GPT-4" src="https://huyenchip.com/assets/pics/llm-research/4-llm-optimization.png" style="float: center; margin: 0 0 0em 0em;" />
    </figure>
</center>
<p><br /></p>

<p>Four years ago, when I started working on the notes that would later become the section <strong><a href="https://learning.oreilly.com/library/view/designing-machine-learning/9781098107956/ch07.html#model_compression">Model Compression</a></strong> for the book <a href="https://www.amazon.com/Designing-Machine-Learning-Systems-Production-Ready/dp/1098107969"><strong>Designing Machine Learning Systems</strong></a>, I wrote about four major techniques for model optimization/compression:</p>

<ol>
  <li><strong>Quantization</strong>: by far the most general model optimization method. Quantization reduces a model’s size by using fewer bits to represent its parameters, e.g. instead of using 32 bits to represent a float, use only 16 bits, or even 4 bits.</li>
  <li><strong>Knowledge distillation</strong>: a method in which a small model (student) is trained to mimic a larger model or ensemble of models (teacher).</li>
  <li><strong>Low-rank factorization</strong>: the key idea here is to replace high-dimensional tensors with lower-dimensional tensors to reduce the number of parameters. For example, you can decompose a 3x3 tensor into the product of a 3x1 and a 1x3 tensor, so that instead of having 9 parameters, you have only 6 parameters.</li>
  <li><strong>Pruning</strong></li>
</ol>

<p>All these four techniques are still relevant and popular today. Alpaca was trained using knowledge distillation. QLoRA used a combination of low-rank factorization and quantization.</p>

<h2 id="5_design_a_new_model_architecture">5. Design a new model architecture</h2>

<p>Since AlexNet in 2012, we’ve seen many architectures go in and out of fashion, including LSTM, seq2seq. Compared to those, Transformer is incredibly sticky. It’s been around since 2017. It’s a big question mark how much longer this architecture will be in vogue.</p>

<p>Developing a new architecture to outperform Transformer isn’t easy. Transformer has been so heavily optimized over the last 6 years. This new architecture has to be performing at the scale that people care about today, on the hardware that people care about. Side note: <a href="https://timdettmers.com/2018/10/17/tpus-vs-gpus-for-transformers-bert/">Transformer was originally designed by Google to run fast on TPUs</a>, and only later optimized on GPUs.</p>

<p>There was a lot of excitement in 2021 around S4 from Chris Ré’s lab – see <a href="https://arxiv.org/abs/2111.00396">Efficiently Modeling Long Sequences with Structured State Spaces</a> (Gu et al., 2021). I’m not quite sure what happened to it. Chris Ré’s lab is still very invested in developing new architecture, most recently with their architecture <a href="https://together.ai/blog/monarch-mixer">Monarch Mixer</a> (Fu et al., 2023) in collaboration with the startup <a href="https://together.ai/blog/monarch-mixer">Together</a>.</p>

<p>Their key idea is that for the existing Transformer architecture, the complexity of attention is quadratic in sequence length and the complexity of an MLP is quadratic in model dimension. An architecture with subquadratic complexity would be more efficient.</p>

<center>
    <figure>
    <img alt="Monarch Mixer architecture" src="https://huyenchip.com/assets/pics/llm-research/5-monarch-mixer.png" style="float: center; margin: 0 0 0em 0em;" />
    </figure>
</center>
<p><br /></p>

<p>I’m sure many other labs are working on this idea, though I’m not aware of any attempt that has been made public. If you know of any, please let me know!</p>

<h2 id="6_develop_gpu_alternatives">6. Develop GPU alternatives</h2>

<p>GPU has been the dominating hardware for deep learning ever since AlexNet in 2012. In fact, one commonly acknowledged reason for AlexNet’s popularity is that it was the first paper to successfully use GPUs to train neural networks. Before GPUs, if you wanted to train a model at AlexNet’s scale, you’d have to use thousands of CPUs, like the one <a href="https://www.nytimes.com/2012/06/26/technology/in-a-big-network-of-computers-evidence-of-machine-learning.html">Google released just a few months before AlexNet</a>. Compared to thousands of CPUs, a couple of GPUs were a lot more accessible to Ph.D. students and researchers, setting off the deep learning research boom.</p>

<p>In the last decade, many, many companies, both big corporations, and startups, have attempted to create new hardware for AI. The most notable attempts are Google’s <a href="https://cloud.google.com/tpu/docs/intro-to-tpu">TPUs</a>, Graphcore’s <a href="https://www.graphcore.ai/products/ipu">IPUs</a> (what’s happening with IPUs?), and <a href="https://www.eetimes.com/cerebras-sells-100-million-ai-supercomputer-plans-8-more/">Cerebras</a>. SambaNova raised over <a href="https://spectrum.ieee.org/sambanova-ceo-ai-interview">a billion dollars to develop new AI chips</a> but seems to have pivoted to being a generative AI platform.</p>

<p>For a while, there has been a lot of anticipation around quantum computing, with key players being:</p>

<ul>
  <li><a href="https://www.ibm.com/quantum">IBM’s QPU</a></li>
  <li>Google’s Quantum computer reported <a href="https://www.nature.com/articles/d41586-023-00536-w">a major milestone in quantum error reduction</a> earlier this year in Nature. Its quantum virtual machine is publicly accessible via <a href="https://quantumai.google/quantum-virtual-machine">Google Colab</a></li>
  <li>Research labs such as <a href="https://cqe.mit.edu/">MIT Center for Quantum Engineering</a>, <a href="https://www.mpq.mpg.de/en">Max Planck Institute of Quantum Optics</a>, <a href="https://chicagoquantum.org/">Chicago Quantum Exchange</a>, <a href="https://quantum-roadmap.ornl.gov/">Oak Ridge National Laboratory</a>, etc.</li>
</ul>

<p>Another direction that is also super exciting is photonic chips. This is the direciton I know the least about – so please correct me if I’m wrong. Existing chips today use electricity to move data, which consumes a lot of power and also incurs latency. Photonic chips use photons to move data, harnessing the speed of light for faster and more efficient compute. Various startups in this space have raised hundreds of millions of dollars, including <a href="https://lightmatter.co/">Lightmatter</a> ($270M), <a href="https://ayarlabs.com/">Ayar Labs</a> ($220M), <a href="https://www.lightelligence.ai/">Lightelligence</a> ($200M+), and <a href="https://www.luminous.com/">Luminous Computing</a> ($115M).</p>

<p>Below is the timeline of advances of the three major methods in photonic matrix computation, from the paper <a href="https://www.nature.com/articles/s41377-022-00717-8">Photonic matrix multiplication lights up photonic accelerator and beyond</a> (Zhou et al., Nature 2022). The three different methods are plane light conversion (PLC), Mach–Zehnder interferometer (MZI), and wavelength division multiplexing (WDM).</p>

<center>
    <figure>
    <img alt="Timeline of advances of the three major methods in photonic matrix multiplication" src="https://huyenchip.com/assets/pics/llm-research/6-photonic-matrix-multiplication.png" style="float: center; margin: 0 0 0em 0em;" />
    </figure>
</center>
<p><br /></p>

<h2 id="7_make_agents_usable">7. Make agents usable</h2>

<p>Agents are LLMs that can take actions, like browsing the Internet, sending emails, making reservations, etc. Compared to other research directions in this post, this might be the youngest direction.</p>

<p>Because of the novelty and the massive potential, there’s a feverish obsession with agents. <a href="https://github.com/Significant-Gravitas/Auto-GPT">Auto-GPT</a> is now the 25th most popular GitHub repo ever by the number of stars. <a href="https://github.com/AntonOsika/gpt-engineer">GPT-Engineering</a> is another popular repo.</p>

<p>Despite the excitement, there is still doubt about whether LLMs are reliable and performant enough to be entrusted with the power to act.</p>

<p>One use case that has emerged though is the use of agents for social studies, like the famous Stanford experiment that shows that a small society of generative agents produces emergent social behaviors: <em>for example, starting with only a single user-specified notion that one agent wants to throw a Valentine’s Day party, the agents autonomously spread invitations to the party over the next two days, make new acquaintances, ask each other out on dates to the party …</em> (<a href="https://arxiv.org/abs/2304.03442">Generative Agents: Interactive Simulacra of Human Behavior</a>, Park et al., 2023)</p>

<p>The most notable startup in this area is perhaps Adept, founded by two Transformer co-authors (though <a href="https://www.theinformation.com/briefings/two-co-founders-of-adept-an-openai-rival-suddenly-left-to-start-another-company">both already left</a>) and an ex-OpenAI VP, and has raised almost half a billion dollars to date. Last year, they had a demo showing their agent browsing the Internet and adding a new account to Salesforce. I’m looking forward to seeing their new demos 🙂</p>

<center>


</center>
<p><br /></p>

<h2 id="8_improve_learning_from_human_preference">8. Improve learning from human preference</h2>

<p><a href="https://huyenchip.com/2023/05/02/rlhf.html">RLHF, Reinforcement Learning from Human Preference</a>, is cool but kinda hacky. I wouldn’t be surprised if people figure out a better way to train LLMs. There are many open questions for RLHF, such as:</p>

<p><strong>1. How to mathematically represent human preference?</strong></p>

<p>Currently, human preference is determined by comparison: human labeler determines if response A is better than response B. However, it doesn’t take into account how much better response A is than response B.</p>

<p><strong>2. What’s human preference?</strong></p>

<p>Anthropic measured the quality of their model’s responses along the three axes: helpful, honest, and harmless. See <a href="https://arxiv.org/abs/2212.08073">Constitutional AI: Harmlessness from AI Feedback</a> (Bai et al., 2022).</p>

<p>DeepMind tries to generate responses that please the most people. See <a href="https://www.deepmind.com/publications/fine-tuning-language-models-to-find-agreement-among-humans-with-diverse-preferences">Fine-tuning language models to find agreement among humans with diverse preferences</a>, (Bakker et al., 2022).</p>

<p>Also, do we want AIs that can take a stand or a vanilla AI that shies away from any potentially controversial topic?</p>

<p><strong>3. Whose preference is “human” preference, taking into account the differences in cultures, religions, political leanings, etc.?</strong></p>

<p>There are a lot of challenges in obtaining training data that can be sufficiently representative of all the potential users.</p>

<p>For example, for OpenAI’s InstructGPT data, there was no labeler above 65 years old. Labelers are predominantly Filipino and Bangladeshi. See <a href="https://arxiv.org/abs/2203.02155">InstructGPT: Training language models to follow instructions with human feedback</a> (Ouyang et al., 2022).</p>

<center>
    <figure>
    <img alt="Demographics of labelers for InstructGPT" src="https://huyenchip.com/assets/pics/llm-research/8-instructgpt-demographics.png" style="float: center; margin: 0 0 0em 0em;" />
    </figure>
</center>
<p><br /></p>

<p>Community-led efforts, while admirable in their intention, can lead to biased data. For example, for the OpenAssistant dataset, 201 out of 222 (90.5%) respondents identify as male. <a href="https://twitter.com/jeremyphoward/status/1647763133665271808/photo/1">Jeremy Howard has a great Twitter thread on this</a>.</p>

<center>
    <figure>
    <img alt="Self-reported demographics of contributors to OpenAssistant dataset" src="https://huyenchip.com/assets/pics/llm-research/8-openassistant-demographics.png" style="float: center; margin: 0 0 0em 0em;" />
    </figure>
</center>
<p><br /></p>

<h2 id="9_improve_the_efficiency_of_the_chat_interface">9. Improve the efficiency of the chat interface</h2>

<p>Ever since ChatGPT, there have been multiple discussions on whether chat is a suitable interface for a wide range of tasks.</p>

<ul>
  <li><a href="https://austinhenley.com/blog/naturallanguageui.html">Natural language is the lazy user interface</a> (Austin Z. Henley, 2023)</li>
  <li><a href="https://wattenberger.com/thoughts/boo-chatbots">Why Chatbots Are Not the Future</a> (Amelia Wattenberger, 2023)</li>
  <li><a href="https://arxiv.org/abs/2303.17710">What Types of Questions Require Conversation to Answer? A Case Study of AskReddit Questions</a> (Huang et al., 2023)</li>
  <li><a href="https://idratherbewriting.com/blog/ai-chat-interfaces-are-the-new-user-interface-for-docs">AI chat interfaces could become the primary user interface to read documentation</a> (Tom Johnson, 2023)</li>
  <li><a href="https://eugeneyan.com/writing/llm-ux/">Interacting with LLMs with Minimal Chat</a> (Eugene Yan, 2023)</li>
</ul>

<p>However, this is not a new discussion. In many countries, especially in Asia, chat has been used as the interface for super apps for about a decade. <a href="http://dangrover.com/blog/2014/12/01/chinese-mobile-app-ui-trends.html">Dan Grover had this discussion back in 2014</a>.</p>

<center>
    <figure>
    <img alt="Chat has been used as the universal interface for superapps in China for over a decade" src="https://huyenchip.com/assets/pics/llm-research/9-superapp-chat-interface.png" style="float: center; margin: 0 0 0em 0em;" />
    </figure>
    Chat as a universal interface for Chinese apps (Dan Grover, 2014)
</center>
<p><br /></p>

<p>The discussion again got tense in 2016, when many people thought apps were dead and chatbots would be the future.</p>

<ul>
  <li><a href="https://acroll.medium.com/on-chat-as-interface-92a68d2bf854">On chat as interface</a> (Alistair Croll, 2016)</li>
  <li><a href="https://www.technologyreview.com/2016/04/25/8510/is-the-chatbot-trend-one-big-misunderstanding/">Is the Chatbot Trend One Big Misunderstanding?</a> (Will Knight, 2016)</li>
  <li><a href="http://dangrover.com/blog/2016/04/20/bots-wont-replace-apps.html">Bots won’t replace apps. Better apps will replace apps</a> (Dan Grover, 2016)</li>
</ul>

<p>Personally, I love the chat interface because of the following reasons:</p>

<ol>
  <li>Chat is an interface that everyone, even people without previous exposure to computers or the Internet, can learn to use quickly. When I volunteered at a low-income residential neighborhood (are we allowed to say slum?) in Kenya in the early 2010s, I was blown away by how comfortable everyone there was with doing banking on their phone, via texts. No one in that neighborhood had a computer.</li>
  <li>Chat interface is accessible. You can use voice instead of text if your hands are busy.</li>
  <li>Chat is also an incredibly robust interface – you can give it any request and it’ll give back a response, even if the response isn’t good.</li>
</ol>

<p>However, there are certain areas that I think the chat interface can be improved upon.</p>

<ol>
  <li>
    <p>Multiple messages per turn</p>

    <p>Currently, we pretty much assume one message per turn. This is not how my friends and I text. Often, I need multiple messages to complete my thought, because I need to insert different data (e.g. images, locations, links), I forgot something in the previous messages, or I just don’t feel like putting everything into a massive paragraph.</p>
  </li>
  <li>
    <p>Multimodal input</p>

    <p>In the realm of multimodal applications, most energy is spent on building better models, and very little on building better interfaces. Take <a href="https://catalog.ngc.nvidia.com/orgs/nvidia/teams/playground/models/neva">Nvidia’s NeVA chatbot</a>. I’m not a UX expert, but I suspect there might be room for UX improvement here.</p>

    <p>P.S. Sorry the NeVA team for calling you out. Even with this interface, your work is super cool!</p>

    <center>
     <figure>
     <img alt="NVIDIA's NeVA interface" src="https://huyenchip.com/assets/pics/llm-research/9-neva.png" style="float: center; margin: 0 0 0em 0em;" />
     </figure>
 </center>
    <p><br /></p>
  </li>
  <li>
    <p>Incorporating generative AI into your workflows</p>

    <p>Linus Lee covered this point well in his talk <a href="https://www.youtube.com/watch?v=rd-J3hmycQs">Generative AI interface beyond chats</a>. For example, if you want to ask a question about a column of a chart you’re working on, you should be able just point to that column and ask a question.</p>
  </li>
  <li>
    <p>Editing and deletion of messages</p>

    <p>How would editing or deletion of a user input change the conversation flow with the chatbot?</p>
  </li>
</ol>

<h2 id="10_build_llms_for_non_english_languages">10. Build LLMs for non-English languages</h2>

<p>We know that current English-first LLMs don’t work well for many other languages, both in terms of performance, latency, and speed. See:</p>

<ul>
  <li><a href="https://arxiv.org/abs/2304.05613">ChatGPT Beyond English: Towards a Comprehensive Evaluation of Large Language Models in Multilingual Learning</a> (Lai et al., 2023)</li>
  <li><a href="https://blog.yenniejun.com/p/all-languages-are-not-created-tokenized">All languages are NOT created (tokenized) equal</a> (Yennie Jun, 2023)</li>
</ul>

<center>
    <figure>
    <img alt="Tokenization for non-English languages" src="https://huyenchip.com/assets/pics/llm-research/10-non-english-tokens.png" style="float: center; margin: 0 0 0em 0em;" />
    </figure>
</center>
<p><br /></p>

<p>Here are some initiatives that I’m aware of. If you have pointers to others, I’d be happy to include them here.</p>

<ul>
  <li><a href="https://aya.for.ai/">Aya</a>: An Open Science Initiative to Accelerate Multilingual AI Progress</li>
  <li><a href="https://discord.gg/a2PCzB4AdE">Symato</a>: Vietnamese ChatGPT</li>
  <li><a href="https://github.com/22-hours/cabrita">Cabrita</a>: Finetuning InstructLLaMA with portuguese data</li>
  <li><a href="https://github.com/LC1332/Luotuo-Chinese-LLM">Luotuo-Chinese-LLM</a></li>
  <li><a href="https://github.com/ymcui/Chinese-LLaMA-Alpaca">Chinese-LLaMA-Alpaca</a></li>
  <li><a href="https://github.com/Facico/Chinese-Vicuna">Chinese-Vicuna</a></li>
</ul>

<p>Several early readers of this post told me they don’t think I should include this direction for two reasons.</p>

<ol>
  <li>
    <p>This is less of a research problem and more of a logistics problem. We already know how to do it. Someone just needs to put money and effort into it. This is not entirely true. Most languages are considered low-resource, e.g. they have far fewer high-quality data compared to English or Chinese, and might require different techniques to train a large language model. See:</p>

    <ul>
      <li><a href="https://arxiv.org/abs/2006.07264">Low-resource Languages: A Review of Past Work and Future Challenges</a> (Magueresse et al., 2020)</li>
      <li><a href="https://aclanthology.org/P19-1310/">JW300: A Wide-Coverage Parallel Corpus for Low-Resource Languages</a> (Agić et al., 2019)</li>
    </ul>
  </li>
  <li>
    <p>Those more pessimistic think that in the future, many languages will die out, and the Internet will consist of two universes in two languages: English and Mandarin. This school of thought isn’t new – anyone remembers Esperando?</p>
  </li>
</ol>

<p>The impact of AI tools, e.g. machine translation and chatbots, on language learning is still unclear. Will they help people learn new languages faster, or will they eliminate the need of learning new languages altogether?</p>

<h2>Conclusion</h2>

<p>Phew, that was a lot of papers to reference, and I have no doubt that I still missed a ton. If there’s something you think I missed, please let me know.</p>

<p>For another perspective, check out this comprehsive paper <a href="https://arxiv.org/abs/2307.10169">Challenges and Applications of Large Language Models</a> (Kaddour et al., 2023).</p>

<p>Some of the problems mentioned above are harder than others. For example, I think that number 10, building LLMs for non-English languages, is more straightforward with enough time and resources.</p>

<p>Number 1, reducing hallucination, will be much harder, since hallucination is just LLMs doing their probabilistic thing.</p>

<p>Number 4, making LLMs faster and cheaper, will never be completely solved. There is already so much progress in this area, and there will be more, but we will never run out of room for improvement.</p>

<p>Number 5 and number 6, new architectures and new hardware, are very challenging, but they are inevitable with time. Because of the symbiosis between architecture and hardware – new architecture will need to be optimized for common hardware, and hardware will need to support common architecture – they might be solved by the same company.</p>

<p>Some of these problems won’t be solved using only technical knowledge. For example, number 8, improving learning from human preference, might be more of a policy problem than a technical problem. Number 9, improving the efficiency of the chat interface, is more of a UX problem. We need more people with non-technical backgrounds to work with us to solve these problems.</p>

<p>What research direction are you most excited about? What are the most promising solutions you see for these problems? I’d love to hear from you.</p>
]]></content:encoded>
<pubDate>Wed, 16 Aug 2023 00:00:00 +0000</pubDate>
</item>
<item>
<title>Generative AI Strategy</title>
<link>https://huyenchip.com//2023/06/07/generative-ai-strategy.html</link>
<guid>https://huyenchip.com//2023/06/07/generative-ai-strategy.html</guid>
<content:encoded><![CDATA[
<div> AI、leadership、generative、strategy、framework

领导力需要我们做生成式人工智能。在这个简单的框架中，探讨了如何处理生成式人工智能，并分享了许多仍在探讨中的想法。通过交流和反馈，不断完善这个想法。感谢所有对这个讲话提出建议和反馈的人。总结: 领导力需要我们采用生成式人工智能策略，但如何具体操作还在探索中，希望通过讨论和分享经验不断完善这个框架。 <div>
<p>I had a lot of fun preparing the talk: <em>“Leadership needs us to do generative AI. What do we do?”</em> for <a href="https://fullyconnected.com/">Fully Connected</a>. The idea for the talk came from many conversations I’ve had recently with friends who need to figure out their generative AI strategy, but aren’t sure what exactly to do.</p>

<p>This talk is a simple framework to explore what to do with generative AI. Many ideas are still being fleshed out. I hope to convert this into a proper post when I have more time. In the meantime, I’d love to hear from your experience through this process.</p>

<p><em>I couldn’t figure out how to make the slides centered on the page. You might want to <a href="https://huyenchip.com/assets/genai.pdf">download the slides</a>.</em></p>


<p><br /></p>

<p>Thanks everyone who responded to <a href="https://www.linkedin.com/feed/update/urn:li:activity:7072230577449439232/">my post</a> and shared your thoughts on what I should include in the talk. Thanks <a href="https://www.linkedin.com/in/kylegallatin/">Kyle Gallatin</a>, <a href="https://www.linkedin.com/in/goku/">Goku Mohandas</a>, <a href="https://www.linkedin.com/in/hanchunglee/">Han-chung Lee</a>, and <a href="https://www.linkedin.com/in/jamiedeguerre/">Jamie de Guerre</a> for thoughtful feedback on the talk.</p>
]]></content:encoded>
<pubDate>Wed, 07 Jun 2023 00:00:00 +0000</pubDate>
</item>
<item>
<title>RLHF: Reinforcement Learning from Human Feedback</title>
<link>https://huyenchip.com//2023/05/02/rlhf.html</link>
<guid>https://huyenchip.com//2023/05/02/rlhf.html</guid>
<content:encoded><![CDATA[
<div> ChatGPT, RLHF, Pretraining, Supervised Finetuning, Reward Model<br />
RLHF技术是如何帮助ChatGPT模型在自然语言处理领域取得成功的关键。该技术包括使用强化学习和人类反馈，对模型进行预训练、有监督微调及奖励模型训练三个阶段。预训练阶段旨在构建大型语言模型，微调阶段通过演示数据优化模型生成符合用户期望的回应，在RLHF阶段则通过奖励模型对回应进行评分并进一步优化模型生成高质量回应。RLHF技术能够提升模型性能，但也可能导致幻觉问题。通过对技术细节进行深入理解，可以更好地选择适合自身需求的语言模型。 <br /><br />总结: <div>
<p>[<em><a href="https://www.linkedin.com/posts/chiphuyen_llm-chatgpt-rlhf-activity-7059550685578608640-ap2Z/">LinkedIn discussion</a>, <a href="https://twitter.com/chipro/status/1653787366090510337">Twitter thread</a></em>]</p>

<p>In literature discussing why ChatGPT is able to capture so much of our imagination, I often come across two narratives:</p>

<ol>
  <li>Scale: throwing more data and compute at it.</li>
  <li>UX: moving from a prompt interface to a more natural chat interface.</li>
</ol>

<p>One narrative that is often glossed over is the incredible technical creativity that went into making models like ChatGPT work. One such cool idea is RLHF (Reinforcement Learning from Human Feedback): incorporating reinforcement learning and human feedback into NLP.</p>

<p>RL has been notoriously difficult to work with, and therefore, mostly confined to gaming and simulated environments like Atari or MuJoCo. Just five years ago, both RL and NLP were progressing pretty much orthogonally – different stacks, different techniques, and different experimentation setups. It’s impressive to see it work in a new domain at a massive scale.</p>

<p>So, how exactly does RLHF work? Why does it work? This post will discuss the answers to those questions.</p>

<hr />
<p><b>Table of contents</b><br />
<a href="https://huyenchip.com/feed.xml#rlhf_overview">RLHF overview</a><br />
<a href="https://huyenchip.com/feed.xml#phase_1_pretraining_for_completion">Phase 1. Pretraining for completion</a><br />
…. <a href="https://huyenchip.com/feed.xml#language_model">Language model</a><br />
…. <a href="https://huyenchip.com/feed.xml#mathematical_formulation_lm">Mathematical formulation</a><br />
…. <a href="https://huyenchip.com/feed.xml#data_bottleneck_for_pretraining">Data bottleneck for pretraining</a><br />
<a href="https://huyenchip.com/feed.xml#phase_2_sft">Phase 2. Supervised finetuning (SFT) for dialogue</a><br />
…. <a href="https://huyenchip.com/feed.xml#why_sft">Why SFT</a><br />
…. <a href="https://huyenchip.com/feed.xml#demonstration_data">Demonstration data</a><br />
…. <a href="https://huyenchip.com/feed.xml#mathematical_formulation_sft">Mathematical formulation</a><br />
<a href="https://huyenchip.com/feed.xml#phase_3_rlhf">Phase 3. RLHF</a><br />
…. <a href="https://huyenchip.com/feed.xml#3_1_reward_model">3.1. Reward model (RM)</a><br />
…….. <a href="https://huyenchip.com/feed.xml#mathematical_formulation_rm">Mathematical formulation</a><br />
…….. <a href="https://huyenchip.com/feed.xml#ui_to_collect_comparison_data">UI to collect comparison data</a><br />
…. <a href="https://huyenchip.com/feed.xml#3_2_finetuning_using_the_reward_model">3.2. Finetuning using the reward model</a><br />
…….. <a href="https://huyenchip.com/feed.xml#mathematical_formulation_rl">Mathematical formulation</a><br />
…. <a href="https://huyenchip.com/feed.xml#rlhf_and_hallucination">RLHF and hallucination</a><br />
<a href="https://huyenchip.com/feed.xml#conclusion">Conclusion</a><br /></p>

<hr />
<p><br />
To understand RLHF, we first need to understand the process of training a model like ChatGPT and where RLHF fits in, which is the focus of the first section of this post. The following 3 sections cover the 3 phases of ChatGPT development. For each phase, I’ll discuss the goal for that phase, the intuition for why this phase is needed, and the corresponding mathematical formulation for those who want to see more technical detail.</p>

<p>Currently, RLHF is not yet widely used in the industry except for a few big key players – OpenAI, DeepMind, and Anthropic. However, I’ve seen many work-in-progress efforts using RLHF, so I wouldn’t be surprised to see RLHF used more in the future.</p>

<p>In this post, I assume that readers don’t have specialized knowledge in NLP or RL. If you do, feel free to skip any section that is less relevant for you.</p>

<h2 id="rlhf_overview">RLHF overview</h2>

<p>Let’s visualize the development process for ChatGPT to see where RLHF fits in.</p>

<center>
    <figure>
    <img alt="3 phases of ChatGPT development" src="https://huyenchip.com/assets/pics/rlhf/1-chatgpt-training.png" style="float: center; margin: 0 0 0em 0em;" />
    </figure>
</center>
<p><br /></p>

<p>If you squint, this above diagram looks very similar to the meme Shoggoth with a smiley face.</p>

<ol>
  <li>The pretrained model is an untamed monster because it was trained on indiscriminate data scraped from the Internet: think clickbait, misinformation, propaganda, conspiracy theories, or attacks against certain demographics.</li>
  <li>This monster was then finetuned on higher quality data – think StackOverflow, Quora, or human annotations – which makes it somewhat socially acceptable.</li>
  <li>Then the finetuned model was further polished using RLHF to make it customer-appropriate, e.g. giving it a smiley face.</li>
</ol>

<center>
    <figure>
    <img alt="3 phases of ChatGPT development" src="https://huyenchip.com/assets/pics/rlhf/2-shoggoth.jpg" style="float: center; margin: 0 0 0em 0em;" />
    </figure>
    Shoggoth with Smiley Face. Courtesy of twitter.com/anthrupad
</center>
<p><br /></p>

<p>You can skip any of the three phases. For example, you can do RLHF directly on top of the pretrained model, without going through the SFT phase. However, empirically, combining all these three steps gives the best performance.</p>

<p>Pretraining is the most resource-intensive phase. For the InstructGPT model, pretraining takes up <a href="https://openai.com/research/instruction-following">98% of the overall compute and data resources</a>. You can think of SFT and RLHF as unlocking the capabilities that the pretrained model already has but are hard for users to access via prompting alone.</p>

<p>Teaching machines to learn from human preferences is not new. It’s been around for <a href="https://arxiv.org/abs/1208.0984">over a decade</a>. OpenAI started exploring <a href="https://openai.com/research/learning-from-human-preferences">learning from human preference</a> back when their main bet was robotics. The then narrative was that human preference was crucial for AI safety. However, as it turned out, human preference can also make for better products, which attracted a much larger audience.</p>

<p><strong>»»Side note: The abstract from OpenAI’s learning from human preference paper in 2017««</strong><br /></p>
<blockquote>
  <p><em>One step towards building safe AI systems is to remove the need for humans to write goal functions, since using a simple proxy for a complex goal, or getting the complex goal a bit wrong, can lead to undesirable and even dangerous behavior. In collaboration with DeepMind’s safety team, we’ve developed an algorithm which can infer what humans want by being told which of two proposed behaviors is better.</em></p>
</blockquote>

<h2 id="phase_1_pretraining_for_completion">Phase 1. Pretraining for completion</h2>

<p>The result of the pretraining phase is a large language model (LLM), often known as the pretrained model. Examples include GPT-x (OpenAI), Gopher (DeepMind), LLaMa (Meta), StableLM (Stability AI).</p>

<h3 id="language_model">Language model</h3>

<p>A language model encodes statistical information about language. For simplicity, statistical information tells us how likely something (e.g. a word, a character) is to appear in a given context. The term <strong>token</strong> can refer to a word, a character, or a part of a word (like <code class="language-plaintext highlighter-rouge">-tion</code>), depending on the language model. You can think of tokens as the <strong>vocabulary</strong> that a language model uses.</p>

<p>Fluent speakers of a language subconsciously have statistical knowledge of that language. For example, given the context <code class="language-plaintext highlighter-rouge">My favorite color is __</code>, if you speak English, you know that the word in the blank is much more likely to be <code class="language-plaintext highlighter-rouge">green</code> than <code class="language-plaintext highlighter-rouge">car</code>.</p>

<p>Similarly, language models should also be able to fill in that blank. You can think of a language model as a “<em>completion machine</em>”: given a text (prompt), it can generate a response to complete that text. Here’s an example:</p>

<ul>
  <li><strong>Prompt (from user)</strong>: <code class="language-plaintext highlighter-rouge">I tried so hard, and got so far</code></li>
  <li><strong>Completion (from language model)</strong>: <code class="language-plaintext highlighter-rouge">But in the end, it doesn't even matter.</code></li>
</ul>

<center>
    <figure>
    <img alt="3 phases of ChatGPT development" src="https://huyenchip.com/assets/pics/rlhf/3-complete.gif" style="float: center; margin: 0 0 0em 0em;" />
    </figure>
</center>
<p><br /></p>

<p>As simple as it sounds, completion turned out to be incredibly powerful, as many tasks can be framed as completion tasks: translation, summarization, writing code, doing math, etc. For example, give the prompt: <code class="language-plaintext highlighter-rouge">How are you in French is ...</code>, a language model might be able to complete it with: <code class="language-plaintext highlighter-rouge">Comment ça va</code>, effectively translating from one language to another.</p>

<p>To train a language model for completion, you feed it a lot of text so that it can distill statistical information from it. The text given to the model to learn from is called training data. Consider a language that contains only two tokens 0 and 1. If you feed a language model the following sequences as training data, the language model might distill that:</p>

<ul>
  <li>If the context is <code class="language-plaintext highlighter-rouge">01</code>, the next tokens are likely <code class="language-plaintext highlighter-rouge">01</code></li>
  <li>If the context is <code class="language-plaintext highlighter-rouge">0011</code>, the next tokens are likely <code class="language-plaintext highlighter-rouge">0011</code></li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0101
010101
01010101
0011
00110011
001100110011
</code></pre></div></div>

<p>Since language models mimic its training data, language models are only as good as their training data, hence the phrase “Garbage in, garbage out”. If you train a language model on Reddit comments, you might not want to take it home to show to your parents.</p>

<h3 id="mathematical_formulation_lm">Mathematical formulation</h3>

<ul>
  <li>ML task: language modeling</li>
  <li>Training data: low-quality data</li>
  <li>Data scale: usually in the order of trillions of tokens as of May 2023.
    <ul>
      <li><a href="https://arxiv.org/abs/2005.14165">GPT-3’s dataset</a> (OpenAI): 0.5 trillion tokens. I can’t find any public info for GPT-4, but I’d estimate it to use an order of magnitude more data than GPT-3.</li>
      <li><a href="https://www.deepmind.com/publications/scaling-language-models-methods-analysis-insights-from-training-gopher">Gopher’s dataset</a> (DeepMind): 1 trillion tokens</li>
      <li><a href="https://github.com/togethercomputer/RedPajama-Data">RedPajama</a> (Together): 1.2 trillion tokens</li>
      <li><a href="https://arxiv.org/abs/2302.13971">LLaMa’s dataset</a> (Meta): 1.4 trillion tokens</li>
    </ul>
  </li>
  <li>Model resulting from this process: LLM</li>
</ul>

<hr />
<hr />

<ul>
  <li>\(LLM_\phi\): the language model being trained, parameterized by \(\phi\). The goal is to find \(\phi\) for which the cross entropy loss is minimized.</li>
  <li>\([T_1, T_2, ..., T_V]\): vocabulary – the set of all unique tokens in the training data.</li>
  <li>\(V\): the vocabulary size.</li>
  <li>\(f(x)\): function mapping a token to its position in the vocab. If \(x\) is \(T_k\) in the vocab, \(f(x) = k\).</li>
  <li>Given the sequence \((x_1, x_2, ..., x_n)\), we’ll have \(n\) training samples:
    <ul>
      <li>Input: \(x =(x_1, x_2, ..., x_{i-1})\)</li>
      <li>Ground truth:  \(x_i\)</li>
    </ul>
  </li>
  <li>For each training sample \((x, x_i)\):
    <ul>
      <li>Let \(k = f(x_i)\)</li>
      <li>Model’s output: \(LLM(x)= [\bar{y}_1, \bar{y}_2, ..., \bar{y}_V]\). Note: \(\sum_j\bar{y}_j = 1\)</li>
      <li>The loss value: \(CE(x, x_i; \phi) = -\log\bar{y}_k\)</li>
    </ul>
  </li>
  <li>Goal: find \(\phi\) to minimize the expected loss on all training samples.
  \(CE(\phi) = -E_x\log\bar{y}_k\)</li>
</ul>

<hr />
<hr />

<p><br /></p>
<h3 id="data_bottleneck_for_pretraining">Data bottleneck for pretraining</h3>

<p>Today, a language model like GPT-4 uses so much data that there’s a realistic concern that we’ll run out of Internet data in the next few years. It sounds crazy, but it’s happening. To get a sense of how big a trillion token is: a book contains around 50,000 words or 67,000 tokens. 1 trillion tokens are equivalent to 15 million books.</p>

<center>
    <figure>
    <img alt="RedPajama vs. LLaMa data" src="https://huyenchip.com/assets/pics/rlhf/4-1t-tokens.png" style="float: center; margin: 0 0 0em 0em;" />
    </figure>
    Side-by-side comparison of RedPajama and LLaMa data, done by RedPajama.
</center>
<p><br /></p>

<p>The rate of training dataset size growth is much faster than the rate of new data being generated (<a href="https://arxiv.org/abs/2211.04325">Villalobos et al, 2022</a>). <strong>If you’ve ever put anything on the Internet, you should assume that it is already or will be included in the training data for some language models</strong>, whether you consent or not. This is similar to how, if you post something on the Internet, you should expect it to be indexed by Google.</p>

<center>
    <figure>
    <img alt="We're at the risk of running out of Internet data" src="https://huyenchip.com/assets/pics/rlhf/5-internet-data.png" style="float: center; margin: 0 0 0em 0em;" />
    </figure>
</center>
<p><br /></p>

<p>On top of that, the Internet is being rapidly populated with data generated by large language models like ChatGPT. If companies continue using Internet data to train large LLMs, these new LLMs might just be trained on data generated by existing LLMs.</p>

<p>Once the publicly available data is exhausted, the most feasible path for more training data is with proprietary data. I suspect that any company that somehow gets its hand on a massive amount of proprietary data – copyrighted books, translations, video/podcast transcriptions, contracts, medical records, genome sequences, user data, etc. – will have a competitive advantage. It’s not surprising that in light of ChatGPT, many companies have changed their data terms to prevent other companies from scraping their data for LLMs – see <a href="https://www.redditinc.com/policies/data-api-terms">Reddit</a>, <a href="https://policies.stackoverflow.co/teams/enterprise-cloud-business/">StackOverflow</a>.</p>

<h2 id="phase_2_sft">Phase 2. Supervised finetuning (SFT) for dialogue</h2>

<h3 id="why_sft">Why SFT</h3>

<p>Pretraining optimizes for completion. If you give the pretrained model a question, say, <code class="language-plaintext highlighter-rouge">How to make pizza</code>, any of the following could be valid completion.</p>

<ol>
  <li>Adding more context to the question: <code class="language-plaintext highlighter-rouge">for a family of six</code></li>
  <li>Adding follow-up questions: <code class="language-plaintext highlighter-rouge">? What ingredients do I need? How much time would it take?</code></li>
  <li>Actually giving the answer</li>
</ol>

<p>The third option is preferred if you’re looking for an answer. The goal of SFT is to optimize the pretrained model to generate the responses that users are looking for.</p>

<p>How to do that? We know that a model mimics its training data. During SFT, we show our language model examples of how to appropriately respond to prompts of different use cases (e.g. question answering, summarization, translation). The examples follow the format (prompt, response) and are called demonstration data. OpenAI calls supervised finetuning <em>behavior cloning</em>: you demonstrate how the model should behave, and the model clones this behavior.</p>

<center>
    <figure>
    <img alt="3 phases of ChatGPT development" src="https://huyenchip.com/assets/pics/rlhf/7-sft-prompts.png" style="float: center; margin: 0 0 0em 0em;" />
    </figure>
    The distribution of prompts used to finetune InstructGPT
</center>
<p><br />
To train a model to mimic the demonstration data, you can either start with the pretrained model and finetune it, or train from scratch. In fact, OpenAI showed that the <em><a href="https://arxiv.org/abs/2203.02155">outputs from the 1.3B parameter InstructGPT model are preferred to outputs from the 175B GPT-3</a></em>. However, the finetuned approach produces much superior results.</p>

<h3 id="demonstration_data">Demonstration data</h3>

<p>Demonstration data can be generated by humans, like what OpenAI did with InstructGPT and ChatGPT. Unlike traditional data labeling, demonstration data is generated by highly educated labelers who pass a screen test. Among those who labeled demonstration data for InstructGPT, <a href="https://arxiv.org/pdf/2203.02155.pdf">~90% have at least a college degree</a> and more than one-third have a master’s degree.</p>

<center>
    <figure>
    <img alt="3 phases of ChatGPT development" src="https://huyenchip.com/assets/pics/rlhf/8-labeler-degrees.png" style="float: center; margin: 0 0 0em 0em;" />
    </figure>
</center>
<p><br /></p>

<p>OpenAI’s 40 labelers created around 13,000 (prompt, response) pairs for <a href="https://arxiv.org/abs/2203.02155">InstructGPT</a>. Here are a few examples:</p>

<table>
    
  <tr>
   <td><strong>Prompt</strong>
   </td>
   <td><strong>Response</strong>
   </td>
  </tr>
  <tr>
   <td>Serendipity means the occurrence and development of events by chance in a happy or beneficial way. Use the word in a sentence.
   </td>
   <td>Running into Margaret and being introduced to Tom was a fortunate stroke of serendipity.
   </td>
  </tr>
  <tr>
   <td>ELI5: What's the cause of the "anxiety lump" in our chest during stressful or disheartening experiences?
   </td>
   <td>The anxiety lump in your throat is caused by muscular tension keeping your glottis dilated to maximize airflow. The clenched chest or heartache feeling is caused by the vagus nerve which tells the organs to pump blood faster, stop digesting, and produce adrenaline and cortisol.
   </td>
  </tr>
  <tr>
   <td>Create a shopping list from this recipe:<br />
        Trim the ends off zucchini. Cut zucchini in half lengthwise; scoop out pulp, leaving 1/2-in. shells. Finely chop pulp. In a skillet, cook beef, zucchini pulp, onion, mushrooms and peppers over medium heat until meat is no longer pink; drain. Remove from the heat. Add 1/2 cup cheese, ketchup, salt and pepper; mix well. Spoon into the zucchini shells. Place in a greased 13x9-in. baking dish. Sprinkle with remaining cheese.
   </td>
   <td>Zucchini, beef, onion, mushroom, peppers, cheese, ketchup, salt, pepper
   </td>
  </tr>
</table>

<p><br /></p>

<p>OpenAI’s approach yields high-quality demonstration data but is expensive and time-consuming. Instead, DeepMind used heuristics to filter for dialogues from Internet data for their model Gopher (<a href="https://arxiv.org/abs/2112.11446">Rae et al., 2021</a>).</p>

<p><strong>»» Side note: DeepMind’s heuristics for dialogues ««</strong></p>
<blockquote>
  <p>_Concretely, we find all sets of consecutive paragraphs (blocks of text separated by two newlines) at least 6 paragraphs long, with all paragraphs having a prefix ending in a separator (e.g., <code class="language-plaintext highlighter-rouge">Gopher: </code>, <code class="language-plaintext highlighter-rouge">Dr Smith - </code>, or <code class="language-plaintext highlighter-rouge">Q. </code>). The even-indexed paragraphs must have the same prefix as each other, and the same for the odd-indexed paragraphs, but both prefixes should be different (in other words, the conversation must be strictly back-and-forth between two individuals). This procedure reliably yields high-quality dialogue.</p>
</blockquote>

<p><strong>»» Side note: on finetuning for dialogues vs. finetuning for following instructions ««</strong></p>
<blockquote>
  <p>OpenAI’s InstructGPT is finetuned for following instructions. Each example of demonstration data is a pair of (prompt, response). DeepMind’s Gopher is finetuned for conducting dialogues. Each example of demonstration is multiple turns of back-and-forth dialogues. Instructions are subsets of dialogues – ChatGPT is a powered-up version of InstructGPT.</p>
</blockquote>

<h3 id="mathematical_formulation_sft">Mathematical formulation</h3>

<p>The mathematical formulation is very similar to the one in phase 1.</p>

<ul>
  <li>ML task: language modeling</li>
  <li>Training data: high-quality data in the format of (prompt, response)</li>
  <li>Data scale: 10,000 - 100,000 (prompt, response) pairs
    <ul>
      <li><a href="https://openai.com/research/instruction-following#sample1">InstructGPT</a>: ~14,500 pairs (13,000 from labelers + 1,500 from customers)</li>
      <li><a href="https://github.com/tatsu-lab/stanford_alpaca">Alpaca</a>: 52K ChatGPT instructions</li>
      <li><a href="https://huggingface.co/datasets/databricks/databricks-dolly-15k">Databricks’ Dolly-15k</a>: ~15k pairs, created by Databricks employees</li>
      <li><a href="https://projects.laion.ai/Open-Assistant/docs/data/datasets">OpenAssistant</a>: 161,000 messages in 10,000 conversations -&gt; approximately 88,000 pairs</li>
      <li><a href="https://www.deepmind.com/publications/scaling-language-models-methods-analysis-insights-from-training-gopher">Dialogue-finetuned Gopher</a>: ~5 billion tokens, which I estimate to be in the order of 10M messages. However, keep in mind that these are filtered out using heuristics from the Internet, so not of the highest quality.</li>
    </ul>
  </li>
  <li>Model input and output
    <ul>
      <li>Input: prompt</li>
      <li>Output: response for this prompt</li>
    </ul>
  </li>
  <li>Loss function to minimize during the training process: cross entropy, but only the tokens in the response are counted towards the loss.</li>
</ul>

<h2 id="phase_3_rlhf">Phase 3. RLHF</h2>

<p>Empirically, RLHF improves performance significantly compared to SFT alone. However, I haven’t seen an argument that I find foolproof. Anthropic explained that: “<em>we expect human feedback (HF) to have the largest comparative advantage over other techniques when people have complex intuitions that are easy to elicit but difficult to formalize and automate</em>.” (<a href="https://arxiv.org/abs/2204.05862">Bai et al., 2022</a>)</p>

<center>
    <figure>
    <img alt="3 phases of ChatGPT development" src="https://huyenchip.com/assets/pics/rlhf/9-sft-rlhf.png" style="float: center; margin: 0 0 0em 0em;" />
    </figure>
    InstructGPT (SFT + RLHF) outperforms SFT alone
</center>
<p><br /></p>

<p>Dialogues are flexible. Given a prompt, there are many plausible responses, some are better than others. Demonstration data tells the model what responses are plausible for a given context, but doesn’t tell the model how good or how bad a response is.</p>

<p>The idea: what if we have a scoring function that, if given a prompt and a response, outputs a score for how good that response is? Then we use this scoring function to further train our LLMs towards giving responses with high scores. That’s exactly what RLHF does. RLHF consists of two parts:</p>

<ol>
  <li>Train a reward model to act as a scoring function.</li>
  <li>Optimize LLM to generate responses for which the reward model will give high scores.</li>
</ol>

<p><strong>»»Side note: Hypotheses on why RLHF works««</strong></p>

<blockquote>
  <p>Yoav Goldberg has an excellent note on the <a href="https://gist.github.com/yoavg/6bff0fecd65950898eba1bb321cfbd81">three hypotheses on why RLHF works</a>.</p>
</blockquote>

<blockquote>
  <ul>
    <li><strong>The diversity hypothesis</strong>: during SFT, the model’s output is expected to somewhat match the demonstrated responses. For example, given the prompt “what’s an example of a language?”, if the demonstrated response is “Spanish” and the model’s response is “Java”, the model’s response might be marked as wrong.</li>
    <li><strong>The negative feedback hypothesis</strong>: demonstration only gives the model positive signals (e.g. only showing the model good responses), not negative signals (e.g. showing models what bad responses look like). RL allows us to show models negative signals.</li>
    <li><strong>The hallucination hypothesis</strong>: RLHF is supposed to help with hallucination, which we’ll go into in the <strong>RLHF and hallucination</strong> section.</li>
  </ul>
</blockquote>

<h3 id="3_1_reward_model">3.1. Reward model (RM)</h3>

<p>The RM’s job is to output a score for a pair of (prompt, response). Training a model to output a score on a given input is a pretty common task in ML. You can simply frame it as a classification or a regression task. The challenge with training a reward model is with obtaining trustworthy data. Getting different labelers to give consistent scores for the same response turns out to be quite difficult. It’s a lot easier to ask labelers to compare two responses and decide which one is better.</p>

<p>The labeling process would produce data that looks like this: (prompt, winning_response, losing_response). This is called comparison data.</p>

<p>Here’s an example of comparison data from <a href="https://huggingface.co/datasets/Anthropic/hh-rlhf">Anthropic</a>’s HH-RLHF dataset. Personally, I prefer the losing_response. This highlights a challenge for learning from human preferences. Human preferences are diverse and impossible to capture in a single mathematical formulation.</p>

<table>

  <tr>
   <td><strong>prompt</strong>
   </td>
   <td><strong>winning_response</strong>
   </td>
   <td><strong>losing_response</strong>
   </td>
  </tr>
  <tr>
   <td>How can I get my dog high?
   </td>
   <td>I'm not sure what you mean by that.
   </td>
   <td>I don't know that we should get the dog high. I think it's important for a dog to experience the world in a sober state of mind.
   </td>
  </tr>
</table>
<p><br /></p>

<p>Now comes the trippy part: given only this comparison data, how do you train the model to give concrete scores? Just like how you can get humans to do (basically) anything given the right incentive, you can get a model to do (basically) anything given the right objective (aka loss function).</p>

<p>For InstructGPT, the objective is to maximize the difference in score between the winning response and the losing response (see detail in the section <strong>Mathematical formulation</strong>).</p>

<p>People have experimented with different ways to initialize an RM: e.g. training an RM from scratch or starting with the SFT model as the seed. Starting from the SFT model seems to give the best performance. The intuition is that the RM should be at least as powerful as the LLM to be able to score the LLM’s responses well.</p>

<h4 id="mathematical_formulation_rm">Mathematical formulation</h4>

<p>There might be some variations, but here’s the core idea.</p>

<ul>
  <li>Training data: high-quality data in the format of (prompt, winning_response, losing_response)</li>
  <li>Data scale: 100K - 1M examples
    <ul>
      <li><a href="https://openai.com/research/instruction-following#sample1">InstructGPT</a>: 50,000 prompts. Each prompt has 4 to 9 responses, forming between 6 and 36 pairs of (winning_response, losing_response). This means between 300K and 1.8M training examples in the format of (prompt, winning_response, losing_response).</li>
      <li><a href="https://arxiv.org/abs/2212.08073">Constitutional AI</a>, which is suspected to be the backbone of Claude (Anthropic): 318K comparisons – 135K generated by humans, and 183K generated by AI. Anthropic has an older version of their data open-sourced (<a href="https://huggingface.co/datasets/Anthropic/hh-rlhf">hh-rlhf</a>), which consists of roughly 170K comparisons.</li>
    </ul>
  </li>
</ul>

<hr />
<hr />

<ul>
  <li>\(r_\theta\): the reward model being trained, parameterized by \(\theta\). The goal of the training process is to find \(\theta\) for which the loss is minimized.</li>
  <li>Training data format:
    <ul>
      <li>\(x\): prompt</li>
      <li>\(y_w\): winning response</li>
      <li>\(y_l\): losing response</li>
    </ul>
  </li>
  <li>For each training sample \((x, y_w, y_l)\)
    <ul>
      <li>\(s_w=r_\theta(x, y_w)\): reward model’s score for the winning response</li>
      <li>\(s_l=r_\theta(x, y_l)\): reward model’s score for the losing response</li>
      <li>Loss value: \(-\log(\sigma(s_w - s_l))\)</li>
    </ul>
  </li>
  <li>Goal: find \(\theta\) to minimize the expected loss for all training samples.
  \(-E_x\log(\sigma(s_w - s_l))\)</li>
</ul>

<p>To get more intuition how this loss function works, let’s visualize it.</p>

<p>Let \(d = s_w - s_l\). Here’s the graph for \(f(d) = -\log(\sigma(d))\). The loss value is large for negative \(d\), which incentivizes the reward model to not give the winning response a lower score than the losing response.</p>

<center>
    <figure>
    <img alt="3 phases of ChatGPT development" src="https://huyenchip.com/assets/pics/rlhf/11-graph-rm-loss.png" style="float: center; margin: 0 0 0em 0em;" />
    </figure>
</center>
<p><br /></p>

<hr />
<hr />
<p><br /></p>

<h4 id="ui_to_collect_comparison_data">UI to collect comparison data</h4>

<p>Below is a screenshot of <a href="https://arxiv.org/pdf/2203.02155.pdf">the UI that OpenAI’s labelers</a> used to create training data for InstructGPT’s RM. Labelers both give concrete scores from 1 to 7 and rank the responses in the order of preference, but only the ranking is used to train the RM. <strong>Their inter-labeler agreement is around 73%, which means if they ask 10 people to rank 2 responses, 7 of them will have the same ranking</strong>.</p>

<center>
    <figure>
    <img alt="3 phases of ChatGPT development" src="https://huyenchip.com/assets/pics/rlhf/12-ui.png" style="float: center; margin: 0 0 0em 0em;" />
    </figure>
</center>
<p><br /></p>

<p>To speed up the labeling process, they ask each annotator to rank multiple responses. 4 ranked responses, e.g. A &gt; B &gt; C &gt; D, will produce 6 ranked pairs, e.g. (A &gt; B), (A &gt; C), (A &gt; D), (B &gt; C), (B &gt; D), (C &gt; D).</p>

<h3 id="3_2_finetuning_using_the_reward_model">3.2. Finetuning using the reward model</h3>

<p>In this phase, we will further train the SFT model to generate output responses that will maximize the scores by the RM. Today, most people use <a href="https://openai.com/research/openai-baselines-ppo">Proximal Policy Optimization</a> (PPO), a reinforcement learning algorithm released by OpenAI in 2017.</p>

<p>During this process, prompts are randomly selected from a distribution – e.g. we might randomly select among customer prompts. Each of these prompts is input into the LLM model to get back a response, which is given a score by the RM.</p>

<p>OpenAI also found that it’s necessary to add a constraint: the model resulting from this phase should not stray too far from the model resulting from the SFT phase (mathematically represented as the KL divergence term in the objective function below) and the original pretraining model. The intuition is that there are many possible responses for any given prompt, the vast majority of them the RM has never seen before. For many of those unknown (prompt, response) pairs, the RM might give an extremely high or low score by mistake. Without this constraint, we might bias toward those responses with extremely high scores, even though they might not be good responses.</p>

<p>OpenAI has this great diagram that explains the <a href="https://openai.com/research/instruction-following">SFT and RLHF</a> for InstructGPT.</p>

<center>
    <figure>
    <img alt="3 phases of ChatGPT development" src="https://huyenchip.com/assets/pics/rlhf/6-sft-rlhf.png" style="float: center; margin: 0 0 0em 0em;" />
    </figure>
</center>
<p><br /></p>

<h4 id="mathematical_formulation_rl">Mathematical formulation</h4>

<ul>
  <li>ML task: reinforcement learning
    <ul>
      <li>Action space: the vocabulary of tokens the LLM uses. Taking action means choosing a token to generate.</li>
      <li>Observation space: the distribution over all possible prompts.</li>
      <li>Policy: the probability distribution over all actions to take (aka all tokens to generate) given an observation (aka a prompt). An LLM constitutes a policy because it dictates how likely a token is to be generated next.</li>
      <li>Reward function: the reward model.</li>
    </ul>
  </li>
  <li>Training data: randomly selected prompts</li>
  <li>Data scale: 10,000 - 100,000 prompts
    <ul>
      <li><a href="https://openai.com/research/instruction-following#sample1">InstructGPT</a>: 40,000 prompts</li>
    </ul>
  </li>
</ul>

<hr />
<hr />
<ul>
  <li>\(RM\): the reward model obtained from phase 3.1.</li>
  <li>\(LLM^{SFT}\): the supervised finetuned model obtained from phase 2.
    <ul>
      <li>Given a prompt \(x\), it outputs a distribution of responses.</li>
      <li>In the InstructGPT paper, \(LLM^{SFT}\) is represented as \(\pi^{SFT}\).</li>
    </ul>
  </li>
  <li>\(LLM^{RL}_\phi\): the model being trained with reinforcement learning, parameterized by \(\phi\).
    <ul>
      <li>The goal is to find \(\phi\) to maximize the score according to the \(RM\).</li>
      <li>Given a prompt \(x\), it outputs a distribution of responses.</li>
      <li>In the InstructGPT paper, \(LLM^{RL}_\phi\) is represented as \(\pi^{RL}_\phi\).</li>
    </ul>
  </li>
  <li>\(x\): prompt</li>
  <li>\(D_{RL}\): the distribution of prompts used explicitly for the RL model.</li>
  <li>\(D_{pretrain}\): the distribution of the training data for the pretrain model.</li>
</ul>

<p>For each training step, you sample a batch of \(x_{RL}\) from \(D_{RL}\) and a batch of \(x_{pretrain}\) from \(D_{pretrain}\). The objective function for each sample depends on which distribution the sample comes from.</p>

<ol>
  <li>
    <p>For each \(x_{RL}\), we use \(LLM^{RL}_\phi\) to sample a response: \(y \sim LLM^{RL}_\phi(x_{RL})\). The objective is computed as follows. Note that the second term in this objective is the KL divergence to make sure that the RL model doesn’t stray too far from the SFT model.</p>

\[\text{objective}_1(x_{RL}, y; \phi) = RM(x_{RL}, y) - \beta \log \frac{LLM^{RL}_\phi(y \vert x)}{LLM^{SFT}(y \vert x)}\]
  </li>
  <li>
    <p>For each \(x_{pretrain}\), the objective is computed as follows. Intuitively, this objective is to make sure that the RL model doesn’t perform worse on text completion – the task the pretrained model was optimized for.</p>

\[\text{objective}_2(x_{pretrain}; \phi) = \gamma \log LLM^{RL}_\phi(x_{pretrain})\]
  </li>
</ol>

<p>The final objective is the sum of the expectation of two objectives above. In the RL setting, we maximize the objective instead of minimizing the objective as done in the previous steps.</p>

\[\text{objective}(\phi) = E_{x \sim D_{RL}}E_{y \sim LLM^{RL}_\phi(x)} [RM(x, y) - \beta \log \frac{LLM^{RL}_\phi(y \vert x)}{LLM^{SFT}(y \vert x)}] + \gamma E_{x \sim D_{pretrain}}\log LLM^{RL}_\phi(x)\]

<p><strong>Note</strong>:</p>

<p>The notation used is slightly different from the notation used in <a href="https://arxiv.org/abs/2203.02155">the InstructGPT paper</a>, as I find the notation here a bit more explicit, but they both refer to the exact same objective function.</p>

<center>
    <figure>
    <img alt="RLHF objective function" src="https://huyenchip.com/assets/pics/rlhf/14-rlhf-objective.png" style="float: center; margin: 0 0 0em 0em;" />
        The objective function as written in the InstructGPT paper.
    </figure>
</center>
<p><br /></p>

<hr />
<hr />

<p><br /></p>
<h3 id="rlhf_and_hallucination">RLHF and hallucination</h3>

<p>Hallucination happens when an AI model makes stuff up. It’s a big reason why many companies are hesitant to incorporate LLMs into their workflows.</p>

<p>There are two hypotheses that I found that explain why LLMs hallucinate.</p>

<p>The first hypothesis, first expressed by Pedro A. Ortega et al. at DeepMind in Oct 2021, is that LLMs hallucinate because they “<a href="https://arxiv.org/abs/2110.10819#deepmind">lack the understanding of the cause and effect of their actions</a>” (back then, DeepMind used the term “delusion” for “hallucination”). They showed that this can be addressed by treating response generation as causal interventions.</p>

<p>The second hypothesis is that hallucination is caused by the mismatch between the LLM’s internal knowledge and the labeler’s internal knowledge. In his <a href="https://www.youtube.com/watch?v=hhiLw5Q_UFg">UC Berkeley talk</a> (April 2023), John Schulman, OpenAI co-founder and PPO author, suggested that behavior cloning causes hallucination. During SFT, LLMs are trained to mimic responses written by humans. If we give a response using the knowledge that we have but the LLM doesn’t have, we’re teaching the LLM to hallucinate.</p>

<p>This view was also well articulated by <a href="https://www.alignmentforum.org/posts/BgoKdAzogxmgkuuAt/behavior-cloning-is-miscalibrated">Leo Gao</a>, another OpenAI employee, in Dec 2021. In theory, the human labeler can include all the context they know with each prompt to teach the model to use only the existing knowledge. However, this is impossible in practice.</p>

<p>Schulman believed that <a href="https://www.youtube.com/live/hhiLw5Q_UFg?feature=share&amp;t=1019">LLMs know if they know something</a> (which is a big claim, IMO), this means that hallucination can be fixed if we find a way to force LLMs to only give answers that contain information they know. He then proposed a couple of solutions.</p>

<ol>
  <li>Verification: asking the LLM to explain (retrieve) the sources where it gets the answer from.</li>
  <li>RL. Remember that the reward model in phase 3.1 is trained using only comparisons: response A is better than response B, without any information on how much better or why A is better. Schulman argued that we can solve hallucination by having a better reward function, e.g. punishing a model more for making things up.</li>
</ol>

<p>Here’s a screenshot from <a href="https://www.youtube.com/live/hhiLw5Q_UFg?feature=share&amp;t=1254">John Schulman’s talk</a> in April 2023.</p>

<center>
    <figure>
    <img alt="Fix hallucination with R" src="https://huyenchip.com/assets/pics/rlhf/13-schulman-fix-rl.png" style="float: center; margin: 0 0 0em 0em;" />
    </figure>
</center>
<p><br /></p>

<p>From Schulman’s talk, I got the impression that RLHF is supposed to help with hallucination. However, the InstructGPT paper shows that RLHF actually made hallucination worse. Even though RLHF caused worse hallucination, it improved other aspects, and overall, human labelers prefer RLHF model over SFT alone model.</p>

<center>
    <figure>
    <img alt="RLHF makes hallucination worse" src="https://huyenchip.com/assets/pics/rlhf/10-hallucination.png" style="float: center; margin: 0 0 0em 0em;" />
    </figure>
    Hallucination is worse for InstructGPT (RLHF + SFT) compared to just SFT (Ouyang et al., 2022)
</center>
<p><br /></p>

<p>Based on the assumption that LLMs know what they know, some people try to reduce hallucination with prompts, e.g. adding <code class="language-plaintext highlighter-rouge">Answer as truthfully as possible, and if you're unsure of the answer, say "Sorry, I don't know"</code>. Making LLMs respond concisely also seems to help with hallucination – the fewer tokens LLMs have to generate, the less chance they have to make things up.</p>

<h2 id="conclusion">Conclusion</h2>

<p>This has been a really fun post to write – I hope you enjoyed reading it too. I had another whole section about the limitations of RLHF – e.g. biases in human preference, the challenge of evaluation, and data ownership issue – but decided to save it for another post because this one has gotten long.</p>

<p>As I dove into papers about RLHF, I was impressed by three things:</p>

<ol>
  <li>Training a model like ChatGPT is a fairly complicated process – it’s amazing it worked at all.</li>
  <li>The scale is insane. I’ve always known that LLMs require a lot of data and compute, but the entire Internet data!!??</li>
  <li>How much companies (used to) share about their process. <a href="https://arxiv.org/abs/2112.11446">DeepMind’s Gopher paper</a> is 120 pages. <a href="https://arxiv.org/abs/2203.02155">OpenAI’s InstructGPT</a> paper is 68 pages, Anthropic shared their 161K hh-rlhf comparison examples, Meta made available their LLaMa model for research. There’s also an incredible amount of goodwill and drive from the community to create open-sourced models and datasets, such as OpenAssistant and LAION. It’s an exciting time!</li>
</ol>

<p>We’re still in the early days of LLMs. The rest of the world has just woken up to the potential of LLMs, so the race has just begun. Many things about LLMs, including RLHF, will evolve. But I hope that this post helped you understand better how LLMs are trained under the hood, which can hopefully help you with choosing the best LLM for your need!</p>
]]></content:encoded>
<pubDate>Tue, 02 May 2023 00:00:00 +0000</pubDate>
</item>
<item>
<title>Building LLM applications for production</title>
<link>https://huyenchip.com//2023/04/11/llm-engineering.html</link>
<guid>https://huyenchip.com//2023/04/11/llm-engineering.html</guid>
<content:encoded><![CDATA[
<div> 挑战,生产,控制流,应用,使用  

挑战: 生产化LLM应用的关键挑战包括工程严谨度不足、自然语言的模糊性、LLM输出格式不一致和用户体验方面的一致性问题。解决这些挑战需要加强工程严谨性、对LLM生成的输出进行评估和版本控制。<br /><br />总结: 在LLM应用中生产任务工程方面的重要挑战包括解决自然语言的模糊性问题和提高工程严谨性，同时需要考虑控制流、多任务组合、工具整合和LLM生成的输出格式问题。 <div>
<p>[<em><a href="https://news.ycombinator.com/item?id=35565212">Hacker News discussion</a>, <a href="https://www.linkedin.com/posts/chiphuyen_llms-promptengineering-mlops-activity-7051955337221844992-oG7a/">LinkedIn discussion</a>, <a href="https://twitter.com/chipro/status/1646189847625998336">Twitter thread</a></em>]</p>

<p>A question that I’ve been asked a lot recently is how large language models (LLMs) will change machine learning workflows. After working with several companies who are working with LLM applications and personally going down a rabbit hole building my applications, I realized two things:</p>

<ol>
  <li>It’s easy to make something cool with LLMs, but very hard to make something production-ready with them.</li>
  <li>LLM limitations are exacerbated by a lack of engineering rigor in prompt engineering, partially due to the ambiguous nature of natural languages, and partially due to the nascent nature of the field.</li>
</ol>

<p>This post consists of three parts.</p>

<ul>
  <li>Part 1 discusses the key challenges of productionizing LLM applications and the solutions that I’ve seen.</li>
  <li>Part 2 discusses how to compose multiple tasks with control flows (e.g. if statement, for loop) and incorporate tools (e.g. SQL executor, bash, web browsers, third-party APIs) for more complex and powerful applications.</li>
  <li>Part 3 covers some of the promising use cases that I’ve seen companies building on top of LLMs and how to construct them from smaller tasks.</li>
</ul>

<p>There has been so much written about LLMs, so feel free to skip any section you’re already familiar with.</p>

<hr />
<p><b>Table of contents</b><br />
<a href="https://huyenchip.com/feed.xml#prompt_engineering_challenges">Part I. Challenges of productionizing prompt engineering</a><br />
…….. <a href="https://huyenchip.com/feed.xml#natural_languages_ambiguity">The ambiguity of natural languages</a><br />
………… <a href="https://huyenchip.com/feed.xml#prompt_evaluation">Prompt evaluation</a><br />
………… <a href="https://huyenchip.com/feed.xml#prompt_versioning">Prompt versioning</a><br />
………… <a href="https://huyenchip.com/feed.xml#prompt_optimization">Prompt optimization</a><br />
…….. <a href="https://huyenchip.com/feed.xml#cost_and_latency">Cost and latency</a><br />
………… <a href="https://huyenchip.com/feed.xml#cost">Cost</a><br />
………… <a href="https://huyenchip.com/feed.xml#latency">Latency</a><br />
………… <a href="https://huyenchip.com/feed.xml#cost_latency_analysis_impossibility">The impossibility of cost + latency analysis for LLMs</a><br />
…….. <a href="https://huyenchip.com/feed.xml#prompting_vs_finetuning_vs_alternatives">Prompting vs. finetuning vs. alternatives</a><br />
………… <a href="https://huyenchip.com/feed.xml#prompt_tuning">Prompt tuning</a><br />
………… <a href="https://huyenchip.com/feed.xml#finetuning_with_distillation">Finetuning with distillation</a><br />
…….. <a href="https://huyenchip.com/feed.xml#embeddings_vector_databases">Embeddings + vector databases</a><br />
…….. <a href="https://huyenchip.com/feed.xml#backward_and_forward_compatibility">Backward and forward compatibility</a><br />
<a href="https://huyenchip.com/feed.xml#part_2_task_composability">Part 2. Task composability</a><br />
…….. <a href="https://huyenchip.com/feed.xml#applications_that_consist_of_multiple_tasks">Applications that consist of multiple tasks</a><br />
…….. <a href="https://huyenchip.com/feed.xml#agents_tools_and_control_flows">Agents, tools, and control flows</a><br />
………… <a href="https://huyenchip.com/feed.xml#tools_vs_plugins">Tools vs. plugins</a><br />
………… <a href="https://huyenchip.com/feed.xml#control_flows_sequential_parallel_if_for_loop">Control flows: sequential, parallel, if, for loop</a><br />
………… <a href="https://huyenchip.com/feed.xml#control_flow_with_llm_agents">Control flow with LLM agents</a><br />
………… <a href="https://huyenchip.com/feed.xml#testing_an_agent">Testing an agent</a><br />
<a href="https://huyenchip.com/feed.xml#part_3_promising_use_cases">Part 3. Promising use cases</a><br />
…….. <a href="https://huyenchip.com/feed.xml#ai_assistant">AI assistant</a><br />
…….. <a href="https://huyenchip.com/feed.xml#chatbot">Chatbot</a><br />
…….. <a href="https://huyenchip.com/feed.xml#programming_and_gaming">Programming and gaming</a><br />
…….. <a href="https://huyenchip.com/feed.xml#learning">Learning</a><br />
…….. <a href="https://huyenchip.com/feed.xml#talk_to_your_data">Talk-to-your-data</a><br />
………… <a href="https://huyenchip.com/feed.xml#can_llms_do_data_analysis_for_me">Can LLMs do data analysis for me?</a><br />
…….. <a href="https://huyenchip.com/feed.xml#search_and_recommendation">Search and recommendation</a><br />
…….. <a href="https://huyenchip.com/feed.xml#sales">Sales</a><br />
…….. <a href="https://huyenchip.com/feed.xml#seo">SEO</a><br />
<a href="https://huyenchip.com/feed.xml#conclusion">Conclusion</a><br /></p>

<hr />
<p><br /></p>
<h2 id="prompt_engineering_challenges">Part I. Challenges of productionizing prompt engineering</h2>

<h3 id="natural_languages_ambiguity">The ambiguity of natural languages</h3>

<p>For most of the history of computers, engineers have written instructions in programming languages. Programming languages are “mostly” exact. Ambiguity causes frustration and even passionate hatred in developers (think dynamic typing in Python or JavaScript).</p>

<p>In prompt engineering, instructions are written in natural languages, which are a lot more flexible than programming languages. This can make for a great user experience, but can lead to a pretty bad developer experience.</p>

<p>The flexibility comes from two directions: how users define instructions, and how LLMs respond to these instructions.</p>

<p>First, the flexibility in user-defined prompts leads to silent failures. If someone accidentally makes some changes in code, like adding a random character or removing a line, it’ll likely throw an error. However, if someone accidentally changes a prompt, it will still run but give very different outputs.</p>

<p>While the flexibility in user-defined prompts is just an annoyance, the ambiguity in LLMs’ generated responses can be a dealbreaker. It leads to two problems:</p>

<ol>
  <li>
    <p><strong>Ambiguous output format</strong>: downstream applications on top of LLMs expect outputs in a certain format so that they can parse. We can craft our prompts to be explicit about the output format, but there’s no guarantee that the outputs will <em>always</em> follow this format.</p>

    <center>
 <figure>
 <img alt="LLM Engineering" src="https://huyenchip.com/assets/pics/llmops/1_ambiguous_output.png" style="float: center; margin: 0 0 0em 0em;" />
 </figure>
 </center>
    <p><br /></p>
  </li>
  <li>
    <p><strong>Inconsistency in user experience</strong>: when using an application, users expect certain consistency. Imagine an insurance company giving you a different quote every time you check on their website. LLMs are stochastic – there’s no guarantee that an LLM will give you the same output for the same input every time.</p>

    <p>You can force an LLM to give the same response by setting <strong><a href="https://platform.openai.com/docs/api-reference/completions/create#completions/create-temperature">temperature = 0</a></strong>, which is, in general, a good practice. While it <a href="https://community.openai.com/t/observing-discrepancy-in-completions-with-temperature-0/73380">mostly solves the consistency problem</a>, it doesn’t inspire trust in the system. Imagine a teacher who gives you consistent scores only if that teacher sits in one particular room. If that teacher sits in different rooms, that teacher’s scores for you will be wild.</p>

    <center>
 <figure>
 <img alt="LLM Engineering" src="https://huyenchip.com/assets/pics/llmops/2_ambiguous_output.png" style="float: center; margin: 0 0 0em 0em;" />
 </figure>
 </center>
    <p><br /></p>
  </li>
</ol>

<hr />
<p><b>How to solve this ambiguity problem?</b></p>

<p>This seems to be a problem that OpenAI is actively trying to mitigate. They have a notebook with tips on how to increase their models’ reliability.</p>

<p>A couple of people who’ve worked with LLMs for years told me that they just accepted this ambiguity and built their workflows around that. It’s a different mindset compared to developing deterministic programs, but not something impossible to get used to.</p>

<p>This ambiguity can be mitigated by applying as much engineering rigor as possible. In the rest of this post, we’ll discuss how to make prompt engineering, if not deterministic, systematic.</p>

<hr />
<p><br /></p>

<h4 id="prompt_evaluation">Prompt evaluation</h4>

<p>A common technique for prompt engineering is to provide in the prompt a few examples and hope that the LLM will generalize from these examples (fewshot learners).</p>

<p>As an example, consider trying to give a text a controversy score – it was a fun project that I did to find the correlation between a tweet’s popularity and its controversialness. Here is the shortened prompt with 4 fewshot examples:</p>

<p><strong>Example: controversy scorer</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Given a text, give it a controversy score from 0 to 10.

Examples:

1 + 1 = 2
Controversy score: 0

Starting April 15th, only verified accounts on Twitter will be eligible to be in For You recommendations
Controversy score: 5

Everyone has the right to own and use guns
Controversy score: 9

Immigration should be completely banned to protect our country
Controversy score: 10

The response should follow the format:

Controversy score: { score }
Reason: { reason }

Here is the text.
</code></pre></div></div>

<p>When doing fewshot learning, two questions to keep in mind:</p>

<ol>
  <li><strong>Whether the LLM understands the examples given in the prompt</strong>. One way to evaluate this is to input the same examples and see if the model outputs the expected scores. If the model doesn’t perform well on the same examples given in the prompt, it is likely because the prompt isn’t clear – you might want to rewrite the prompt or break the task into smaller tasks (and combine them together, discussed in detail in Part II of this post).</li>
  <li><strong>Whether the LLM overfits to these fewshot examples.</strong> You can evaluate your model on separate examples.</li>
</ol>

<p>One thing I’ve also found useful is to ask models to give examples for which it would give a certain label. For example, I can ask the model to give me examples of texts for which it’d give a score of 4. Then I’d input these examples into the LLM to see if it’ll indeed output 4.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>from llm import OpenAILLM

def eval_prompt(examples_file, eval_file):
    prompt = get_prompt(examples_file)
    model = OpenAILLM(prompt=prompt, temperature=0)
    compute_rmse(model, examples_file)
    compute_rmse(model, eval_file)
eval_prompt("fewshot_examples.txt", "eval_examples.txt")
</code></pre></div></div>

<h4 id="prompt_versioning">Prompt versioning</h4>

<p>Small changes to a prompt can lead to very different results. It’s essential to version and track the performance of each prompt. You can use git to version each prompt and its performance, but I wouldn’t be surprised if there will be tools like MLflow or Weights &amp; Biases for prompt experiments.</p>

<h4 id="prompt_optimization">Prompt optimization</h4>

<p>There have been many papers + blog posts written on how to optimize prompts. I agree with Lilian Weng in <a href="https://lilianweng.github.io/posts/2023-03-15-prompt-engineering/">her helpful blog post</a> that most papers on prompt engineering are tricks that can be explained in a few sentences. OpenAI has a great notebook that explains many <a href="https://github.com/openai/openai-cookbook/blob/main/techniques_to_improve_reliability.md#how-to-improve-reliability-on-complex-tasks">tips with examples</a>. Here are some of them:</p>

<ul>
  <li>Prompt the model to explain or explain step-by-step how it arrives at an answer, a technique known as <a href="https://arxiv.org/abs/2201.11903">Chain-of-Thought</a> or COT (Wei et al., 2022). <strong>Tradeoff</strong>: COT can increase both latency and cost due to the increased number of output tokens [see <strong>Cost and latency</strong> section]</li>
  <li>Generate many outputs for the same input. Pick the final output by either the majority vote  (also known as <a href="https://arxiv.org/abs/2203.11171">self-consistency technique</a> by Wang et al., 2023) or you can ask your LLM to pick the best one. In OpenAI API, you can generate multiple responses for the same input by passing in the argument <a href="https://platform.openai.com/docs/api-reference/completions/create">n</a> (not an ideal API design if you ask me).</li>
  <li>Break one big prompt into smaller, simpler prompts.</li>
</ul>

<p>Many tools promise to auto-optimize your prompts – they are quite expensive and usually just apply these tricks. One nice thing about these tools is that they’re no code, which makes them appealing to non-coders.</p>

<h3 id="cost_and_latency">Cost and latency</h3>

<h4 id="cost">Cost</h4>

<p>The more explicit detail and examples you put into the prompt, the better the model performance (hopefully), and the more expensive your inference will cost.</p>

<p>OpenAI API charges for both the input and output tokens. Depending on the task, a simple prompt might be anything between 300 - 1000 tokens. If you want to include more context, e.g. adding your own documents or info retrieved from the Internet to the prompt, it can easily go up to 10k tokens for the prompt alone.</p>

<p>The cost with long prompts isn’t in experimentation but in inference.</p>

<p>Experimentation-wise, <strong>prompt engineering is a cheap and fast way get something up and running</strong>. For example, even if you use GPT-4 with the following setting, your experimentation cost will still be just over $300. The traditional ML cost of collecting data and training models is usually much higher and takes much longer.</p>

<ul>
  <li>Prompt: 10k tokens ($0.06/1k tokens)</li>
  <li>Output: 200 tokens ($0.12/1k tokens)</li>
  <li>Evaluate on 20 examples</li>
  <li>Experiment with 25 different versions of prompts</li>
</ul>

<p><strong>The cost of LLMOps is in inference.</strong></p>

<ul>
  <li>If you use GPT-4 with 10k tokens in input and 200 tokens in output, it’ll be $0.624 / prediction.</li>
  <li>If you use GPT-3.5-turbo with 4k tokens for both input and output, it’ll be $0.004 / prediction or $4 / 1k predictions.</li>
  <li>As a thought exercise, in 2021, DoorDash ML models made <a href="https://www.databricks.com/session_na21/scaling-online-ml-predictions-at-doordash">10 billion predictions a day</a>. If each prediction costs $0.004, that’d be $40 million a day!</li>
  <li>By comparison, AWS personalization costs about <a href="https://aws.amazon.com/personalize/pricing/">$0.0417 / 1k predictions</a> and AWS fraud detection costs about <a href="https://aws.amazon.com/fraud-detector/pricing/">$7.5 / 1k predictions</a> [for over 100,000 predictions a month]. AWS services are usually considered prohibitively expensive (and less flexible) for any company of a moderate scale.</li>
</ul>

<h4 id="latency">Latency</h4>

<p>Input tokens can be processed in parallel, which means that input length shouldn’t affect the latency that much.</p>

<p>However, output length significantly affects latency, which is likely due to output tokens being generated sequentially.</p>

<p>Even for extremely short input (51 tokens) and output (1 token), the latency for <em>gpt-3.5-turbo</em> is around 500ms. If the output token increases to over 20 tokens, the latency is over 1 second.</p>

<p>Here’s an experiment I ran, each setting is run 20 times. All runs happen within 2 minutes. If I do the experiment again, the latency will be very different, but the relationship between the 3 settings should be similar.</p>

<p>This is another challenge of productionizing LLM applications using APIs like OpenAI: <strong>APIs are very unreliable, and no commitment yet on when SLAs will be provided.</strong></p>

<table>
    
  <tr>
   <td><strong># tokens</strong>
   </td>
   <td><strong>p50 latency (sec)</strong>
   </td>
   <td><strong>p75 latency</strong>
   </td>
   <td><strong>p90 latency</strong>
   </td>
  </tr>
  <tr>
   <td>input: 51 tokens, output: 1 token
   </td>
   <td>0.58
   </td>
   <td>0.63
   </td>
   <td>0.75
   </td>
  </tr>
  <tr>
   <td>input: 232 tokens, output: 1 token
   </td>
   <td>0.53
   </td>
   <td>0.58
   </td>
   <td>0.64
   </td>
  </tr>
  <tr>
   <td>input: 228 tokens, output: 26 tokens
   </td>
   <td>1.43
   </td>
   <td>1.49
   </td>
   <td>1.62
   </td>
  </tr>
</table>

<p><br /></p>

<p>It is, unclear, how much of the latency is due to model, networking (which I imagine is huge due to high variance across runs), or some just inefficient engineering overhead. It’s very possible that the latency will reduce significantly in a near future.</p>

<p>While half a second seems high for many use cases, this number is incredibly impressive given how big the model is and the scale at which the API is being used. The number of parameters for gpt-3.5-turbo isn’t public but is guesstimated to be around 150B. As of writing, no open-source model is that big. Google’s T5 is 11B parameters and Facebook’s largest LLaMA model is 65B parameters. People discussed on <a href="https://github.com/facebookresearch/llama/issues/79">this GitHub thread</a> what configuration they needed to make LLaMA models work, and it seemed like getting the 30B parameter model to work is hard enough. The most successful one seemed to be <em>randaller</em> who was able to get the <a href="https://github.com/randaller/llama-chat">30B parameter model work on 128 GB of RAM</a>, which takes a few seconds just to generate one token.</p>

<h4 id="cost_latency_analysis_impossibility">The impossibility of cost + latency analysis for LLMs</h4>

<p>The LLM application world is moving so fast that any cost + latency analysis is bound to go outdated quickly. <a href="https://www.linkedin.com/in/matt-as-ross/">Matt Ross</a>, a senior manager of applied research at Scribd, told me that the estimated API cost for his use cases has gone down two orders of magnitude over the last year. Latency has significantly decreased as well. Similarly, many teams have told me they feel like they have to redo the feasibility estimation and buy (using paid APIs) vs. build (using open source models) decision every week.</p>

<h3 id="prompting_vs_finetuning_vs_alternatives">Prompting vs. finetuning vs. alternatives</h3>

<ul>
  <li>Prompting: for each sample, explicitly tell your model how it should respond.</li>
  <li>Finetuning: train a model on how to respond, so you don’t have to specify that in your prompt.</li>
</ul>

<center>
<figure>
<img alt="LLM Engineering: Prompting vs. finetuning" src="https://huyenchip.com/assets/pics/llmops/3_prompting_vs_finetuning.png" style="float: center; margin: 0 0 0em 0em;" />
</figure>
</center>
<p><br /></p>

<p>There are 3 main factors when considering prompting vs. finetuning: data availability, performance, and cost.</p>

<p>If you have only a few examples, prompting is quick and easy to get started. <strong>There’s a limit to how many examples you can include in your prompt due to the maximum input token length.</strong></p>

<p>The number of examples you need to finetune a model to your task, of course, depends on the task and the model. In my experience, however, you can expect a noticeable change in your model performance if you finetune on 100s examples. However, the result might not be much better than prompting.</p>

<p>In <a href="https://arxiv.org/abs/2103.08493">How Many Data Points is a Prompt Worth?</a> (2021), ​​Scao and Rush found that a prompt is worth approximately 100 examples (caveat: variance across tasks and models is high – see image below). The general trend is that <strong>as you increase the number of examples, finetuning will give better model performance than prompting</strong>. There’s no limit to how many examples you can use to finetune a model.</p>

<center>
<figure>
<img alt="Prompting vs. finetuning: number of examples needed" src="https://huyenchip.com/assets/pics/llmops/4_prompting_vs_finetuning_data.png" style="float: center; margin: 0 0 0em 0em;" />
</figure>
</center>
<p><br /></p>

<p>The benefit of finetuning is two folds:</p>

<ol>
  <li>You can get better model performance: can use more examples, examples becoming part of the model’s internal knowledge.</li>
  <li>You can reduce the cost of prediction. The more instruction you can bake into your model, the less instruction you have to put into your prompt. Say, if you can reduce 1k tokens in your prompt for each prediction, for 1M predictions on <em>gpt-3.5-turbo</em>, you’d save $2000.</li>
</ol>

<h4 id="prompt_tuning">Prompt tuning</h4>

<p>A cool idea that is between prompting and finetuning is <strong><a href="https://arxiv.org/abs/2104.08691">prompt tuning</a></strong>, introduced by Leister et al. in 2021. Starting with a prompt, instead of changing this prompt, you programmatically change the embedding of this prompt. For prompt tuning to work, you need to be able to input prompts’ embeddings into your LLM model and generate tokens from these embeddings, which currently, can only be done with open-source LLMs and not in OpenAI API. On T5, prompt tuning appears to perform much better than prompt engineering and can catch up with model tuning (see image below).</p>

<center>
<figure>
<img alt="LLM Engineering: Prompt tuning" src="https://huyenchip.com/assets/pics/llmops/5_prompt_tuning.png" style="float: center; margin: 0 0 0em 0em;" />
</figure>
</center>
<p><br /></p>

<h4 id="finetuning_with_distillation">Finetuning with distillation</h4>

<p>In March 2023, a group of Stanford students released a promising idea: finetune a smaller open-source language model (LLaMA-7B, the 7 billion parameter version of LLaMA) on examples generated by a larger language model (<em>text-davinci-003</em> – 175 billion parameters). This technique of training a small model to imitate the behavior of a larger model is called distillation. The resulting finetuned model behaves similarly to <em>text-davinci-003</em>, while being a lot smaller and cheaper to run.</p>

<p>For finetuning, they used 52k instructions, which they inputted into <em>text-davinci-003</em> to obtain outputs, which are then used to finetune LLaMa-7B. This costs under $500 to generate. The training process for finetuning costs under $100. See <a href="https://github.com/tatsu-lab/stanford_alpaca">Stanford Alpaca: An Instruction-following LLaMA Model</a> (Taori et al., 2023).</p>

<center>
<figure>
<img alt="LLM Engineering: Alpaca" src="https://huyenchip.com/assets/pics/llmops/6_alpaca.png" style="float: center; margin: 0 0 0em 0em;" />
</figure>
</center>
<p><br /></p>

<p>The appeal of this approach is obvious. After 3 weeks, their GitHub repo got almost 20K stars!! By comparison, <a href="https://github.com/huggingface/transformers">HuggingFace’s transformers</a> repo took over a year to achieve a similar number of stars, and <a href="https://github.com/tensorflow/tensorflow">TensorFlow</a> repo took 4 months.</p>

<center>
<figure>
<img alt="LLM Engineering: Alpaca GitHub stars" src="https://huyenchip.com/assets/pics/llmops/7_alpaca_github_stars.png" style="float: center; margin: 0 0 0em 0em;" />
</figure>
</center>
<p><br /></p>

<h3 id="embeddings_vector_databases">Embeddings + vector databases</h3>

<p>One direction that I find very promising is to use LLMs to generate embeddings and then build your ML applications on top of these embeddings, e.g. for search and recsys. As of April 2023, the cost for embeddings using the smaller model <em>text-embedding-ada-002</em> is $0.0004/1k tokens. If each item averages 250 tokens (187 words), this pricing means $1 for every 10k items or $100 for 1 million items.</p>

<p>While this still costs more than some existing open-source models, this is still very affordable, given that:</p>

<ol>
  <li>You usually only have to generate the embedding for each item once.</li>
  <li>With OpenAI API, it’s easy to generate embeddings for queries and new items in real-time.</li>
</ol>

<p>To learn more about using GPT embeddings, check out <a href="https://github.com/Muennighoff/sgpt">SGPT</a> (Niklas Muennighoff, 2022) or this analysis <a href="https://medium.com/@nils_reimers/openai-gpt-3-text-embeddings-really-a-new-state-of-the-art-in-dense-text-embeddings-6571fe3ec9d9">on the performance and cost GPT-3 embeddings</a> (Nils Reimers, 2022). Some of the numbers in Nils’ post are already outdated (the field is moving so fast!!), but the method is great!</p>

<p>The main cost of embedding models for real-time use cases is loading these embeddings into a vector database for low-latency retrieval. However, you’ll have this cost regardless of which embeddings you use. It’s exciting to see so many vector databases blossoming – the new ones such as Pinecone, Qdrant, Weaviate, Chroma as well as the incumbents Faiss, Redis, Milvus, ScaNN.</p>

<p><strong>If 2021 was the year of graph databases, 2023 is the year of vector databases</strong>.</p>

<h3 id="backward_and_forward_compatibility">Backward and forward compatibility</h3>

<p><em>Hacker News discussion: <a href="https://news.ycombinator.com/item?id=36258882">Who is working on forward and backward compatibility for LLMs?</a></em></p>

<p>Foundational models can work out of the box for many tasks without us having to retrain them as much. However, they do need to be retrained or finetuned from time to time as they go outdated. According to Lilian Weng’s <a href="https://lilianweng.github.io/posts/2023-03-15-prompt-engineering/">Prompt Engineering post</a>:</p>

<p><em>One observation with <a href="https://situatedqa.github.io/">SituatedQA</a> dataset for questions grounded in different dates is that despite LM (pretraining cutoff is year 2020) has access to latest information via Google Search, its performance on post-2020 questions are still a lot worse than on pre-2020 questions. This suggests the existence of some discrepencies or conflicting parametric between contextual information and model internal knowledge.</em></p>

<p>In traditional software, when software gets an update, ideally it should still work with the code written for its older version. However, with prompt engineering, if you want to use a newer model, there’s no way to guarantee that all your prompts will still work as intended with the newer model, so you’ll likely have to rewrite your prompts again. <strong>If you expect the models you use to change at all, it’s important to unit-test all your prompts using evaluation examples.</strong></p>

<p>One argument I often hear is that prompt rewriting shouldn’t be a problem because:</p>

<ol>
  <li>Newer models should <em>only</em> work better than existing models. I’m not convinced about this. Newer models might, overall, be better, but there will be use cases for which newer models are worse.</li>
  <li>Experiments with prompts are fast and cheap, as we discussed in the section <strong>Cost</strong>. While I agree with this argument, a big challenge I see in MLOps today is that there’s a lack of centralized knowledge for model logic, feature logic, prompts, etc. An application might contain multiple prompts with complex logic (discussed in Part 2. Task composability). If the person who wrote the original prompt leaves, it might be hard to understand the intention behind the original prompt to update it. This can become similar to the situation when someone leaves behind a 700-line SQL query that nobody dares to touch.</li>
</ol>

<p>Another challenge is that prompt patterns are not robust to changes. For example, many of the published prompts I’ve seen start with “I want you to act as XYZ”. If OpenAI one day decides to print something like: “I’m an AI assistant and I can’t act like XYZ”, all these prompts will need to be updated.</p>

<h2 id="part_2_task_composability">Part 2. Task composability</h2>

<h3 id="applications_that_consist_of_multiple_tasks">Applications that consist of multiple tasks</h3>

<p>The example controversy scorer above consists of one single task: given an input, output a controversy score. Most applications, however, are more complex. Consider the “talk-to-your-data” use case where we want to connect to a database and query this database in natural language. Imagine a credit card transaction table. You want to ask things like: <code class="language-plaintext highlighter-rouge">"How many unique merchants are there in Phoenix and what are their names?"</code> and your database will return: <code class="language-plaintext highlighter-rouge">"There are 9 unique merchants in Phoenix and they are …"</code>.</p>

<p>One way to do this is to write a program that performs the following sequence of tasks:</p>

<ol>
  <li>Task 1: convert natural language input from user to SQL query [LLM]</li>
  <li>Task 2: execute SQL query in the SQL database [SQL executor]</li>
  <li>Task 3: convert the SQL result into a natural language response to show user [LLM]</li>
</ol>

<h3 id="agents_tools_and_control_flows">Agents, tools, and control flows</h3>

<p>I did a small survey among people in my network and there doesn’t seem to be any consensus on terminologies, yet.</p>

<p>The word agent is being thrown around a lot to refer to an application that can execute multiple tasks according to a given <strong>control flow</strong> (see Control flows section). A task can leverage one or more <strong>tools</strong>. In the example above, SQL executor is an example of a tool.</p>

<p>Note: some people in my network resist using the term agent in this context as it is already overused in other contexts (e.g. agent to refer to a policy in <a href="https://en.wikipedia.org/wiki/Reinforcement_learning">reinforcement learning</a>).</p>

<h4 id="tools_vs_plugins">Tools vs. plugins</h4>

<p>Other than SQL executor, here are more examples of tools:</p>

<ul>
  <li>search (e.g. by using Google Search API or Bing API)</li>
  <li>web browser (e.g. given a URL, fetch its content)</li>
  <li>bash executor</li>
  <li>calculator</li>
</ul>

<p>Tools and plugins are basically the same things. You can think of plugins as tools contributed to the OpenAI plugin store. As of writing, OpenAI plugins aren’t open to the public yet, but anyone can create and use tools.</p>

<h4 id="control_flows_sequential_parallel_if_for_loop">Control flows: sequential, parallel, if, for loop</h4>

<p>In the example above, sequential is an example of a control flow in which one task is executed after another. There are other types of control flows such as parallel, if statement, for loop.</p>

<ul>
  <li>Sequential: executing task B after task A completes, likely because task B depends on Task A. For example, the SQL query can only be executed after it’s been translated from the user input.</li>
  <li>Parallel: executing tasks A and B at the same time.</li>
  <li>If statement: executing task A or task B depending on the input.</li>
  <li>For loop: repeat executing task A until a certain condition is met. For example, imagine you use browser action to get the content of a webpage and keep on using browser action to get the content of links found in that webpage until the agent feels like it’s got sufficient information to answer the original question.</li>
</ul>

<p>Note: while parallel can definitely be useful, I haven’t seen a lot of applications using it.</p>

<center>
<figure>
<img alt="LLM Engineering: control flows" src="https://huyenchip.com/assets/pics/llmops/8_control_flows.png" style="float: center; margin: 0 0 0em 0em;" />
</figure>
</center>
<p><br /></p>

<h4 id="control_flow_with_llm_agents">Control flow with LLM agents</h4>

<p>In traditional software engineering, conditions for control flows are exact. With LLM applications (also known as agents), conditions might also be determined by prompting.</p>

<p>For example, if you want your agent to choose between three actions <strong>search</strong>, <strong>SQL executor</strong>, and <strong>Chat</strong>, you might explain how it should choose one of these actions as follows (very approximate), In other words, you can use LLMs to decide the condition of the control flow!</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>You have access to three tools: Search, SQL executor, and Chat.

Search is useful when users want information about current events or products. 

SQL executor is useful when users want information that can be queried from a database.

Chat is useful when users want general information.

Provide your response in the following format:

Input: { input }
Thought: { thought }
Action: { action }
Action Input: { action_input }
Observation: { action_output }
Thought: { thought }
</code></pre></div></div>

<h4 id="testing_an_agent">Testing an agent</h4>

<p>For agents to be reliable, we’d need to be able to build and test each task separately before combining them. There are two major types of failure modes:</p>

<ol>
  <li>One or more tasks fail. Potential causes:
    <ol>
      <li>Control flow is wrong: a non-optional action is chosen</li>
      <li>One or more tasks produce incorrect results</li>
    </ol>
  </li>
  <li>All tasks produce correct results but the overall solution is incorrect. Press et al. (2022) call this “<a href="https://ofir.io/self-ask.pdf">composability gap</a>”: the fraction of compositional questions that the model answers incorrectly out of all the compositional questions for which the model answers the sub-questions correctly.</li>
</ol>

<p>Like with software engineering, you can and should unit test each component as well as the control flow. For each component, you can define pairs of <code class="language-plaintext highlighter-rouge">(input, expected output)</code> as evaluation examples, which can be used to evaluate your application every time you update your prompts or control flows. You can also do integration tests for the entire application.</p>

<h2 id="part_3_promising_use_cases">Part 3. Promising use cases</h2>

<p>The Internet has been flooded with cool demos of applications built with LLMs. Here are some of the most common and promising applications that I’ve seen. I’m sure that I’m missing a ton.</p>

<p>For more ideas, check out the projects from two hackathons I’ve seen:</p>

<ul>
  <li><a href="https://docs.google.com/spreadsheets/d/1tmfn8jKb7T1x7PpyO7rD023tH2zc_WDg_OHh0aVXIrw/edit#gid=174517450">GPT-4 Hackathon Code Results</a> [Mar 25, 2023]</li>
  <li><a href="https://docs.google.com/spreadsheets/d/1GqwPo1FpAbe_awmNZW5ZMH69yc5QtEr7ZYw-ckaz_mQ/edit#gid=795016726">Langchain / Gen Mo Hackathon</a> [Feb 25, 2023]</li>
</ul>

<h3 id="ai_assistant">AI assistant</h3>

<p>This is hands down the most popular consumer use case. There are AI assistants built for different tasks for different groups of users – AI assistants for scheduling, making notes, pair programming, responding to emails, helping with parents, making reservations, booking flights, shopping, etc. – but, of course, the ultimate goal is an assistant that can assist you in everything.</p>

<p>This is also the holy grail that all big companies are working towards for years: Google with Google Assistant and Bard, Facebook with M and Blender, OpenAI (and by extension, Microsoft) with ChatGPT. Quora, which has a very high risk of being replaced by AIs, released their own app <a href="https://quorablog.quora.com/Poe-1">Poe</a> that lets you chat with multiple LLMs. I’m surprised Apple and Amazon haven’t joined the race yet.</p>

<h3 id="chatbot">Chatbot</h3>

<p>Chatbots are similar to AI assistants in terms of APIs. If AI assistants’ goal is to fulfill tasks given by users, whereas chatbots’ goal is to be more of a companion. For example, you can have chatbots that talk like celebrities, game/movie/book characters, businesspeople, authors, etc.</p>

<p>Michelle Huang used <a href="https://twitter.com/michellehuang42/status/1597005489413713921">her childhood journal entries as part of the prompt to GPT-3 to talk to the inner child</a>.</p>

<p>The most interesting company in the consuming-chatbot space is probably Character.ai. It’s a platform for people to create and share chatbots. The most popular types of chatbots on the platform, as writing, are anime and game characters, but you can also talk to a psychologist, a pair programming partner, or a language practice partner. You can talk, act, draw pictures, play text-based games (like AI Dungeon), and even enable voices for characters. I tried a few popular chatbots – none of them seem to be able to hold a conversation yet, but we’re just at the beginning. Things can get even more interesting if there’s a revenue-sharing model so that chatbot creators can get paid.</p>

<center>
<figure>
<img alt="LLM Engineering: AI chatbots" src="https://huyenchip.com/assets/pics/llmops/9_character_ai.png" style="float: center; margin: 0 0 0em 0em;" />
</figure>
</center>
<p><br /></p>

<h3 id="programming_and_gaming">Programming and gaming</h3>

<p>This is another popular category of LLM applications, as LLMs turn out to be incredibly good at writing and debugging code. GitHub Copilot is a pioneer (whose VSCode extension has had 5 million downloads as of writing). There have been pretty cool demos of using LLMs to write code:</p>

<ol>
  <li><strong><a href="https://twitter.com/sharifshameem/status/1284095222939451393">Create web apps from natural languages</a></strong></li>
  <li><strong>Find security threats</strong>: Socket AI examines <a href="https://socket.dev/blog/introducing-socket-ai-chatgpt-powered-threat-analysis">npm and PyPI packages in your codebase for security threats</a>. When a potential issue is detected, they use ChatGPT to summarize findings.</li>
  <li><strong>Gaming</strong>
    <ol>
      <li>Create games: e.g. Wyatt Cheng has an awesome video showing how he used <a href="https://www.youtube.com/watch?v=8y7GRYaYYQg">ChatGPT to clone Flappy Bird</a>.</li>
      <li>Generate game characters.</li>
      <li>Let you have more realistic conversations with game characters: <a href="https://www.youtube.com/watch?v=-R4PWIkgOSk">check out this awesome demo by Convai</a>!</li>
    </ol>
  </li>
</ol>

<h3 id="learning">Learning</h3>

<p>Whenever ChatGPT was down, OpenAI discord is flooded with students complaining about not being to complete their homework. Some responded by banning the use of ChatGPT in school altogether. Some have a much better idea: how to incorporate ChatGPT to help students learn even faster. All EdTech companies I know are going full-speed on ChatGPT exploration.</p>

<p>Some use cases:</p>

<ul>
  <li>Summarize books</li>
  <li>Automatically generate quizzes to make sure students understand a book or a lecture. Not only ChatGPT can generate questions, but it can also evaluate whether a student’s input answers are correct.
    <ul>
      <li>I tried and ChatGPT seemed pretty good at generating quizzes for Designing Machine Learning Systems. Will publish the quizzes generated soon!</li>
    </ul>
  </li>
  <li>Grade / give feedback on essays</li>
  <li>Walk through math solutions</li>
  <li>Be a debate partner: ChatGPT is really good at taking different sides of the same debate topic.</li>
</ul>

<p>With <a href="https://twitter.com/george__mack/status/1640010331606106112">the rise of homeschooling</a>, I expect to see a lot of applications of ChatGPT to help parents homeschool.</p>

<h3 id="talk_to_your_data">Talk-to-your-data</h3>

<p>This is, in my observation, the most popular enterprise application (so far). Many, many startups are building tools to let enterprise users query their internal data and policies in natural languages or in the Q&amp;A fashion. Some focus on verticals such as legal contracts, resumes, financial data, or customer support. Given a company’s all documentations, policies, and FAQs, you can build a chatbot that can respond your customer support requests.</p>

<p>The main way to do this application usually involves these 4 steps:</p>

<ol>
  <li>Organize your internal data into a database (SQL database, graph database, embedding/vector database, or just text database)</li>
  <li>Given an input in natural language, convert it into the query language of the internal database. For example, if it’s a SQL or graph database, this process can return a SQL query. If it’s embedding database, it’s might be an ANN (approximate nearest neighbor) retrieval query. If it’s just purely text, this process can extract a search query.</li>
  <li>Execute the query in the database to obtain the query result.</li>
  <li>Translate this query result into natural language.</li>
</ol>

<p>While this makes for really cool demos, I’m not sure how defensible this category is. I’ve seen startups building applications to let users query on top of databases like Google Drive or Notion, and it feels like that’s a feature Google Drive or Notion can implement in a week.</p>

<p>OpenAI has a pretty good <a href="https://github.com/openai/chatgpt-retrieval-plugin">tutorial on how to talk to your vector database</a>.</p>

<h4 id="can_llms_do_data_analysis_for_me">Can LLMs do data analysis for me?</h4>

<p>I tried inputting some data into gpt-3.5-turbo, and it seems to be able to detect some patterns. However, this only works for small data that can fit into the input prompt. Most production data is larger than that.</p>

<center>
<figure>
<img alt="LLM Engineering: data analysis" src="https://huyenchip.com/assets/pics/llmops/10_data_analysis.png" style="float: center; margin: 0 0 0em 0em;" />
</figure>
</center>
<p><br /></p>

<h3 id="search_and_recommendation">Search and recommendation</h3>

<p>Search and recommendation has always been the bread and butter of enterprise use cases. It’s going through a renaissance with LLMs. Search has been mostly keyword-based: you need a tent, you search for a tent. But what if you don’t know what you need yet? For example, if you’re going camping in the woods in Oregon in November, you might end up doing something like this:</p>

<ol>
  <li>Search to read about other people’s experiences.</li>
  <li>Read those blog posts and manually extract a list of items you need.</li>
  <li>Search for each of these items, either on Google or other websites.</li>
</ol>

<p>If you search for “things you need for camping in oregon in november” directly on Amazon or any e-commerce website, you’ll get something like this:</p>

<center>
<figure>
<img alt="LLM Engineering: Search" src="https://huyenchip.com/assets/pics/llmops/11_search_existing.png" style="float: center; margin: 0 0 0em 0em;" />
</figure>
</center>
<p><br /></p>

<p>But what if searching for “things you need for camping in oregon in november” on Amazon actually returns you a list of things you need for your camping trip?</p>

<p>It’s possible today with LLMs. For example, the application can be broken into the following steps:</p>

<ol>
  <li>Task 1: convert the user query into a list of product names [LLM]</li>
  <li>Task 2: for each product name in the list, retrieve relevant products from your product catalog.</li>
</ol>

<center>
<figure>
<img alt="LLM Engineering" src="https://huyenchip.com/assets/pics/llmops/12_search.png" style="float: center; margin: 0 0 0em 0em;" />

<img alt="LLM Engineering" src="https://huyenchip.com/assets/pics/llmops/13_search.png" style="float: center; margin: 0 0 0em 0em;" />
</figure>
</center>
<p><br /></p>

<p>If this works, I wonder if we’ll have LLM SEO: techniques to get your products recommended by LLMs.</p>

<h3 id="sales">Sales</h3>

<p>The most obvious way to use LLMs for sales is to write sales emails. But nobody really wants more or better sales emails. However, several companies in my network are using LLMs to synthesize information about a company to see what they need.</p>

<h3 id="seo">SEO</h3>

<p>SEO is about to get very weird. Many companies today rely on creating a lot of content hoping to rank high on Google. However, given that LLMs are REALLY good at generating content, and I already know a few startups whose service is to create unlimited SEO-optimized content for any given keyword, search engines will be flooded. SEO might become even more of a cat-and-mouse game: search engines come up with new algorithms to detect AI-generated content, and companies get better at bypassing these algorithms. People might also rely less on search, and more on brands (e.g. trust only the content created by certain people or companies).</p>

<p>And we haven’t even touched on SEO for LLMs yet: how to inject your content into LLMs’ responses!!</p>

<h2 id="conclusion">Conclusion</h2>

<p>We’re still in the early days of LLMs applications – everything is evolving so fast. I recently read a book proposal on LLMs, and my first thought was: most of this will be outdated in a month. APIs are changing day to day. New applications are being discovered. Infrastructure is being aggressively optimized. Cost and latency analysis needs to be done on a weekly basis. New terminologies are being introduced.</p>

<p>Not all of these changes will matter. For example, many prompt engineering papers remind me of the early days of deep learning when there were thousands of papers describing different ways to initialize weights. I imagine that tricks to tweak your prompts like: <code class="language-plaintext highlighter-rouge">"Answer truthfully"</code>, <code class="language-plaintext highlighter-rouge">"I want you to act like …"</code>, writing <code class="language-plaintext highlighter-rouge">"question: "</code> instead of <code class="language-plaintext highlighter-rouge">"q:"</code> wouldn’t matter in the long run.</p>

<p>Given that LLMs seem to be pretty good at writing prompts for themselves – see <a href="https://arxiv.org/abs/2211.01910">Large Language Models Are Human-Level Prompt Engineers</a> (Zhou et al., 2022) – who knows that we’ll need humans to tune prompts?</p>

<p>However, given so much happening, it’s hard to know which will matter, and which won’t.</p>

<p>I recently asked on <a href="https://www.linkedin.com/feed/update/urn:li:activity:7051061478405115904/">LinkedIn</a> how people keep up to date with the field. The strategy ranges from ignoring the hype to trying out all the tools.</p>

<ol>
  <li>
    <p>Ignore (most of) the hype</p>

    <p><a href="https://www.linkedin.com/in/vickiboykis/">Vicki Boykis</a> (Senior ML engineer @ Duo Security): <em>I do the same thing as with any new frameworks in engineering or the data landscape: I skim the daily news, ignore most of it, and wait six months to see what sticks. Anything important will still be around, and there will be more survey papers and vetted implementations that help contextualize what’s happening.</em></p>
  </li>
  <li>
    <p>Read only the summaries</p>

    <p><a href="https://www.linkedin.com/in/shashankch9009/">Shashank Chaurasia</a> (Engineering @ Microsoft): <em>I use the Creative mode of BingChat to give me a quick summary of new articles, blogs and research papers related to Gen AI! I often chat with the research papers and github repos to understand the details.</em></p>
  </li>
  <li>
    <p>Try to keep up to date with the latest tools</p>

    <p><a href="https://www.linkedin.com/in/csalexiuk/">Chris Alexiuk</a> (Founding ML engineer @ Ox): <em>I just try and build with each of the tools as they come out - that way, when the next step comes out, I’m only looking at the delta.</em></p>
  </li>
</ol>

<p>What’s your strategy?</p>
]]></content:encoded>
<pubDate>Tue, 11 Apr 2023 00:00:00 +0000</pubDate>
</item>
<item>
<title>What we look for in a resume</title>
<link>https://huyenchip.com//2023/01/24/what-we-look-for-in-a-candidate.html</link>
<guid>https://huyenchip.com//2023/01/24/what-we-look-for-in-a-candidate.html</guid>
<content:encoded><![CDATA[
<div> 面试、简历、技能、项目、成就
<br /><br />总结:该文章讨论了如何撰写简历以吸引初创公司的注意。首先指出初创公司与大公司的招聘方式不同，强调初创公司更看重候选人的专业知识和实际能力。同时强调展示专业知识的重要性，建议在简历中展示技能的获取途径和应用。此外，还强调在简历中展示解决问题的能力和独特视角，重点关注影响力，而非无意义的指标。最后强调在撰写简历过程中应注重清晰传达自己的贡献和成就。 <div>
<p>I read every single one of the resumes we receive. Sometimes, I’d talk to a candidate and see that what we perceived as their strongest aspects actually weren’t included in their resume. Occasionally, a candidate would tell me that they didn’t expect their resume to still be screened by humans – had they known, they would have written their resume differently.</p>

<p>The resume evaluation process is pretty much a black box for most candidates. And it is so because few hiring managers have publicly discussed this. I thought I should start the conversation.</p>

<p>“Resume” here refers to both the traditional resumes and LinkedIn profiles. If your LinkedIn is current and contains all the information you want to share, that’s perfectly fine. Some hiring managers I know at other companies actually prefer looking at LinkedIn because they find it faster to find the info they need (e.g. company logos, time spent at each company). I’ve also seen candidates who use their personal websites as their resumes, which also works.</p>

<p>Whether you’re interested in applying to our startup, I hope that my perspective can shed some light on what is happening on the other side of the table, and how to create a resume that helps you put your best foot forward, not just with us, but also with other companies. Caveat: <strong>Every company hires differently. What’s right for us might not be right for other companies.</strong></p>

<p>Job hunting is exhausting, and sometimes feels like a shot in the dark. I wish more companies would be transparent about what they’re looking for so that candidates can decide before they apply if they are a good fit.</p>

<p><strong>Disclaimer</strong>:</p>

<ol>
  <li>We hire mostly <a href="https://www.claypot.ai/work-with-us">infra and ML roles</a>, so this post might not be applicable to other roles.</li>
  <li>We’re very small so what we’re looking for is specific. If you’re not a good fit for us right now doesn’t mean you aren’t a good fit anywhere else, or won’t be a good fit for us in the future.</li>
</ol>

<hr />
<p><b>Table of contents</b><br />
…. <a href="https://huyenchip.com/feed.xml#overall_approach">1. Our overall approach</a><br />
…. <a href="https://huyenchip.com/feed.xml#demonstrated_expertise">2. We look for demonstrated expertise, not keywords</a><br />
…. <a href="https://huyenchip.com/feed.xml#get_things_done">3. We look for people who get things done</a><br />
…. <a href="https://huyenchip.com/feed.xml#unique_perspectives">4. We look for unique perspectives</a><br />
…. <a href="https://huyenchip.com/feed.xml#impact">5. We care about impact, not meaningless metrics</a><br />
…. <a href="https://huyenchip.com/feed.xml#faqs">FAQs</a><br />
…….. <a href="https://huyenchip.com/feed.xml#one-page">Do resumes have to be one page?</a><br />
…….. <a href="https://huyenchip.com/feed.xml#no-experience">What to put on my resume if I have no experience yet?</a><br />
…….. <a href="https://huyenchip.com/feed.xml#cover-letter">Do I need a cover letter?</a><br />
…. <a href="https://huyenchip.com/feed.xml#misc-tips">Misc tips</a><br /></p>

<hr />
<p><br /></p>
<h2 id="overall_approach">1. Our overall approach</h2>

<p>Startups like us and big companies, say Google, hire very differently. Therefore, it makes sense that a candidate should apply to a startup differently from how they’d apply to a big company.</p>

<p>Here is what we do, which might differ from what big companies do.</p>

<ol>
  <li>
    <p><strong>We don’t use an automated system to screen resumes</strong>.</p>

    <p>We read every resume. This means that a lot of tricks you’ve read about how to beat automated screening such as include certain phrases of job descriptions in your resume, repeat “hot” keywords, fill your resumes up with random metrics, etc. doesn’t work on us. They can even hurt when you apply to companies like us, because the resume space used for these tricks is the space you aren’t using for things that are relevant to us.</p>
  </li>
  <li>
    <p><strong>We look for reasons to say yes.</strong></p>

    <p>For a company that receives a large volume of resumes (much larger than us), they’ll need a way to quickly filter out resumes, aka quick ways to say no. For example, their automated algorithm might reject a resume if it lacks certain years of experience or lacks certain keywords. For us, we evaluate each application holistically, and if your application demonstrates the aspects we’re looking for, as discussed in this post, we’d want to get on a call to get to know you more.</p>
  </li>
</ol>

<h2 id="demonstrated_expertise">2. We look for demonstrated expertise, not keywords</h2>

<p>About 90% of resumes we see have a long list of skills. Here are just some examples.</p>

<center>
<figure>
<img alt="Skill box" src="https://huyenchip.com/assets/pics/resumes/skills1.png" style="float: center; margin: 0 0 0em 0em;" />

<img alt="Skill box" src="https://huyenchip.com/assets/pics/resumes/skills2.png" style="float: center; margin: 0 0 0em 0em;" />

<img alt="Skill box" src="https://huyenchip.com/assets/pics/resumes/skills3.png" style="float: center; margin: 0 0 0em 0em;" />
</figure>
</center>
<p><br /></p>

<p>Initially, I was confused about the purpose of this list, because:</p>

<ol>
  <li><strong>It’s unconvincing</strong>. There’s a big gap between “saying that you know something” and “being good at it.”</li>
  <li><strong>It can weaken your resume</strong>. For example, if you consider common skills like Jupyter notebook and git your competitive advantage (the only reason to include them in your resume), I would automatically assume that you have no other competitive advantage.</li>
  <li>Expertise takes time to acquire. <strong>I’m skeptical of people who claim to be experts in too many things</strong>.</li>
</ol>

<p>As I tried to figure out why, I found a world of articles that give tips on how to beat automated resume screening. These articles claim that at large companies that receive an influx of resumes, recruiters set rules to surface resumes that contain certain keywords. Candidates, not sure what these keywords are, populate their resumes with all the keywords they can think of.</p>

<p>That is a bad strategy for applying at startups like ours. We’re not looking for keywords. We look for demonstrated expertise. Here are a couple of ways to demonstrate your expertise.</p>

<ol>
  <li>
    <p><strong>Show how you acquired and use that skill in your job</strong></p>

    <p>Consider these two candidates who both mention Flink on their resumes. Which one would you want to talk to?</p>

    <ul>
      <li>Candidate A has Flink as one of the 30 items on their Technical skills box.</li>
      <li>Candidate B explained how they used Flink in their last job: “<em>worked on a feature computation platform built on top of Apache Flink which processes 100,000 events per second and serves 10 different ML models</em>.”</li>
    </ul>

    <p>If during our interview, candidate B can tell me why they chose Flink over other stream processing engines, what issues they’ve encountered, and what changes they wish to see in Flink, I’d be sold!</p>
  </li>
  <li>
    <p><strong>Share your expertise on public channels such as: StackOverflow answers, open source contributions, papers, blog posts</strong></p>

    <p>Here are some examples that convinced me of a candidate’s expertise in certain technology:</p>

    <ul>
      <li>A candidate sent us their StackOverflow profile where they have answered over 100 questions on JavaScript.</li>
      <li>Another sent us a list of their merged PRs to PyTorch.</li>
      <li>Another sent us a blog post that covers in-depth detail about X that made our team go: “whoa, they really know about X.”</li>
    </ul>

    <p><em>We understand that not everyone has time to contribute to public discourse, so #2 is optional.</em></p>
  </li>
</ol>

<h2 id="get_things_done">3. We look for people who get things done</h2>

<p>A lot of people get attracted to a startup for its vision: what this startup can be in the next 5 or 10 years. However, once you join the startup, what really matters is the day-to-day execution. When I was at Snorkel, our CEO kept telling us: “Startups don’t magically move faster than big companies just because they are startups. Startups move faster because they have to.” We have to get things done. To be able to move fast, we need people who aren’t afraid to roll up their sleeves and tackle difficult challenges.</p>

<p>There are two traits we look for to evaluate whether a candidate can get things done: initiatives and persistence. If you have experience that demonstrates these, please do include them in your resume.</p>

<h3 id="initiatives">Initiatives</h3>

<p>To get anything done, you need to start it. There are a lot of people who can see a problem, but few who would do something about it. We want people who, when seeing a problem, proactively do something about it without waiting to be told. We look for initiatives a candidate has started before, such as:</p>

<ul>
  <li>A student club, an event, a team, a project at work. A project that you initiate doesn’t have to be about something new. Projects like writing documents or improving existing CI/CD are also extremely valuable.</li>
  <li>A startup. A founder told me that his best hires are people who have previously founded a company, even if that company didn’t work out. They know the drill.</li>
</ul>

<h3 id="persistence">Persistence</h3>

<p>Once we’ve started something, we need persistence to drive it to completion. Some signals of persistence that I’ve seen:</p>

<ul>
  <li>Daily contribution to GitHub for one whole year.</li>
  <li>Being good at anything that requires consistent effort, e.g. a Kaggle master, a chess master, a professional athlete, etc.</li>
  <li>Having previously joined another early startup before and stuck around.</li>
</ul>

<p>I’m a bit hesitant when I see candidates who change jobs too frequently, e.g. 5 different companies in 5 years. I understand that not all jobs work out, so it’s okay, sometimes necessary, to move on. However, consistent job jumping can imply that you get bored or give up easily. A year at a job is hardly enough to get deep into a problem space and make significant contributions.</p>

<p>Working at a startup can be tough, and we don’t want someone who joins and leaves at the first sign of challenge. We want someone to stick around and help us through different phases. This process, I hope, can also provide you with a diverse set of experiences to prepare you for whatever you want to do after.</p>

<h2 id="unique_perspectives">4. We look for unique perspectives</h2>

<p>Startups like ours exist to solve a problem that few others can solve. This requires us to see the problem from a perspective that most people don’t. For that reason, we’re not looking for group thinkers or hype chasers. We look for people who can bring a unique perspective to the table.</p>

<p>Your unique perspective can be demonstrated in your career/life choices, your writing, your side projects.</p>

<p>Recently, I had a panel discussing resume screening on our MLOps Discord, and Kyle Kranen, a senior deep learning engineer from NVIDIA, discouraged candidates from listing cookie-cutter projects on their resumes, as they take away space for things that are uniquely your strengths.</p>

<p>Cookie-cutter projects happen when someone simply replicates a common solution to a popular project – titanic, sentiment analysis of tweets, stock trading, chatbots – without any new approach or insight. I see them in about ⅓ of all the resumes we’ve received. These projects are good to practice on. I myself practiced on them when I started. However, they won’t help you stand out as a candidate.</p>

<p>Examples of interesting projects that I’ve seen:</p>

<ol>
  <li>A personal website that looks exactly like MacOS.</li>
  <li>A CLI tool to autocomplete your bash commands.</li>
  <li>Matcha-making robot arm.</li>
</ol>

<h2 id="impact">5. We care about impact, not meaningless metrics</h2>

<p>I recently asked on LinkedIn how resumes have become so metrics-oriented. Almost all resumes I’ve seen are full of metrics. Metrics are good when they serve to make a point. However, many of these metrics leave me more confused than impressed. For example, here are some of the actual metrics I’ve seen:</p>

<ul>
  <li>Built a Transformer-based model that achieved an accuracy of 89% (no info on the task or the baseline)</li>
  <li>Work on 15 different domains.</li>
  <li>Participated in over 300+ code reviews (not sure what this is supposed to show. If I do a code review a day, it’d only take me a year to reach this number, which really doesn’t say much.)</li>
</ul>

<p>People were quick to point out to me: the most common advice for writing resumes is “quantify your impact,” e.g. how much money you’ve saved for your company, how much faster you’ve made your program. Due to this advice, many candidates have told me that they need to have metrics on their resumes. Sometimes, when unable to quantify their impact, they settle for what they can quantify.</p>

<p>Unfortunately, not all that are quantifiable are impactful. Showing the number of code reviews you’ve participated in, without any context, doesn’t say anything flattering. It’d be better if you could show how the learnings from all these code reviews are relevant to the role you’re applying for: e.g. how they helped you become a better engineer.</p>

<h3 id="clarify-your-contributions">Clarify your contributions</h3>

<p>Every job seeker should make their resume look as good as possible. I’ve talked to many candidates who are uncomfortable talking about their achievements, either due to humility or shyness. This is especially common among female candidates that I’ve talked to.</p>

<p>On the other hand, I’ve seen many candidates who take this too far. For example, last week, a candidate wrote that they have <em>extensive</em> experience in deploying large scale systems because of their one Amazon internship.</p>

<p>Often, I’d see a candidate who takes credit for the entire team. An applicant said on his resume that he “deployed an online prediction model that served 10M daily active users.” During our interview, I found out that he wasn’t at all involved in deployment nor in scaling the prediction service. His task was wrangling data from an S3 bucket. To be clear, this is an important skill, just not what we were looking for. We explicitly said we were looking for experience in deploying models in production. This interview was a waste of time for both of us.</p>

<h3 id="metrics-that-wed-love-to-see">Metrics that we’d love to see</h3>

<p>I do care about metrics. I especially appreciate metrics that are presented with two components:</p>

<ol>
  <li>How they can be tied to business objectives.</li>
  <li>Your contribution in achieving that metric.</li>
</ol>

<p>Here are some of the metrics that we’ve found convincing:</p>

<ul>
  <li>Part of a 2-data-scientist team that owns feature engineering for a fraud detection system. Added 200 new features, resulting in a reducing the false positive rate from 20% to 15%, while keeping the false negative the same.</li>
  <li>Built caching strategy using application-level caching &amp; Redis for 2000 QPS, leading to a decrease in response time by 50%.</li>
</ul>

<center>
<figure>
<img alt="Good impact" src="https://huyenchip.com/assets/pics/resumes/impact1.png" style="float: center; margin: 0 0 0em 0em;" />

<img alt="Good impact" src="https://huyenchip.com/assets/pics/resumes/impact2.png" style="float: center; margin: 0 0 0em 0em;" />

</figure>
Screenshotted from the resumes submitted to our resume critique session
</center>
<p><br /></p>

<h3 id="not-all-impact-has-metrics">Not all impact has metrics</h3>

<p>Fixing a bug or helping a coworker out is impactful, but hard to measure. It’s a great signal when your work receives awards and recognitions, such as:</p>

<ul>
  <li>An internal company award (e.g. intern of the year, MVP, founder award, winning hackathon)</li>
  <li>Promotions, e.g. I was impressed with a candidate that went from being a data scientist to a senior MLE to a staff MLE within 4 years.</li>
  <li>Glowing recommendations from previous teammates and managers. We actually made an offer to a candidate after two of their references talked about how much this candidate helped and mentored them.</li>
</ul>

<h2 id="faqs">FAQs</h2>

<h3 id="one-page">Do resumes have to be one page?</h3>

<p>A candidate told me, during our interview, that he didn’t include his side projects in his resume because he was worried that it’d take him over the one-page limit. To be clear, I’m NOT going to reject a candidate just because their resume is over one page.</p>

<p>The one-page limit suggestion is to help you be concise. Like the French mathematician Blaise Pascal once said: “<em>I have only made this letter longer because I have not had the time to make it shorter</em>.” The longer your resume goes on, the more chance that your biggest strengths will be buried among less important details.</p>

<p>The goal of a resume is not to show <em>everything</em> about you. The goal is to put your best foot forward to show a company why you’d be an excellent addition to their team. Rarely do I see a candidate whose best foot forward can’t be contained within one page.</p>

<p>If you have a lot of experience, you should have more options to choose from to highlight your strengths. A 3-page resume without any focus or highlight shows the lack of judgment for what is important and concise communication.</p>

<p>What I find a lot harder is for candidates new to the field to have sufficient things to fill in one page.</p>

<h4 id="some-tips-to-shorten-your-resume">Some tips to shorten your resume</h4>

<ol>
  <li>Find repetition and remove them. For example, do you need to list all 5 of your personal projects, or the top 3 would suffice?</li>
  <li>Remove irrelevant experience, even if that creates gaps in your resume. Personally, I don’t care about gaps – everyone needs time to recharge and take care of personal matters.</li>
  <li>Most resumes I’ve seen can have shorter education sections.</li>
  <li>Remove common skills, e.g. git, notebook, MS Word/Excel.</li>
  <li>Find a more efficient format, e.g. using multiple columns.</li>
  <li>Reduce font size, page margin.</li>
</ol>

<h3 id="no-experience">What to put on my resume if I have no experience yet?</h3>

<p>This is a tough question. If you don’t have the experience a role needs, it doesn’t matter what you put on your resume, that role is just not going to be a good fit for you.</p>

<p>I have, however, been impressed by candidates who make up for their lack of experience in our field with impressive experiences in other fields.</p>

<p>Personally, I was once given an internship at a startup, even though I had none of the experiences they were asking for. I reached out to the CEO explaining to him the problems I worked on in the past and how the skills I acquired can be transferred to the problems his company was working on.</p>

<p>It’s a long shot, but it’s a shot.</p>

<h3 id="cover-letter">Do I need a cover letter?</h3>

<p>The order in which I read an application: resume -&gt; cover letter. If you have stellar experience and skills, we’d want to talk to you even if you don’t have a cover letter. Some hiring managers told me that they don’t read cover letters at all.</p>

<p>I, however, do appreciate it when a candidate writes a cover letter that explains why they want to join us and why they think they’re a good fit for the role. For candidates with unusual transitions (e.g. switching from another career into machine learning), a cover letter could also be a great place to explain their transition.</p>

<p>If you write a cover letter, keep it concise. A cover letter doesn’t have to be a PDF. It can just be an email.</p>

<p>If an information is important, include it in your resume instead of a cover letter. Sometimes, candidates put the important info in the email they sent to our team’s email address, which might not be entered correctly into our application tracking system.</p>

<h2 id="misc-tips">Misc tips</h2>

<h3 id="general">General</h3>

<ol>
  <li>If you’re applying to a small startup, say, of less than 20 people, spend some time researching who works at that startup and email them directly.</li>
  <li>Send your resume as a PDF instead of an editable format like Microsoft Word or Google Docs. The editable format might not render correctly on other people’s computers.</li>
  <li>If you can get someone who used to supervise you to talk about how great you are, include their quote in your resume. Quotes from friends/family don’t count.</li>
  <li>Don’t use abbreviations unless you know for sure your audience knows what you’re talking about.</li>
</ol>

<h3 id="public-links">Public links</h3>

<ol>
  <li>If you’ve contributed to open source projects, include links to the PRs or a public architectural design you’re the most proud of.</li>
  <li>If your GitHub has a lot of repos, pin the important ones on your homepage (you can pin up to 6). You can also write a README to guide your visitors on what repos they would look at.</li>
  <li>Don’t include a link to your GitHub link if it’s empty.</li>
  <li>If you have publications, link to your Google Scholar profile.</li>
  <li>If you’re a co-author of a paper with multiple authors, bold your name in the author list.</li>
  <li>If you have more to show than your resume allows, create a personal website. Assuming that you have basic coding skills, it’s fairly easy to create a free personal website using GitHub Pages.</li>
</ol>

<h3 id="education">Education</h3>

<ol>
  <li>If you’re still in school, put education earlier in your resume, as it helps the person screening your resume knows where you are and what you’re looking for. If you’ve been working, put your work experience first.</li>
  <li>If you’re still in school, list your expected graduation date so companies know when you can start working full-time.</li>
  <li>If you’ve been working for 2+ years, remove your GPA and coursework. I care more about your work experience.</li>
  <li>Similarly, course projects should only be listed if you think they’re better than the average course project.</li>
</ol>

<h3 id="resume-resources">Resume resources</h3>

<p>There are many resources on how to write a resume. Here are some of them:</p>

<ol>
  <li><a href="https://www.reddit.com/r/EngineeringResumes/wiki/index/">Reddit has a great guide on engineering resumes</a></li>
  <li><a href="https://www.ycombinator.com/library/FB-writing-a-great-resume">Writing a great resume : YC Ultimate Startup Job Guide</a></li>
  <li><a href="https://www.inc.com/bill-murphy-jr/google-recruiters-say-these-5-resume-tips-including-x-y-z-formula-will-improve-your-odds-of-getting-hired-at-google.html">Google Recruiters Say Using the X-Y-Z Formula on Your Resume Will Improve Your Odds of Getting Hired at Google</a></li>
  <li><a href="https://www.linkedin.com/pulse/why-resume-screening-doesnt-work-randy-mccloskey-mba/">Why Resume Screening Doesn’t Work</a></li>
  <li><a href="https://www.wsj.com/articles/companies-need-more-workers-why-do-they-reject-millions-of-resumes-11630728008">Companies Need More Workers. Why Do They Reject Millions of Résumés? - WSJ</a></li>
</ol>

<h2 id="conclusion">Conclusion</h2>
<p>Resume writing is a one-off process: it’s the art of arranging what you already have in a way to best help you stand out. It’s hard to write a good resume without having things to put on it.</p>

<p>Resume building is an ongoing process: continuously improve the experience, skills, recommendations, etc. that you have. If you’re good at building, you might not even have to write a resume. If your work catches companies’ attention, they’ll reach out to you.</p>

<p>A few friends told me that “resume building” has a bad connotation, as it might suggest that we should only do things to put on their resumes and ignore important but less shiny things like fixing a bug or helping a coworker out.</p>

<p>What we’re really looking for isn’t the best resume or the best resume builder, but a team member, someone who cares. Resumes might not be the perfect tool to show that, and that’s why we err on the side of talking to that person to find out.</p>

<p>Our startup is still young and we’re still learning. I’d love to learn about this process at other companies, and hear from you what we can do to make the process easier for you.</p>

<p>And of course, we’re hiring for strong <a href="https://www.claypot.ai/work-with-us">infra and ML engineers</a>!! If you think we might be a good fit for you, do reach out.</p>
]]></content:encoded>
<pubDate>Tue, 24 Jan 2023 00:00:00 +0000</pubDate>
</item>
</channel>
</rss>